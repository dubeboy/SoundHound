/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/EmailPassword/FIREmailAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIREmailAuthProvider.h"
   18|       |
   19|       |#import "FIREmailPasswordAuthCredential.h"
   20|       |
   21|       |// FIREmailPasswordAuthProviderID is defined in FIRAuthProvider.m.
   22|       |
   23|       |@implementation FIREmailAuthProvider
   24|       |
   25|      0|- (instancetype)init {
   26|      0|  @throw [NSException exceptionWithName:@"Attempt to call unavailable initializer."
   27|      0|                                 reason:@"This class is not meant to be initialized."
   28|      0|                               userInfo:nil];
   29|      0|}
   30|       |
   31|      0|+ (FIRAuthCredential *)credentialWithEmail:(NSString *)email password:(NSString *)password {
   32|      0|  return [[FIREmailPasswordAuthCredential alloc] initWithEmail:email password:password];
   33|      0|}
   34|       |
   35|      0|+ (FIRAuthCredential *)credentialWithEmail:(NSString *)email link:(NSString *)link {
   36|      0|  return [[FIREmailPasswordAuthCredential alloc] initWithEmail:email link:link];
   37|      0|}
   38|       |
   39|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/EmailPassword/FIREmailPasswordAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIREmailPasswordAuthCredential.h"
   18|       |
   19|       |#import "FIREmailAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |@interface FIREmailPasswordAuthCredential ()
   24|       |
   25|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FIREmailPasswordAuthCredential
   30|       |
   31|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   32|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   33|      0|      @"Please call the designated initializer."];
   34|      0|  return nil;
   35|      0|}
   36|       |
   37|      0|- (nullable instancetype)initWithEmail:(NSString *)email password:(NSString *)password {
   38|      0|  self = [super initWithProvider:FIREmailAuthProviderID];
   39|      0|  if (self) {
   40|      0|    _email = [email copy];
   41|      0|    _password = [password copy];
   42|      0|  }
   43|      0|  return self;
   44|      0|}
   45|       |
   46|      0|- (nullable instancetype)initWithEmail:(NSString *)email link:(NSString *)link {
   47|      0|  self = [super initWithProvider:FIREmailAuthProviderID];
   48|      0|  if (self) {
   49|      0|    _email = [email copy];
   50|      0|    _link = [link copy];
   51|      0|  }
   52|      0|  return self;
   53|      0|}
   54|       |
   55|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   56|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   57|      0|      @"Attempt to call prepareVerifyAssertionRequest: on a FIREmailPasswordAuthCredential."];
   58|      0|}
   59|       |
   60|       |#pragma mark - NSSecureCoding
   61|       |
   62|      0|+ (BOOL)supportsSecureCoding {
   63|      0|  return YES;
   64|      0|}
   65|       |
   66|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   67|      0|  NSString *email = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"email"];
   68|      0|  NSString *password = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"password"];
   69|      0|  NSString *link = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"link"];
   70|      0|  if (email.length && password.length) {
   71|      0|    self = [self initWithEmail:email password:password];
   72|      0|  } else if (email.length && link.length) {
   73|      0|    self = [self initWithEmail:email link:link];
   74|      0|  } else {
   75|      0|    self = nil;
   76|      0|  }
   77|      0|  return self;
   78|      0|}
   79|       |
   80|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   81|      0|  [aCoder encodeObject:self.email forKey:@"email"];
   82|      0|  [aCoder encodeObject:self.password forKey:@"password"];
   83|      0|  [aCoder encodeObject:self.link forKey:@"link"];
   84|      0|}
   85|       |
   86|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/Facebook/FIRFacebookAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRFacebookAuthCredential.h"
   18|       |
   19|       |#import "FIRFacebookAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |@interface FIRFacebookAuthCredential ()
   24|       |
   25|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FIRFacebookAuthCredential {
   30|       |  NSString *_accessToken;
   31|       |}
   32|       |
   33|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   34|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   35|      0|      @"Please call the designated initializer."];
   36|      0|  return nil;
   37|      0|}
   38|       |
   39|      0|- (nullable instancetype)initWithAccessToken:(NSString *)accessToken {
   40|      0|  self = [super initWithProvider:FIRFacebookAuthProviderID];
   41|      0|  if (self) {
   42|      0|    _accessToken = [accessToken copy];
   43|      0|  }
   44|      0|  return self;
   45|      0|}
   46|       |
   47|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   48|      0|  request.providerAccessToken = _accessToken;
   49|      0|}
   50|       |
   51|       |#pragma mark - NSSecureCoding
   52|       |
   53|      0|+ (BOOL)supportsSecureCoding {
   54|      0|  return YES;
   55|      0|}
   56|       |
   57|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   58|      0|  NSString *accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"accessToken"];
   59|      0|  self = [self initWithAccessToken:accessToken];
   60|      0|  return self;
   61|      0|}
   62|       |
   63|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   64|      0|  [aCoder encodeObject:_accessToken forKey:@"accessToken"];
   65|      0|}
   66|       |
   67|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/Facebook/FIRFacebookAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRFacebookAuthProvider.h"
   18|       |
   19|       |#import "FIRFacebookAuthCredential.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |
   22|       |// FIRFacebookAuthProviderID is defined in FIRAuthProvider.m.
   23|       |
   24|       |@implementation FIRFacebookAuthProvider
   25|       |
   26|      0|- (instancetype)init {
   27|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   28|      0|      @"This class is not meant to be initialized."];
   29|      0|  return nil;
   30|      0|}
   31|       |
   32|      0|+ (FIRAuthCredential *)credentialWithAccessToken:(NSString *)accessToken {
   33|      0|  return [[FIRFacebookAuthCredential alloc] initWithAccessToken:accessToken];
   34|      0|}
   35|       |
   36|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/GameCenter/FIRGameCenterAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGameCenterAuthCredential.h"
   18|       |
   19|       |#import "FIRAuthExceptionUtils.h"
   20|       |#import "FIRAuthCredential_Internal.h"
   21|       |#import "FIRGameCenterAuthProvider.h"
   22|       |#import "FIRVerifyAssertionRequest.h"
   23|       |
   24|       |@implementation FIRGameCenterAuthCredential
   25|       |
   26|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   27|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   28|      0|     @"Please call the designated initializer."];
   29|      0|  return nil;
   30|      0|}
   31|       |
   32|       |- (nullable instancetype)initWithPlayerID:(NSString *)playerID
   33|       |                             publicKeyURL:(NSURL *)publicKeyURL
   34|       |                                signature:(NSData *)signature
   35|       |                                     salt:(NSData *)salt
   36|       |                                timestamp:(uint64_t)timestamp
   37|      0|                              displayName:(NSString *)displayName {
   38|      0|  self = [super initWithProvider:FIRGameCenterAuthProviderID];
   39|      0|  if (self) {
   40|      0|    _playerID = [playerID copy];
   41|      0|    _publicKeyURL = [publicKeyURL copy];
   42|      0|    _signature = [signature copy];
   43|      0|    _salt = [salt copy];
   44|      0|    _timestamp = timestamp;
   45|      0|    _displayName = [displayName copy];
   46|      0|  }
   47|      0|  return self;
   48|      0|}
   49|       |
   50|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   51|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   52|      0|      @"Attempt to call prepareVerifyAssertionRequest: on a FIRGameCenterAuthCredential."];
   53|      0|}
   54|       |
   55|       |#pragma mark - NSSecureCoding
   56|       |
   57|      0|+ (BOOL)supportsSecureCoding {
   58|      0|  return YES;
   59|      0|}
   60|       |
   61|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   62|      0|  NSString *playerID = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"playerID"];
   63|      0|  NSURL *publicKeyURL = [aDecoder decodeObjectOfClass:[NSURL class] forKey:@"publicKeyURL"];
   64|      0|  NSData *signature = [aDecoder decodeObjectOfClass:[NSData class] forKey:@"signature"];
   65|      0|  NSData *salt = [aDecoder decodeObjectOfClass:[NSData class] forKey:@"salt"];
   66|      0|  NSNumber *timestamp = [aDecoder decodeObjectOfClass:[NSNumber class] forKey:@"timestamp"];
   67|      0|  NSString *displayName = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"displayName"];
   68|      0|  self = [self initWithPlayerID:playerID
   69|      0|                   publicKeyURL:publicKeyURL
   70|      0|                      signature:signature
   71|      0|                           salt:salt
   72|      0|                      timestamp:timestamp.unsignedLongLongValue
   73|      0|                    displayName:displayName];
   74|      0|  return self;
   75|      0|}
   76|       |
   77|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   78|      0|  [aCoder encodeObject:self.playerID forKey:@"playerID"];
   79|      0|  [aCoder encodeObject:self.publicKeyURL forKey:@"publicKeyURL"];
   80|      0|  [aCoder encodeObject:self.signature forKey:@"signature"];
   81|      0|  [aCoder encodeObject:self.salt forKey:@"salt"];
   82|      0|  [aCoder encodeObject:[NSNumber numberWithUnsignedLongLong:self.timestamp] forKey:@"timestamp"];
   83|      0|  [aCoder encodeObject:self.displayName forKey:@"displayName"];
   84|      0|}
   85|       |
   86|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/GameCenter/FIRGameCenterAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGameCenterAuthProvider.h"
   18|       |
   19|       |#import <GameKit/GameKit.h>
   20|       |
   21|       |#import "FIRAuthErrorUtils.h"
   22|       |#import "FIRAuthExceptionUtils.h"
   23|       |#import "FIRGameCenterAuthCredential.h"
   24|       |
   25|       |@implementation FIRGameCenterAuthProvider
   26|       |
   27|      0|- (instancetype)init {
   28|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   29|      0|      @"This class is not meant to be initialized."];
   30|      0|  return nil;
   31|      0|}
   32|       |
   33|      0|+ (void)getCredentialWithCompletion:(FIRGameCenterCredentialCallback)completion {
   34|      0|  __weak GKLocalPlayer *localPlayer = [GKLocalPlayer localPlayer];
   35|      0|  if (!localPlayer.isAuthenticated) {
   36|      0|    if (completion) {
   37|      0|      completion(nil, [FIRAuthErrorUtils localPlayerNotAuthenticatedError]);
   38|      0|    }
   39|      0|    return;
   40|      0|  }
   41|      0|
   42|      0|  [localPlayer generateIdentityVerificationSignatureWithCompletionHandler:
   43|      0|   ^(NSURL *publicKeyURL, NSData *signature, NSData *salt, uint64_t timestamp, NSError *error) {
   44|      0|     if (error) {
   45|      0|       if (completion) {
   46|      0|         completion(nil, error);
   47|      0|       }
   48|      0|     } else {
   49|      0|       if (completion) {
   50|      0|         /**
   51|      0|          @c `localPlayer.alias` is actually the displayname needed, instead of
   52|      0|          `localPlayer.displayname`. For more information, check
   53|      0|          https://developer.apple.com/documentation/gamekit/gkplayer
   54|      0|          **/
   55|      0|         NSString *displayName = localPlayer.alias;
   56|      0|         FIRGameCenterAuthCredential *credential =
   57|      0|             [[FIRGameCenterAuthCredential alloc] initWithPlayerID:localPlayer.playerID
   58|      0|                                                      publicKeyURL:publicKeyURL
   59|      0|                                                         signature:signature
   60|      0|                                                              salt:salt
   61|      0|                                                         timestamp:timestamp
   62|      0|                                                       displayName:displayName];
   63|      0|         completion(credential, nil);
   64|      0|       }
   65|      0|     }
   66|      0|   }];
   67|      0|}
   68|       |
   69|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/GitHub/FIRGitHubAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGitHubAuthCredential.h"
   18|       |
   19|       |#import "FIRGitHubAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |@interface FIRGitHubAuthCredential ()
   24|       |
   25|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FIRGitHubAuthCredential
   30|       |
   31|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   32|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   33|      0|      @"Please call the designated initializer."];
   34|      0|  return nil;
   35|      0|}
   36|       |
   37|      0|- (nullable instancetype)initWithToken:(NSString *)token {
   38|      0|  self = [super initWithProvider:FIRGitHubAuthProviderID];
   39|      0|  if (self) {
   40|      0|    _token = [token copy];
   41|      0|  }
   42|      0|  return self;
   43|      0|}
   44|       |
   45|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   46|      0|  request.providerAccessToken = _token;
   47|      0|}
   48|       |
   49|       |#pragma mark - NSSecureCoding
   50|       |
   51|      0|+ (BOOL)supportsSecureCoding {
   52|      0|  return YES;
   53|      0|}
   54|       |
   55|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   56|      0|  NSString *token = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"token"];
   57|      0|  self = [self initWithToken:token];
   58|      0|  return self;
   59|      0|}
   60|       |
   61|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   62|      0|  [aCoder encodeObject:self.token forKey:@"token"];
   63|      0|}
   64|       |
   65|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/GitHub/FIRGitHubAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGitHubAuthProvider.h"
   18|       |
   19|       |#import "FIRGitHubAuthCredential.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |
   22|       |// FIRGitHubAuthProviderID is defined in FIRAuthProvider.m.
   23|       |
   24|       |@implementation FIRGitHubAuthProvider
   25|       |
   26|      0|- (instancetype)init {
   27|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   28|      0|      @"This class is not meant to be initialized."];
   29|      0|  return nil;
   30|      0|}
   31|       |
   32|      0|+ (FIRAuthCredential *)credentialWithToken:(NSString *)token {
   33|      0|  return [[FIRGitHubAuthCredential alloc] initWithToken:token];
   34|      0|}
   35|       |
   36|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/Google/FIRGoogleAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGoogleAuthCredential.h"
   18|       |
   19|       |#import "FIRGoogleAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |@interface FIRGoogleAuthCredential ()
   24|       |
   25|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FIRGoogleAuthCredential {
   30|       |  NSString *_IDToken;
   31|       |  NSString *_accessToken;
   32|       |}
   33|       |
   34|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   35|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   36|      0|      @"Please call the designated initializer."];
   37|      0|  return nil;
   38|      0|}
   39|       |
   40|      0|- (nullable instancetype)initWithIDToken:(NSString *)IDToken accessToken:(NSString *)accessToken {
   41|      0|  self = [super initWithProvider:FIRGoogleAuthProviderID];
   42|      0|  if (self) {
   43|      0|    _IDToken = [IDToken copy];
   44|      0|    _accessToken = [accessToken copy];
   45|      0|  }
   46|      0|  return self;
   47|      0|}
   48|       |
   49|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   50|      0|  request.providerIDToken = _IDToken;
   51|      0|  request.providerAccessToken = _accessToken;
   52|      0|}
   53|       |
   54|       |#pragma mark - NSSecureCoding
   55|       |
   56|      0|+ (BOOL)supportsSecureCoding {
   57|      0|  return YES;
   58|      0|}
   59|       |
   60|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   61|      0|  NSString *IDToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"IDToken"];
   62|      0|  NSString *accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"accessToken"];
   63|      0|  self = [self initWithIDToken:IDToken accessToken:accessToken];
   64|      0|  return self;
   65|      0|}
   66|       |
   67|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   68|      0|  [aCoder encodeObject:_IDToken forKey:@"IDToken"];
   69|      0|  [aCoder encodeObject:_accessToken forKey:@"accessToken"];
   70|      0|}
   71|       |
   72|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/Google/FIRGoogleAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGoogleAuthProvider.h"
   18|       |
   19|       |#import "FIRGoogleAuthCredential.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |
   22|       |// FIRGoogleAuthProviderID is defined in FIRAuthProvider.m.
   23|       |
   24|       |@implementation FIRGoogleAuthProvider
   25|       |
   26|      0|- (instancetype)init {
   27|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   28|      0|      @"This class is not meant to be initialized."];
   29|      0|  return nil;
   30|      0|}
   31|       |
   32|       |+ (FIRAuthCredential *)credentialWithIDToken:(NSString *)IDToken
   33|      0|                                 accessToken:(NSString *)accessToken {
   34|      0|  return [[FIRGoogleAuthCredential alloc] initWithIDToken:IDToken accessToken:accessToken];
   35|      0|}
   36|       |
   37|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/OAuth/FIROAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIROAuthCredential.h"
   18|       |
   19|       |#import "FIRVerifyAssertionRequest.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |@interface FIROAuthCredential ()
   24|       |
   25|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FIROAuthCredential
   30|       |
   31|       |- (nullable instancetype)initWithProviderID:(NSString *)providerID
   32|       |                                    IDToken:(nullable NSString *)IDToken
   33|      0|                                accessToken:(nullable NSString *)accessToken {
   34|      0|  self = [super initWithProvider:providerID];
   35|      0|  if (self) {
   36|      0|    _IDToken = IDToken;
   37|      0|    _accessToken = accessToken;
   38|      0|  }
   39|      0|  return self;
   40|      0|}
   41|       |
   42|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   43|      0|  request.providerIDToken = _IDToken;
   44|      0|  request.providerAccessToken = _accessToken;
   45|      0|}
   46|       |
   47|       |#pragma mark - NSSecureCoding
   48|       |
   49|      0|+ (BOOL)supportsSecureCoding {
   50|      0|  return YES;
   51|      0|}
   52|       |
   53|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   54|      0|  NSString *IDToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"IDToken"];
   55|      0|  NSString *accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"accessToken"];
   56|      0|  self = [self initWithProviderID:self.provider IDToken:IDToken accessToken:accessToken];
   57|      0|  return self;
   58|      0|}
   59|       |
   60|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   61|      0|  [aCoder encodeObject:self.IDToken forKey:@"IDToken"];
   62|      0|  [aCoder encodeObject:self.accessToken forKey:@"accessToken"];
   63|      0|}
   64|       |
   65|       |NS_ASSUME_NONNULL_END
   66|       |
   67|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/OAuth/FIROAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIROAuthProvider.h"
   18|       |
   19|       |#import "FIROAuthCredential.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |@implementation FIROAuthProvider
   24|       |
   25|       |+ (FIRAuthCredential *)credentialWithProviderID:(NSString *)providerID
   26|       |                                        IDToken:(NSString *)IDToken
   27|      0|                                    accessToken:(nullable NSString *)accessToken {
   28|      0|  return [[FIROAuthCredential alloc] initWithProviderID:providerID
   29|      0|                                                IDToken:IDToken
   30|      0|                                            accessToken:accessToken];
   31|      0|}
   32|       |
   33|       |+ (FIROAuthCredential *)credentialWithProviderID:(NSString *)providerID
   34|      0|                                     accessToken:(NSString *)accessToken {
   35|      0|  return [[FIROAuthCredential alloc] initWithProviderID:providerID
   36|      0|                                                IDToken:nil
   37|      0|                                            accessToken:accessToken];
   38|      0|}
   39|       |
   40|       |NS_ASSUME_NONNULL_END
   41|       |
   42|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/Phone/FIRPhoneAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRPhoneAuthCredential.h"
   18|       |
   19|       |#import "FIRPhoneAuthCredential_Internal.h"
   20|       |#import "FIRAuthCredential_Internal.h"
   21|       |#import "FIRAuthExceptionUtils.h"
   22|       |#import "FIRVerifyAssertionRequest.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@interface FIRPhoneAuthCredential ()
   27|       |
   28|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   29|       |
   30|       |@end
   31|       |
   32|       |@implementation FIRPhoneAuthCredential
   33|       |
   34|       |- (instancetype)initWithTemporaryProof:(NSString *)temporaryProof
   35|       |                           phoneNumber:(NSString *)phoneNumber
   36|      0|                            providerID:(NSString *)providerID {
   37|      0|  self = [super initWithProvider:providerID];
   38|      0|  if (self) {
   39|      0|    _temporaryProof = [temporaryProof copy];
   40|      0|    _phoneNumber = [phoneNumber copy];
   41|      0|  }
   42|      0|  return self;
   43|      0|}
   44|       |
   45|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   46|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   47|      0|      @"Please call the designated initializer."];
   48|      0|  return nil;
   49|      0|}
   50|       |
   51|       |- (instancetype)initWithProviderID:(NSString *)providerID
   52|       |                    verificationID:(NSString *)verificationID
   53|      0|                  verificationCode:(NSString *)verificationCode {
   54|      0|  self = [super initWithProvider:providerID];
   55|      0|  if (self) {
   56|      0|    _verificationID = [verificationID copy];
   57|      0|    _verificationCode = [verificationCode copy];
   58|      0|  }
   59|      0|  return self;
   60|      0|}
   61|       |
   62|       |#pragma mark - NSSecureCoding
   63|       |
   64|      0|+ (BOOL)supportsSecureCoding {
   65|      0|  return YES;
   66|      0|}
   67|       |
   68|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   69|      0|  NSString *verificationID = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"verificationID"];
   70|      0|  NSString *verificationCode = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"verificationCode"];
   71|      0|  NSString *temporaryProof = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"temporaryProof"];
   72|      0|  NSString *phoneNumber = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"phoneNumber"];
   73|      0|  if (temporaryProof.length && phoneNumber.length) {
   74|      0|    self = [self initWithTemporaryProof:temporaryProof phoneNumber:phoneNumber providerID:self.provider];
   75|      0|  } else if (verificationID.length && verificationCode.length) {
   76|      0|    self = [self initWithProviderID:self.provider verificationID:verificationID verificationCode:verificationCode];
   77|      0|  } else {
   78|      0|    self = nil;
   79|      0|  }
   80|      0|  return self;
   81|      0|}
   82|       |
   83|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   84|      0|  [aCoder encodeObject:self.verificationID forKey:@"verificationID"];
   85|      0|  [aCoder encodeObject:self.verificationCode forKey:@"verificationCode"];
   86|      0|  [aCoder encodeObject:self.temporaryProof forKey:@"temporaryProof"];
   87|      0|  [aCoder encodeObject:self.phoneNumber forKey:@"phoneNumber"];
   88|      0|}
   89|       |
   90|       |@end
   91|       |
   92|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/Phone/FIRPhoneAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRPhoneAuthProvider.h"
   18|       |
   19|       |#import <FirebaseCore/FIRLogger.h>
   20|       |#import "FIRPhoneAuthCredential_Internal.h"
   21|       |#import <FirebaseCore/FIRApp.h>
   22|       |#import "FIRAuthAPNSToken.h"
   23|       |#import "FIRAuthAPNSTokenManager.h"
   24|       |#import "FIRAuthAppCredential.h"
   25|       |#import "FIRAuthAppCredentialManager.h"
   26|       |#import "FIRAuthGlobalWorkQueue.h"
   27|       |#import "FIRAuth_Internal.h"
   28|       |#import "FIRAuthURLPresenter.h"
   29|       |#import "FIRAuthNotificationManager.h"
   30|       |#import "FIRAuthErrorUtils.h"
   31|       |#import "FIRAuthBackend.h"
   32|       |#import "FIRAuthSettings.h"
   33|       |#import "FIRAuthWebUtils.h"
   34|       |#import "FirebaseAuthVersion.h"
   35|       |#import <FirebaseCore/FIROptions.h>
   36|       |#import "FIRGetProjectConfigRequest.h"
   37|       |#import "FIRGetProjectConfigResponse.h"
   38|       |#import "FIRSendVerificationCodeRequest.h"
   39|       |#import "FIRSendVerificationCodeResponse.h"
   40|       |#import "FIRVerifyClientRequest.h"
   41|       |#import "FIRVerifyClientResponse.h"
   42|       |
   43|       |NS_ASSUME_NONNULL_BEGIN
   44|       |
   45|       |/** @typedef FIRReCAPTCHAURLCallBack
   46|       |    @brief The callback invoked at the end of the flow to fetch a reCAPTCHA URL.
   47|       |    @param reCAPTCHAURL The reCAPTCHA URL.
   48|       |    @param error The error that occurred while fetching the reCAPTCHAURL, if any.
   49|       | */
   50|       |typedef void (^FIRReCAPTCHAURLCallBack)(NSURL *_Nullable reCAPTCHAURL, NSError *_Nullable error);
   51|       |
   52|       |/** @typedef FIRVerifyClientCallback
   53|       |    @brief The callback invoked at the end of a client verification flow.
   54|       |    @param appCredential credential that proves the identity of the app during a phone
   55|       |        authentication flow.
   56|       |    @param error The error that occurred while verifying the app, if any.
   57|       | */
   58|       |typedef void (^FIRVerifyClientCallback)(FIRAuthAppCredential *_Nullable appCredential,
   59|       |                                        NSError *_Nullable error);
   60|       |
   61|       |/** @typedef FIRFetchAuthDomainCallback
   62|       |    @brief The callback invoked at the end of the flow to fetch the Auth domain.
   63|       |    @param authDomain The Auth domain.
   64|       |    @param error The error that occurred while fetching the auth domain, if any.
   65|       | */
   66|       |typedef void (^FIRFetchAuthDomainCallback)(NSString *_Nullable authDomain,
   67|       |                                           NSError *_Nullable error);
   68|       |/** @var kAuthDomainSuffix
   69|       |    @brief The suffix of the auth domain pertiaining to a given Firebase project.
   70|       | */
   71|       |static NSString *const kAuthDomainSuffix = @"firebaseapp.com";
   72|       |
   73|       |/** @var kauthTypeVerifyApp
   74|       |    @brief The auth type to be specified in the app verification request.
   75|       | */
   76|       |static NSString *const kAuthTypeVerifyApp = @"verifyApp";
   77|       |
   78|       |/** @var kReCAPTCHAURLStringFormat
   79|       |    @brief The format of the URL used to open the reCAPTCHA page during app verification.
   80|       | */
   81|       |NSString *const kReCAPTCHAURLStringFormat = @"https://%@/__/auth/handler?";
   82|       |
   83|       |@implementation FIRPhoneAuthProvider {
   84|       |
   85|       |  /** @var _auth
   86|       |      @brief The auth instance used for verifying the phone number.
   87|       |   */
   88|       |  FIRAuth *_auth;
   89|       |
   90|       |  /** @var _callbackScheme
   91|       |      @brief The callback URL scheme used for reCAPTCHA fallback.
   92|       |   */
   93|       |  NSString *_callbackScheme;
   94|       |}
   95|       |
   96|       |/** @fn initWithAuth:
   97|       |    @brief returns an instance of @c FIRPhoneAuthProvider associated with the provided auth
   98|       |          instance.
   99|       |    @return An Instance of @c FIRPhoneAuthProvider.
  100|       |   */
  101|      0|- (nullable instancetype)initWithAuth:(FIRAuth *)auth {
  102|      0|  self = [super init];
  103|      0|  if (self) {
  104|      0|    _auth = auth;
  105|      0|    _callbackScheme = [[[_auth.app.options.clientID componentsSeparatedByString:@"."]
  106|      0|        reverseObjectEnumerator].allObjects componentsJoinedByString:@"."];
  107|      0|  }
  108|      0|  return self;
  109|      0|}
  110|       |
  111|       |- (void)verifyPhoneNumber:(NSString *)phoneNumber
  112|       |               UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
  113|      0|               completion:(nullable FIRVerificationResultCallback)completion {
  114|      0|  if (![self isCallbackSchemeRegistered]) {
  115|      0|    [NSException raise:NSInternalInconsistencyException
  116|      0|                format:@"Please register custom URL scheme '%@' in the app's Info.plist file.",
  117|      0|                       _callbackScheme];
  118|      0|  }
  119|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  120|      0|    FIRVerificationResultCallback callBackOnMainThread = ^(NSString *_Nullable verificationID,
  121|      0|                                                           NSError *_Nullable error) {
  122|      0|      if (completion) {
  123|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  124|      0|          completion(verificationID, error);
  125|      0|        });
  126|      0|      }
  127|      0|    };
  128|      0|    [self internalVerifyPhoneNumber:phoneNumber completion:^(NSString *_Nullable verificationID,
  129|      0|                                                             NSError *_Nullable error) {
  130|      0|      if (!error) {
  131|      0|        callBackOnMainThread(verificationID, nil);
  132|      0|        return;
  133|      0|      }
  134|      0|      NSError *underlyingError = error.userInfo[NSUnderlyingErrorKey];
  135|      0|      BOOL isInvalidAppCredential = error.code == FIRAuthErrorCodeInternalError &&
  136|      0|          underlyingError.code == FIRAuthErrorCodeInvalidAppCredential;
  137|      0|      if (error.code != FIRAuthErrorCodeMissingAppToken && !isInvalidAppCredential) {
  138|      0|        callBackOnMainThread(nil, error);
  139|      0|        return;
  140|      0|      }
  141|      0|      NSMutableString *eventID = [[NSMutableString alloc] init];
  142|      0|      for (int i=0; i<10; i++) {
  143|      0|        [eventID appendString:
  144|      0|            [NSString stringWithFormat:@"%c", 'a' + arc4random_uniform('z' - 'a' + 1)]];
  145|      0|      }
  146|      0|      [self reCAPTCHAURLWithEventID:eventID completion:^(NSURL *_Nullable reCAPTCHAURL,
  147|      0|                                                         NSError *_Nullable error) {
  148|      0|        if (error) {
  149|      0|          callBackOnMainThread(nil, error);
  150|      0|          return;
  151|      0|        }
  152|      0|        FIRAuthURLCallbackMatcher callbackMatcher = ^BOOL(NSURL *_Nullable callbackURL) {
  153|      0|          return [self isVerifyAppURL:callbackURL eventID:eventID];
  154|      0|        };
  155|      0|        [self->_auth.authURLPresenter presentURL:reCAPTCHAURL
  156|      0|                                      UIDelegate:UIDelegate
  157|      0|                                 callbackMatcher:callbackMatcher
  158|      0|                                      completion:^(NSURL *_Nullable callbackURL,
  159|      0|                                                   NSError *_Nullable error) {
  160|      0|          if (error) {
  161|      0|            callBackOnMainThread(nil, error);
  162|      0|            return;
  163|      0|          }
  164|      0|          NSError *reCAPTCHAError;
  165|      0|          NSString *reCAPTCHAToken = [self reCAPTCHATokenForURL:callbackURL error:&reCAPTCHAError];
  166|      0|          if (!reCAPTCHAToken) {
  167|      0|            callBackOnMainThread(nil, reCAPTCHAError);
  168|      0|            return;
  169|      0|          }
  170|      0|          FIRSendVerificationCodeRequest *request =
  171|      0|            [[FIRSendVerificationCodeRequest alloc] initWithPhoneNumber:phoneNumber
  172|      0|                                                          appCredential:nil
  173|      0|                                                         reCAPTCHAToken:reCAPTCHAToken
  174|      0|                                                   requestConfiguration:
  175|      0|                                                      self->_auth.requestConfiguration];
  176|      0|          [FIRAuthBackend sendVerificationCode:request
  177|      0|                                      callback:^(FIRSendVerificationCodeResponse
  178|      0|                                                 *_Nullable response, NSError *_Nullable error) {
  179|      0|            if (error) {
  180|      0|              callBackOnMainThread(nil, error);
  181|      0|              return;
  182|      0|            }
  183|      0|            callBackOnMainThread(response.verificationID, nil);
  184|      0|          }];
  185|      0|        }];
  186|      0|      }];
  187|      0|    }];
  188|      0|  });
  189|      0|}
  190|       |
  191|       |- (FIRPhoneAuthCredential *)credentialWithVerificationID:(NSString *)verificationID
  192|      0|                                        verificationCode:(NSString *)verificationCode {
  193|      0|  return [[FIRPhoneAuthCredential alloc] initWithProviderID:FIRPhoneAuthProviderID
  194|      0|                                             verificationID:verificationID
  195|      0|                                           verificationCode:verificationCode];
  196|      0|}
  197|       |
  198|      0|+ (instancetype)provider {
  199|      0|  return [[self alloc]initWithAuth:[FIRAuth auth]];
  200|      0|}
  201|       |
  202|      0|+ (instancetype)providerWithAuth:(FIRAuth *)auth {
  203|      0|  return [[self alloc]initWithAuth:auth];
  204|      0|}
  205|       |
  206|       |#pragma mark - Internal Methods
  207|       |
  208|       |/** @fn isCallbackSchemeRegistered
  209|       |    @brief Checks whether or not the expected callback scheme has been registered by the app.
  210|       |    @remarks This method is thread-safe.
  211|       | */
  212|      0|- (BOOL)isCallbackSchemeRegistered {
  213|      0|  NSString *expectedCustomScheme = [_callbackScheme lowercaseString];
  214|      0|  NSArray *urlTypes = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleURLTypes"];
  215|      0|  for (NSDictionary *urlType in urlTypes) {
  216|      0|    NSArray *urlTypeSchemes = urlType[@"CFBundleURLSchemes"];
  217|      0|    for (NSString *urlTypeScheme in urlTypeSchemes) {
  218|      0|      if ([urlTypeScheme.lowercaseString isEqualToString:expectedCustomScheme]) {
  219|      0|        return YES;
  220|      0|      }
  221|      0|    }
  222|      0|  }
  223|      0|  return NO;
  224|      0|}
  225|       |
  226|       |/** @fn reCAPTCHATokenForURL:error:
  227|       |    @brief Parses the reCAPTCHA URL and returns.
  228|       |    @param URL The url to be parsed for a reCAPTCHA token.
  229|       |    @param error The error that occurred if any.
  230|       |    @return The reCAPTCHA token if successful.
  231|       | */
  232|      0|- (NSString *)reCAPTCHATokenForURL:(NSURL *)URL error:(NSError **)error {
  233|      0|  NSURLComponents *actualURLComponents = [NSURLComponents componentsWithURL:URL resolvingAgainstBaseURL:NO];
  234|      0|  NSArray<NSURLQueryItem *> *queryItems = [actualURLComponents queryItems];
  235|      0|  NSString *deepLinkURL = [FIRAuthWebUtils queryItemValue:@"deep_link_id" from:queryItems];
  236|      0|  NSData *errorData;
  237|      0|  if (deepLinkURL) {
  238|      0|    actualURLComponents = [NSURLComponents componentsWithString:deepLinkURL];
  239|      0|    queryItems = [actualURLComponents queryItems];
  240|      0|    NSString *recaptchaToken = [FIRAuthWebUtils queryItemValue:@"recaptchaToken" from:queryItems];
  241|      0|    if (recaptchaToken) {
  242|      0|      return recaptchaToken;
  243|      0|    }
  244|      0|    NSString *firebaseError = [FIRAuthWebUtils queryItemValue:@"firebaseError" from:queryItems];
  245|      0|    errorData = [firebaseError dataUsingEncoding:NSUTF8StringEncoding];
  246|      0|  } else {
  247|      0|    errorData = nil;
  248|      0|  }
  249|      0|  NSError *jsonError;
  250|      0|  NSDictionary *errorDict = [NSJSONSerialization JSONObjectWithData:errorData
  251|      0|                                                            options:0
  252|      0|                                                              error:&jsonError];
  253|      0|  if (jsonError) {
  254|      0|    *error = [FIRAuthErrorUtils JSONSerializationErrorWithUnderlyingError:jsonError];
  255|      0|    return nil;
  256|      0|  }
  257|      0|  *error = [FIRAuthErrorUtils URLResponseErrorWithCode:errorDict[@"code"]
  258|      0|                                               message:errorDict[@"message"]];
  259|      0|  if (!*error) {
  260|      0|    NSString *reason;
  261|      0|    if(errorDict[@"code"] && errorDict[@"message"]) {
  262|      0|      reason = [NSString stringWithFormat:@"[%@] - %@",errorDict[@"code"], errorDict[@"message"]];
  263|      0|    } else {
  264|      0|      reason = [NSString stringWithFormat:@"An unknown error occurred with the following "
  265|      0|          "response: %@", deepLinkURL];
  266|      0|    }
  267|      0|    *error = [FIRAuthErrorUtils appVerificationUserInteractionFailureWithReason:reason];
  268|      0|  }
  269|      0|  return nil;
  270|      0|}
  271|       |
  272|       |/** @fn isVerifyAppURL:
  273|       |    @brief Parses a URL into all available query items.
  274|       |    @param URL The url to be checked against the authType string.
  275|       |    @return Whether or not the URL matches authType.
  276|       | */
  277|      0|- (BOOL)isVerifyAppURL:(nullable NSURL *)URL eventID:(NSString *)eventID {
  278|      0|  if (!URL) {
  279|      0|    return NO;
  280|      0|  }
  281|      0|  NSURLComponents *actualURLComponents =
  282|      0|      [NSURLComponents componentsWithURL:URL resolvingAgainstBaseURL:NO];
  283|      0|  actualURLComponents.query = nil;
  284|      0|  actualURLComponents.fragment = nil;
  285|      0|
  286|      0|  NSURLComponents *expectedURLComponents = [NSURLComponents new];
  287|      0|  expectedURLComponents.scheme = _callbackScheme;
  288|      0|  expectedURLComponents.host = @"firebaseauth";
  289|      0|  expectedURLComponents.path = @"/link";
  290|      0|
  291|      0|  if (!([[expectedURLComponents URL] isEqual:[actualURLComponents URL]])) {
  292|      0|    return NO;
  293|      0|  }
  294|      0|  actualURLComponents = [NSURLComponents componentsWithURL:URL resolvingAgainstBaseURL:NO];
  295|      0|  NSArray<NSURLQueryItem *> *queryItems = [actualURLComponents queryItems];
  296|      0|  NSString *deepLinkURL = [FIRAuthWebUtils queryItemValue:@"deep_link_id" from:queryItems];
  297|      0|  if (deepLinkURL == nil) {
  298|      0|    return NO;
  299|      0|  }
  300|      0|  NSURLComponents *deepLinkURLComponents = [NSURLComponents componentsWithString:deepLinkURL];
  301|      0|  NSArray<NSURLQueryItem *> *deepLinkQueryItems = [deepLinkURLComponents queryItems];
  302|      0|
  303|      0|  NSString *deepLinkAuthType = [FIRAuthWebUtils queryItemValue:@"authType" from:deepLinkQueryItems];
  304|      0|  NSString *deepLinkEventID = [FIRAuthWebUtils queryItemValue:@"eventId" from:deepLinkQueryItems];
  305|      0|  if ([deepLinkAuthType isEqualToString:kAuthTypeVerifyApp] &&
  306|      0|      [deepLinkEventID isEqualToString:eventID]) {
  307|      0|    return YES;
  308|      0|  }
  309|      0|  return NO;
  310|      0|}
  311|       |
  312|       |/** @fn internalVerifyPhoneNumber:completion:
  313|       |    @brief Starts the phone number authentication flow by sending a verifcation code to the
  314|       |        specified phone number.
  315|       |    @param phoneNumber The phone number to be verified.
  316|       |    @param completion The callback to be invoked when the verification flow is finished.
  317|       | */
  318|       |
  319|       |- (void)internalVerifyPhoneNumber:(NSString *)phoneNumber
  320|      0|                       completion:(nullable FIRVerificationResultCallback)completion {
  321|      0|  if (!phoneNumber.length) {
  322|      0|    completion(nil, [FIRAuthErrorUtils missingPhoneNumberErrorWithMessage:nil]);
  323|      0|    return;
  324|      0|  }
  325|      0|  [_auth.notificationManager checkNotificationForwardingWithCallback:
  326|      0|      ^(BOOL isNotificationBeingForwarded) {
  327|      0|    if (!isNotificationBeingForwarded) {
  328|      0|      completion(nil, [FIRAuthErrorUtils notificationNotForwardedError]);
  329|      0|      return;
  330|      0|    }
  331|      0|    FIRVerificationResultCallback callback = ^(NSString *_Nullable verificationID,
  332|      0|                                               NSError *_Nullable error) {
  333|      0|      if (completion) {
  334|      0|        completion(verificationID, error);
  335|      0|      }
  336|      0|    };
  337|      0|    [self verifyClientAndSendVerificationCodeToPhoneNumber:phoneNumber
  338|      0|                               retryOnInvalidAppCredential:YES
  339|      0|                                                  callback:callback];
  340|      0|  }];
  341|      0|}
  342|       |
  343|       |/** @fn verifyClientAndSendVerificationCodeToPhoneNumber:retryOnInvalidAppCredential:callback:
  344|       |    @brief Starts the flow to verify the client via silent push notification.
  345|       |    @param retryOnInvalidAppCredential Whether of not the flow should be retried if an
  346|       |        FIRAuthErrorCodeInvalidAppCredential error is returned from the backend.
  347|       |    @param phoneNumber The phone number to be verified.
  348|       |    @param callback The callback to be invoked on the global work queue when the flow is
  349|       |        finished.
  350|       | */
  351|       |- (void)verifyClientAndSendVerificationCodeToPhoneNumber:(NSString *)phoneNumber
  352|       |                             retryOnInvalidAppCredential:(BOOL)retryOnInvalidAppCredential
  353|      0|                                                callback:(FIRVerificationResultCallback)callback {
  354|      0|  if (_auth.settings.isAppVerificationDisabledForTesting) {
  355|      0|    FIRSendVerificationCodeRequest *request =
  356|      0|        [[FIRSendVerificationCodeRequest alloc] initWithPhoneNumber:phoneNumber
  357|      0|                                                     appCredential:nil
  358|      0|                                                    reCAPTCHAToken:nil
  359|      0|                                              requestConfiguration:
  360|      0|                                                  _auth.requestConfiguration];
  361|      0|    [FIRAuthBackend sendVerificationCode:request
  362|      0|                                callback:^(FIRSendVerificationCodeResponse *_Nullable response,
  363|      0|                                           NSError *_Nullable error) {
  364|      0|      callback(response.verificationID, error);
  365|      0|    }];
  366|      0|    return;
  367|      0|  }
  368|      0|  [self verifyClientWithCompletion:^(FIRAuthAppCredential *_Nullable appCredential,
  369|      0|                                     NSError *_Nullable error) {
  370|      0|    if (error) {
  371|      0|      callback(nil, error);
  372|      0|      return;
  373|      0|    }
  374|      0|    FIRSendVerificationCodeRequest *request =
  375|      0|        [[FIRSendVerificationCodeRequest alloc] initWithPhoneNumber:phoneNumber
  376|      0|                                                     appCredential:appCredential
  377|      0|                                                    reCAPTCHAToken:nil
  378|      0|                                              requestConfiguration:
  379|      0|                                                  self->_auth.requestConfiguration];
  380|      0|    [FIRAuthBackend sendVerificationCode:request
  381|      0|                                callback:^(FIRSendVerificationCodeResponse *_Nullable response,
  382|      0|                                           NSError *_Nullable error) {
  383|      0|      if (error) {
  384|      0|        if (error.code == FIRAuthErrorCodeInvalidAppCredential) {
  385|      0|          if (retryOnInvalidAppCredential) {
  386|      0|            [self->_auth.appCredentialManager clearCredential];
  387|      0|            [self verifyClientAndSendVerificationCodeToPhoneNumber:phoneNumber
  388|      0|                                       retryOnInvalidAppCredential:NO
  389|      0|                                                          callback:callback];
  390|      0|            return;
  391|      0|          }
  392|      0|          callback(nil, [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:nil
  393|      0|                                                                      underlyingError:error]);
  394|      0|          return;
  395|      0|        }
  396|      0|        callback(nil, error);
  397|      0|        return;
  398|      0|      }
  399|      0|      callback(response.verificationID, nil);
  400|      0|    }];
  401|      0|  }];
  402|      0|}
  403|       |
  404|       |/** @fn verifyClientWithCompletion:completion:
  405|       |    @brief Continues the flow to verify the client via silent push notification.
  406|       |    @param completion The callback to be invoked when the client verification flow is finished.
  407|       | */
  408|      0|- (void)verifyClientWithCompletion:(FIRVerifyClientCallback)completion {
  409|      0|  if (_auth.appCredentialManager.credential) {
  410|      0|    completion(_auth.appCredentialManager.credential, nil);
  411|      0|    return;
  412|      0|  }
  413|      0|  [_auth.tokenManager getTokenWithCallback:^(FIRAuthAPNSToken *_Nullable token,
  414|      0|                                             NSError *_Nullable error) {
  415|      0|    if (!token) {
  416|      0|      completion(nil, [FIRAuthErrorUtils missingAppTokenErrorWithUnderlyingError:error]);
  417|      0|      return;
  418|      0|    }
  419|      0|    FIRVerifyClientRequest *request =
  420|      0|        [[FIRVerifyClientRequest alloc] initWithAppToken:token.string
  421|      0|                                               isSandbox:token.type == FIRAuthAPNSTokenTypeSandbox
  422|      0|                                    requestConfiguration:self->_auth.requestConfiguration];
  423|      0|    [FIRAuthBackend verifyClient:request callback:^(FIRVerifyClientResponse *_Nullable response,
  424|      0|                                                    NSError *_Nullable error) {
  425|      0|      if (error) {
  426|      0|        completion(nil, error);
  427|      0|        return;
  428|      0|      }
  429|      0|      NSTimeInterval timeout = [response.suggestedTimeOutDate timeIntervalSinceNow];
  430|      0|      [self->_auth.appCredentialManager
  431|      0|          didStartVerificationWithReceipt:response.receipt
  432|      0|                                  timeout:timeout
  433|      0|                                 callback:^(FIRAuthAppCredential *credential) {
  434|      0|        if (!credential.secret) {
  435|      0|          FIRLogWarning(kFIRLoggerAuth, @"I-AUT000014",
  436|      0|                        @"Failed to receive remote notification to verify app identity within "
  437|      0|                        @"%.0f second(s)", timeout);
  438|      0|        }
  439|      0|        completion(credential, nil);
  440|      0|      }];
  441|      0|    }];
  442|      0|  }];
  443|      0|}
  444|       |
  445|       |/** @fn reCAPTCHAURLWithEventID:completion:
  446|       |    @brief Constructs a URL used for opening a reCAPTCHA app verification flow using a given event
  447|       |        ID.
  448|       |    @param eventID The event ID used for this purpose.
  449|       |    @param completion The callback invoked after the URL has been constructed or an error
  450|       |        has been encountered.
  451|       | */
  452|      0|- (void)reCAPTCHAURLWithEventID:(NSString *)eventID completion:(FIRReCAPTCHAURLCallBack)completion {
  453|      0|  [self fetchAuthDomainWithCompletion:^(NSString *_Nullable authDomain,
  454|      0|                                        NSError *_Nullable error) {
  455|      0|    if (error) {
  456|      0|      completion(nil, error);
  457|      0|      return;
  458|      0|    }
  459|      0|    NSString *bundleID = [NSBundle mainBundle].bundleIdentifier;
  460|      0|    NSString *clientID = self->_auth.app.options.clientID;
  461|      0|    NSString *apiKey = self->_auth.requestConfiguration.APIKey;
  462|      0|    NSMutableArray<NSURLQueryItem *> *queryItems = [@[
  463|      0|      [NSURLQueryItem queryItemWithName:@"apiKey" value:apiKey],
  464|      0|      [NSURLQueryItem queryItemWithName:@"authType" value:kAuthTypeVerifyApp],
  465|      0|      [NSURLQueryItem queryItemWithName:@"ibi" value:bundleID ?: @""],
  466|      0|      [NSURLQueryItem queryItemWithName:@"clientId" value:clientID],
  467|      0|      [NSURLQueryItem queryItemWithName:@"v" value:[FIRAuthBackend authUserAgent]],
  468|      0|      [NSURLQueryItem queryItemWithName:@"eventId" value:eventID]
  469|      0|      ] mutableCopy
  470|      0|    ];
  471|      0|
  472|      0|    if (self->_auth.requestConfiguration.languageCode) {
  473|      0|      [queryItems addObject:[NSURLQueryItem queryItemWithName:@"hl"value:
  474|      0|                             self->_auth.requestConfiguration.languageCode]];
  475|      0|    }
  476|      0|    NSURLComponents *components = [[NSURLComponents alloc] initWithString:
  477|      0|      [NSString stringWithFormat:kReCAPTCHAURLStringFormat, authDomain]];
  478|      0|    [components setQueryItems:queryItems];
  479|      0|    completion([components URL], nil);
  480|      0|  }];
  481|      0|}
  482|       |
  483|       |/** @fn fetchAuthDomainWithCompletion:completion:
  484|       |    @brief Fetches the auth domain associated with the Firebase Project.
  485|       |    @param completion The callback invoked after the auth domain has been constructed or an error
  486|       |        has been encountered.
  487|       | */
  488|      0|- (void)fetchAuthDomainWithCompletion:(FIRFetchAuthDomainCallback)completion {
  489|      0|  FIRGetProjectConfigRequest *request =
  490|      0|      [[FIRGetProjectConfigRequest alloc] initWithRequestConfiguration:_auth.requestConfiguration];
  491|      0|
  492|      0|  [FIRAuthBackend getProjectConfig:request
  493|      0|                          callback:^(FIRGetProjectConfigResponse *_Nullable response,
  494|      0|                                     NSError *_Nullable error) {
  495|      0|    if (error) {
  496|      0|      completion(nil, error);
  497|      0|      return;
  498|      0|    }
  499|      0|    NSString *authDomain;
  500|      0|    for (NSString *domain in response.authorizedDomains) {
  501|      0|      NSInteger index = domain.length - kAuthDomainSuffix.length;
  502|      0|      if (index >= 2) {
  503|      0|        if ([domain hasSuffix:kAuthDomainSuffix] && domain.length >= kAuthDomainSuffix.length + 2) {
  504|      0|          authDomain = domain;
  505|      0|          break;
  506|      0|        }
  507|      0|      }
  508|      0|    }
  509|      0|    if (!authDomain.length) {
  510|      0|      completion(nil, [FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:response]);
  511|      0|      return;
  512|      0|    }
  513|      0|    completion(authDomain, nil);
  514|      0|  }];
  515|      0|}
  516|       |
  517|       |@end
  518|       |
  519|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/Twitter/FIRTwitterAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRTwitterAuthCredential.h"
   18|       |
   19|       |#import "FIRTwitterAuthProvider.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |#import "FIRVerifyAssertionRequest.h"
   22|       |
   23|       |@interface FIRTwitterAuthCredential ()
   24|       |
   25|       |- (nullable instancetype)initWithProvider:(NSString *)provider NS_UNAVAILABLE;
   26|       |
   27|       |@end
   28|       |
   29|       |@implementation FIRTwitterAuthCredential
   30|       |
   31|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   32|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   33|      0|      @"Please call the designated initializer."];
   34|      0|  return nil;
   35|      0|}
   36|       |
   37|      0|- (nullable instancetype)initWithToken:(NSString *)token secret:(NSString *)secret {
   38|      0|  self = [super initWithProvider:FIRTwitterAuthProviderID];
   39|      0|  if (self) {
   40|      0|    _token = [token copy];
   41|      0|    _secret = [secret copy];
   42|      0|  }
   43|      0|  return self;
   44|      0|}
   45|       |
   46|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   47|      0|  request.providerAccessToken = _token;
   48|      0|  request.providerOAuthTokenSecret = _secret;
   49|      0|}
   50|       |
   51|       |#pragma mark - NSSecureCoding
   52|       |
   53|      0|+ (BOOL)supportsSecureCoding {
   54|      0|  return YES;
   55|      0|}
   56|       |
   57|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   58|      0|  NSString *token = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"token"];
   59|      0|  NSString *secret = [aDecoder decodeObjectOfClass:[NSString class] forKey:@"secret"];
   60|      0|  self = [self initWithToken:token secret:secret];
   61|      0|  return self;
   62|      0|}
   63|       |
   64|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   65|      0|  [aCoder encodeObject:self.token forKey:@"token"];
   66|      0|  [aCoder encodeObject:self.secret forKey:@"secret"];
   67|      0|}
   68|       |
   69|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/AuthProviders/Twitter/FIRTwitterAuthProvider.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRTwitterAuthProvider.h"
   18|       |
   19|       |#import "FIRTwitterAuthCredential.h"
   20|       |#import "FIRAuthExceptionUtils.h"
   21|       |
   22|       |// FIRTwitterAuthProviderID is defined in FIRAuthProvider.m.
   23|       |
   24|       |@implementation FIRTwitterAuthProvider
   25|       |
   26|      0|- (instancetype)init {
   27|      0|  [FIRAuthExceptionUtils raiseMethodNotImplementedExceptionWithReason:
   28|      0|      @"This class is not meant to be initialized."];
   29|      0|  return nil;
   30|      0|}
   31|       |
   32|      0|+ (FIRAuthCredential *)credentialWithToken:(NSString *)token secret:(NSString *)secret {
   33|      0|  return [[FIRTwitterAuthCredential alloc] initWithToken:token secret:secret];
   34|      0|}
   35|       |
   36|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRActionCodeSettings.m:
    1|       |/*
    2|       |  * Copyright 2017 Google
    3|       |  *
    4|       |  * Licensed under the Apache License, Version 2.0 (the "License");
    5|       |  * you may not use this file except in compliance with the License.
    6|       |  * You may obtain a copy of the License at
    7|       |  *
    8|       |  *      http://www.apache.org/licenses/LICENSE2.0
    9|       |  *
   10|       |  * Unless required by applicable law or agreed to in writing, software
   11|       |  * distributed under the License is distributed on an "AS IS" BASIS,
   12|       |  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       |  * See the License for the specific language governing permissions and
   14|       |  * limitations under the License.
   15|       |  */
   16|       |
   17|       |#import "FIRActionCodeSettings.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRActionCodeSettings
   22|       |
   23|      0|- (instancetype)init {
   24|      0|  self = [super init];
   25|      0|  if (self) {
   26|      0|    _iOSBundleID = [NSBundle mainBundle].bundleIdentifier;
   27|      0|  }
   28|      0|  return self;
   29|      0|}
   30|       |
   31|      0|- (void)setIOSBundleID:(NSString *)iOSBundleID {
   32|      0|   _iOSBundleID = [iOSBundleID copy];
   33|      0| }
   34|       |
   35|       |- (void)setAndroidPackageName:(NSString *)androidPackageName
   36|       |         installIfNotAvailable:(BOOL)installIfNotAvailable
   37|      0|                minimumVersion:(nullable NSString *)minimumVersion {
   38|      0|   _androidPackageName = [androidPackageName copy];
   39|      0|   _androidInstallIfNotAvailable = installIfNotAvailable;
   40|      0|   _androidMinimumVersion = [minimumVersion copy];
   41|      0| }
   42|       |
   43|       | @end
   44|       |
   45|       | NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAdditionalUserInfo.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAdditionalUserInfo_Internal.h"
   18|       |
   19|       |#import "FIRVerifyAssertionResponse.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |@implementation FIRAdditionalUserInfo
   24|       |
   25|       |/** @var kProviderIDCodingKey
   26|       |    @brief The key used to encode the providerID property for NSSecureCoding.
   27|       | */
   28|       |static NSString *const kProviderIDCodingKey = @"providerID";
   29|       |
   30|       |/** @var kProfileCodingKey
   31|       |    @brief The key used to encode the profile property for NSSecureCoding.
   32|       | */
   33|       |static NSString *const kProfileCodingKey = @"profile";
   34|       |
   35|       |/** @var kUsernameCodingKey
   36|       |    @brief The key used to encode the username property for NSSecureCoding.
   37|       | */
   38|       |static NSString *const kUsernameCodingKey = @"username";
   39|       |
   40|       |/** @var kNewUserKey
   41|       |    @brief The key used to encode the newUser property for NSSecureCoding.
   42|       | */
   43|       |static NSString *const kNewUserKey = @"newUser";
   44|       |
   45|       |+ (nullable instancetype)userInfoWithVerifyAssertionResponse:
   46|      0|    (FIRVerifyAssertionResponse *)verifyAssertionResponse {
   47|      0|  return [[self alloc] initWithProviderID:verifyAssertionResponse.providerID
   48|      0|                                  profile:verifyAssertionResponse.profile
   49|      0|                                 username:verifyAssertionResponse.username
   50|      0|                                isNewUser:verifyAssertionResponse.isNewUser];
   51|      0|}
   52|       |
   53|       |- (nullable instancetype)initWithProviderID:(nullable NSString *)providerID
   54|       |                                    profile:(nullable NSDictionary<NSString *, NSObject *> *)profile
   55|       |                                   username:(nullable NSString *)username
   56|      0|                                  isNewUser:(BOOL)isNewUser {
   57|      0|  self = [super init];
   58|      0|  if (self) {
   59|      0|    _providerID = [providerID copy];
   60|      0|    if (profile) {
   61|      0|      _profile = [[NSDictionary alloc] initWithDictionary:profile copyItems:YES];
   62|      0|    }
   63|      0|    _username = [username copy];
   64|      0|    _newUser = isNewUser;
   65|      0|  }
   66|      0|  return self;
   67|      0|}
   68|       |
   69|       |#pragma mark - NSSecureCoding
   70|       |
   71|      0|+ (BOOL)supportsSecureCoding {
   72|      0|  return YES;
   73|      0|}
   74|       |
   75|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   76|      0|  NSString *providerID =
   77|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kProviderIDCodingKey];
   78|      0|  NSDictionary<NSString *, NSObject *> *profile =
   79|      0|      [aDecoder decodeObjectOfClass:[NSDictionary class] forKey:kProfileCodingKey];
   80|      0|  NSString *username = [aDecoder decodeObjectOfClass:[NSString class] forKey:kUsernameCodingKey];
   81|      0|  NSNumber *isNewUser = [aDecoder decodeObjectOfClass:[NSNumber class] forKey:kNewUserKey];
   82|      0|
   83|      0|  return [self initWithProviderID:providerID
   84|      0|                          profile:profile
   85|      0|                         username:username
   86|      0|                        isNewUser:isNewUser.boolValue];
   87|      0|}
   88|       |
   89|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   90|      0|  [aCoder encodeObject:_providerID forKey:kProviderIDCodingKey];
   91|      0|  [aCoder encodeObject:_profile forKey:kProfileCodingKey];
   92|      0|  [aCoder encodeObject:_username forKey:kUsernameCodingKey];
   93|      0|  [aCoder encodeObject:[NSNumber numberWithBool:_newUser] forKey:kNewUserKey];
   94|      0|}
   95|       |
   96|       |@end
   97|       |
   98|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuth.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import <Foundation/Foundation.h>
   18|       |
   19|       |#import "FIRAuth_Internal.h"
   20|       |
   21|       |#if __has_include(<UIKit/UIKit.h>)
   22|       |#import <UIKit/UIKit.h>
   23|       |#endif
   24|       |
   25|       |#import <FirebaseCore/FIRAppAssociationRegistration.h>
   26|       |#import <FirebaseCore/FIRAppInternal.h>
   27|       |#import <FirebaseCore/FIRComponent.h>
   28|       |#import <FirebaseCore/FIRComponentContainer.h>
   29|       |#import <FirebaseCore/FIRLibrary.h>
   30|       |#import <FirebaseCore/FIRLogger.h>
   31|       |#import <FirebaseCore/FIROptions.h>
   32|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   33|       |
   34|       |#import "AuthProviders/EmailPassword/FIREmailPasswordAuthCredential.h"
   35|       |#import "FIRAdditionalUserInfo_Internal.h"
   36|       |#import "FIRAuthCredential_Internal.h"
   37|       |#import "FIRAuthDataResult_Internal.h"
   38|       |#import "FIRAuthDispatcher.h"
   39|       |#import "FIRAuthErrorUtils.h"
   40|       |#import "FIRAuthExceptionUtils.h"
   41|       |#import "FIRAuthGlobalWorkQueue.h"
   42|       |#import "FIRAuthKeychain.h"
   43|       |#import "FIRAuthOperationType.h"
   44|       |#import "FIRAuthSettings.h"
   45|       |#import "FIRUser_Internal.h"
   46|       |#import "FirebaseAuth.h"
   47|       |#import "FIRAuthBackend.h"
   48|       |#import "FIRAuthRequestConfiguration.h"
   49|       |#import "FIRCreateAuthURIRequest.h"
   50|       |#import "FIRCreateAuthURIResponse.h"
   51|       |#import "FIREmailLinkSignInRequest.h"
   52|       |#import "FIREmailLinkSignInResponse.h"
   53|       |#import "FIRGameCenterAuthCredential.h"
   54|       |#import "FIRGetOOBConfirmationCodeRequest.h"
   55|       |#import "FIRGetOOBConfirmationCodeResponse.h"
   56|       |#import "FIRResetPasswordRequest.h"
   57|       |#import "FIRResetPasswordResponse.h"
   58|       |#import "FIRSendVerificationCodeRequest.h"
   59|       |#import "FIRSendVerificationCodeResponse.h"
   60|       |#import "FIRSetAccountInfoRequest.h"
   61|       |#import "FIRSetAccountInfoResponse.h"
   62|       |#import "FIRSignInWithGameCenterRequest.h"
   63|       |#import "FIRSignInWithGameCenterResponse.h"
   64|       |#import "FIRSignUpNewUserRequest.h"
   65|       |#import "FIRSignUpNewUserResponse.h"
   66|       |#import "FIRVerifyAssertionRequest.h"
   67|       |#import "FIRVerifyAssertionResponse.h"
   68|       |#import "FIRVerifyCustomTokenRequest.h"
   69|       |#import "FIRVerifyCustomTokenResponse.h"
   70|       |#import "FIRVerifyPasswordRequest.h"
   71|       |#import "FIRVerifyPasswordResponse.h"
   72|       |#import "FIRVerifyPhoneNumberRequest.h"
   73|       |#import "FIRVerifyPhoneNumberResponse.h"
   74|       |
   75|       |#if TARGET_OS_IOS
   76|       |#import "FIRAuthAPNSToken.h"
   77|       |#import "FIRAuthAPNSTokenManager.h"
   78|       |#import "FIRAuthAppCredentialManager.h"
   79|       |#import "FIRAuthAppDelegateProxy.h"
   80|       |#import "AuthProviders/Phone/FIRPhoneAuthCredential_Internal.h"
   81|       |#import "FIRAuthNotificationManager.h"
   82|       |#import "FIRAuthURLPresenter.h"
   83|       |#endif
   84|       |
   85|       |#pragma mark - Constants
   86|       |
   87|       |#if defined(__IPHONE_10_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_10_0
   88|       |const NSNotificationName FIRAuthStateDidChangeNotification = @"FIRAuthStateDidChangeNotification";
   89|       |#else
   90|       |NSString *const FIRAuthStateDidChangeNotification = @"FIRAuthStateDidChangeNotification";
   91|       |#endif  // defined(__IPHONE_10_0) && __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_10_0
   92|       |
   93|       |/** @var kMaxWaitTimeForBackoff
   94|       |    @brief The maximum wait time before attempting to retry auto refreshing tokens after a failed
   95|       |        attempt.
   96|       |    @remarks This is the upper limit (in seconds) of the exponential backoff used for retrying
   97|       |        token refresh.
   98|       | */
   99|       |static NSTimeInterval kMaxWaitTimeForBackoff = 16 * 60;
  100|       |
  101|       |/** @var kTokenRefreshHeadStart
  102|       |    @brief The amount of time before the token expires that proactive refresh should be attempted.
  103|       | */
  104|       |NSTimeInterval kTokenRefreshHeadStart  = 5 * 60;
  105|       |
  106|       |/** @var kUserKey
  107|       |    @brief Key of user stored in the keychain. Prefixed with a Firebase app name.
  108|       | */
  109|       |static NSString *const kUserKey = @"%@_firebase_user";
  110|       |
  111|       |/** @var kMissingEmailInvalidParameterExceptionReason
  112|       |    @brief The reason for @c invalidParameterException when the email used to initiate password
  113|       |        reset is nil.
  114|       | */
  115|       |static NSString *const kMissingEmailInvalidParameterExceptionReason =
  116|       |    @"The email used to initiate password reset cannot be nil.";
  117|       |
  118|       |/** @var kHandleCodeInAppFalseExceptionReason
  119|       |    @brief The reason for @c invalidParameterException when the handleCodeInApp parameter is false
  120|       |        on the ActionCodeSettings object used to send the link for Email-link Authentication.
  121|       | */
  122|       |static NSString *const kHandleCodeInAppFalseExceptionReason =
  123|       |    @"You must set handleCodeInApp in your ActionCodeSettings to true for Email-link "
  124|       |    "Authentication.";
  125|       |
  126|       |static NSString *const kInvalidEmailSignInLinkExceptionMessage =
  127|       |    @"The link provided is not valid for email/link sign-in. Please check the link by calling "
  128|       |    "isSignInWithEmailLink:link: on Auth before attempting to use it for email/link sign-in.";
  129|       |
  130|       |/** @var kPasswordResetRequestType
  131|       |    @brief The action code type value for resetting password in the check action code response.
  132|       | */
  133|       |static NSString *const kPasswordResetRequestType = @"PASSWORD_RESET";
  134|       |
  135|       |/** @var kVerifyEmailRequestType
  136|       |    @brief The action code type value for verifying email in the check action code response.
  137|       | */
  138|       |static NSString *const kVerifyEmailRequestType = @"VERIFY_EMAIL";
  139|       |
  140|       |/** @var kRecoverEmailRequestType
  141|       |    @brief The action code type value for recovering email in the check action code response.
  142|       | */
  143|       |static NSString *const kRecoverEmailRequestType = @"RECOVER_EMAIL";
  144|       |
  145|       |/** @var kEmailLinkSignInRequestType
  146|       |    @brief The action code type value for an email sign-in link in the check action code response.
  147|       |*/
  148|       |static NSString *const kEmailLinkSignInRequestType = @"EMAIL_SIGNIN";
  149|       |
  150|       |/** @var kMissingPasswordReason
  151|       |    @brief The reason why the @c FIRAuthErrorCodeWeakPassword error is thrown.
  152|       |    @remarks This error message will be localized in the future.
  153|       | */
  154|       |static NSString *const kMissingPasswordReason = @"Missing Password";
  155|       |
  156|       |/** @var gKeychainServiceNameForAppName
  157|       |    @brief A map from Firebase app name to keychain service names.
  158|       |    @remarks This map is needed for looking up the keychain service name after the FIRApp instance
  159|       |        is deleted, to remove the associated keychain item. Accessing should occur within a
  160|       |        @syncronized([FIRAuth class]) context.
  161|       | */
  162|       |static NSMutableDictionary *gKeychainServiceNameForAppName;
  163|       |
  164|       |#pragma mark - FIRActionCodeInfo
  165|       |
  166|       |@implementation FIRActionCodeInfo {
  167|       |  /** @var _email
  168|       |      @brief The email address to which the code was sent. The new email address in the case of
  169|       |          FIRActionCodeOperationRecoverEmail.
  170|       |   */
  171|       |  NSString *_email;
  172|       |
  173|       |  /** @var _fromEmail
  174|       |      @brief The current email address in the case of FIRActionCodeOperationRecoverEmail.
  175|       |   */
  176|       |  NSString *_fromEmail;
  177|       |}
  178|       |
  179|      0|- (NSString *)dataForKey:(FIRActionDataKey)key{
  180|      0|  switch (key) {
  181|      0|    case FIRActionCodeEmailKey:
  182|      0|      return _email;
  183|      0|    case FIRActionCodeFromEmailKey:
  184|      0|      return _fromEmail;
  185|      0|  }
  186|      0|}
  187|       |
  188|       |- (instancetype)initWithOperation:(FIRActionCodeOperation)operation
  189|       |                            email:(NSString *)email
  190|      0|                         newEmail:(nullable NSString *)newEmail {
  191|      0|  self = [super init];
  192|      0|  if (self) {
  193|      0|    _operation = operation;
  194|      0|    if (newEmail) {
  195|      0|      _email = [newEmail copy];
  196|      0|      _fromEmail = [email copy];
  197|      0|    } else {
  198|      0|      _email = [email copy];
  199|      0|    }
  200|      0|  }
  201|      0|  return self;
  202|      0|}
  203|       |
  204|       |/** @fn actionCodeOperationForRequestType:
  205|       |    @brief Returns the corresponding operation type per provided request type string.
  206|       |    @param requestType Request type returned in in the server response.
  207|       |    @return The corresponding FIRActionCodeOperation for the supplied request type.
  208|       | */
  209|      0|+ (FIRActionCodeOperation)actionCodeOperationForRequestType:(NSString *)requestType {
  210|      0|  if ([requestType isEqualToString:kPasswordResetRequestType]) {
  211|      0|    return FIRActionCodeOperationPasswordReset;
  212|      0|  }
  213|      0|  if ([requestType isEqualToString:kVerifyEmailRequestType]) {
  214|      0|    return FIRActionCodeOperationVerifyEmail;
  215|      0|  }
  216|      0|  if ([requestType isEqualToString:kRecoverEmailRequestType]) {
  217|      0|    return FIRActionCodeOperationRecoverEmail;
  218|      0|  }
  219|      0|  if ([requestType isEqualToString:kEmailLinkSignInRequestType]) {
  220|      0|    return FIRActionCodeOperationEmailLink;
  221|      0|  }
  222|      0|  return FIRActionCodeOperationUnknown;
  223|      0|}
  224|       |
  225|       |@end
  226|       |
  227|       |#pragma mark - FIRAuth
  228|       |
  229|       |#if TARGET_OS_IOS
  230|       |@interface FIRAuth () <FIRAuthAppDelegateHandler, FIRLibrary, FIRComponentLifecycleMaintainer>
  231|       |#else
  232|       |@interface FIRAuth () <FIRLibrary, FIRComponentLifecycleMaintainer>
  233|       |#endif
  234|       |
  235|       |/** @property firebaseAppId
  236|       |    @brief The Firebase app ID.
  237|       | */
  238|       |@property(nonatomic, copy, readonly) NSString *firebaseAppId;
  239|       |
  240|       |/** @property additionalFrameworkMarker
  241|       |    @brief Additional framework marker that will be added as part of the header of every request.
  242|       | */
  243|       |@property(nonatomic, copy, nullable) NSString *additionalFrameworkMarker;
  244|       |
  245|       |/** @fn initWithApp:
  246|       |    @brief Creates a @c FIRAuth instance associated with the provided @c FIRApp instance.
  247|       |    @param app The application to associate the auth instance with.
  248|       | */
  249|       |- (instancetype)initWithApp:(FIRApp *)app;
  250|       |
  251|       |@end
  252|       |
  253|       |@implementation FIRAuth {
  254|       |  /** @var _currentUser
  255|       |      @brief The current user.
  256|       |   */
  257|       |  FIRUser *_currentUser;
  258|       |
  259|       |  /** @var _firebaseAppName
  260|       |      @brief The Firebase app name.
  261|       |   */
  262|       |  NSString *_firebaseAppName;
  263|       |
  264|       |  /** @var _listenerHandles
  265|       |      @brief Handles returned from @c NSNotificationCenter for blocks which are "auth state did
  266|       |          change" notification listeners.
  267|       |      @remarks Mutations should occur within a @syncronized(self) context.
  268|       |   */
  269|       |  NSMutableArray<FIRAuthStateDidChangeListenerHandle> *_listenerHandles;
  270|       |
  271|       |  /** @var _keychain
  272|       |      @brief The keychain service.
  273|       |   */
  274|       |  FIRAuthKeychain *_keychain;
  275|       |
  276|       |  /** @var _lastNotifiedUserToken
  277|       |      @brief The user access (ID) token used last time for posting auth state changed notification.
  278|       |   */
  279|       |  NSString *_lastNotifiedUserToken;
  280|       |
  281|       |  /** @var _autoRefreshTokens
  282|       |      @brief This flag denotes whether or not tokens should be automatically refreshed.
  283|       |      @remarks Will only be set to @YES if the another Firebase service is included (additionally to
  284|       |        Firebase Auth).
  285|       |   */
  286|       |  BOOL _autoRefreshTokens;
  287|       |
  288|       |  /** @var _autoRefreshScheduled
  289|       |      @brief Whether or not token auto-refresh is currently scheduled.
  290|       |   */
  291|       |  BOOL _autoRefreshScheduled;
  292|       |
  293|       |  /** @var _isAppInBackground
  294|       |      @brief A flag that is set to YES if the app is put in the background and no when the app is
  295|       |          returned to the foreground.
  296|       |   */
  297|       |  BOOL _isAppInBackground;
  298|       |
  299|       |  /** @var _applicationDidBecomeActiveObserver
  300|       |      @brief An opaque object to act as the observer for UIApplicationDidBecomeActiveNotification.
  301|       |   */
  302|       |  id<NSObject> _applicationDidBecomeActiveObserver;
  303|       |
  304|       |  /** @var _applicationDidBecomeActiveObserver
  305|       |      @brief An opaque object to act as the observer for
  306|       |          UIApplicationDidEnterBackgroundNotification.
  307|       |   */
  308|       |  id<NSObject> _applicationDidEnterBackgroundObserver;
  309|       |}
  310|       |
  311|      1|+ (void)load {
  312|      1|  [FIRApp registerInternalLibrary:(Class<FIRLibrary>)self
  313|      1|                 withName:@"fire-auth"
  314|      1|              withVersion:[NSString stringWithUTF8String:FirebaseAuthVersionStr]];
  315|      1|}
  316|       |
  317|      1|+ (void)initialize {
  318|      1|  gKeychainServiceNameForAppName = [[NSMutableDictionary alloc] init];
  319|      1|}
  320|       |
  321|      0|+ (FIRAuth *)auth {
  322|      0|  FIRApp *defaultApp = [FIRApp defaultApp];
  323|      0|  if (!defaultApp) {
  324|      0|    [NSException raise:NSInternalInconsistencyException
  325|      0|                format:@"The default FIRApp instance must be configured before the default FIRAuth"
  326|      0|                       @"instance can be initialized. One way to ensure that is to call "
  327|      0|                       @"`[FIRApp configure];` (`FirebaseApp.configure()` in Swift) in the App "
  328|      0|                       @"Delegate's `application:didFinishLaunchingWithOptions:` "
  329|      0|                       @"(`application(_:didFinishLaunchingWithOptions:)` in Swift)."];
  330|      0|  }
  331|      0|  return [self authWithApp:defaultApp];
  332|      0|}
  333|       |
  334|      1|+ (FIRAuth *)authWithApp:(FIRApp *)app {
  335|      1|  // Get the instance of Auth from the container, which will create or return the cached instance
  336|      1|  // associated with this app.
  337|      1|  id<FIRAuthInterop> auth = FIR_COMPONENT(FIRAuthInterop, app.container);
  338|      1|  return (FIRAuth *)auth;
  339|      1|}
  340|       |
  341|      1|- (instancetype)initWithApp:(FIRApp *)app {
  342|      1|  [FIRAuth setKeychainServiceNameForApp:app];
  343|      1|  self = [self initWithAPIKey:app.options.APIKey appName:app.name];
  344|      1|  if (self) {
  345|      1|    _app = app;
  346|      1|    #if TARGET_OS_IOS
  347|      1|    _authURLPresenter = [[FIRAuthURLPresenter alloc] init];
  348|      1|    #endif
  349|      1|  }
  350|      1|  return self;
  351|      1|}
  352|       |
  353|      1|- (instancetype)initWithAPIKey:(NSString *)APIKey appName:(NSString *)appName {
  354|      1|  self = [super init];
  355|      1|  if (self) {
  356|      1|    _listenerHandles = [NSMutableArray array];
  357|      1|    _requestConfiguration = [[FIRAuthRequestConfiguration alloc] initWithAPIKey:APIKey];
  358|      1|    _settings = [[FIRAuthSettings alloc] init];
  359|      1|    _firebaseAppName = [appName copy];
  360|      1|    #if TARGET_OS_IOS
  361|      1|
  362|      1|    static Class applicationClass = nil;
  363|      1|    // iOS App extensions should not call [UIApplication sharedApplication], even if UIApplication
  364|      1|    // responds to it.
  365|      1|    if (![GULAppEnvironmentUtil isAppExtension]) {
  366|      1|      Class cls = NSClassFromString(@"UIApplication");
  367|      1|      if (cls && [cls respondsToSelector:NSSelectorFromString(@"sharedApplication")]) {
  368|      1|        applicationClass = cls;
  369|      1|      }
  370|      1|    }
  371|      1|    UIApplication *application = [applicationClass sharedApplication];
  372|      1|
  373|      1|    // Initialize the shared FIRAuthAppDelegateProxy instance in the main thread if not already.
  374|      1|    [FIRAuthAppDelegateProxy sharedInstance];
  375|      1|    #endif
  376|      1|
  377|      1|    // Continue with the rest of initialization in the work thread.
  378|      1|    __weak FIRAuth *weakSelf = self;
  379|      1|    dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  380|      1|      // Load current user from Keychain.
  381|      1|      FIRAuth *strongSelf = weakSelf;
  382|      1|      if (!strongSelf) {
  383|      0|        return;
  384|      0|      }
  385|      1|      NSString *keychainServiceName =
  386|      1|          [FIRAuth keychainServiceNameForAppName:strongSelf->_firebaseAppName];
  387|      1|      if (keychainServiceName) {
  388|      1|        strongSelf->_keychain = [[FIRAuthKeychain alloc] initWithService:keychainServiceName];
  389|      1|      }
  390|      1|      FIRUser *user;
  391|      1|      NSError *error;
  392|      1|      if ([strongSelf getUser:&user error:&error]) {
  393|      1|        [strongSelf updateCurrentUser:user byForce:NO savingToDisk:NO error:&error];
  394|      1|        self->_lastNotifiedUserToken = user.rawAccessToken;
  395|      1|      } else {
  396|      0|        FIRLogError(kFIRLoggerAuth, @"I-AUT000001",
  397|      0|                    @"Error loading saved user when starting up: %@", error);
  398|      0|      }
  399|      1|
  400|      1|      #if TARGET_OS_IOS
  401|      1|      // Initialize for phone number auth.
  402|      1|      strongSelf->_tokenManager =
  403|      1|          [[FIRAuthAPNSTokenManager alloc] initWithApplication:application];
  404|      1|
  405|      1|      strongSelf->_appCredentialManager =
  406|      1|          [[FIRAuthAppCredentialManager alloc] initWithKeychain:strongSelf->_keychain];
  407|      1|
  408|      1|      strongSelf->_notificationManager = [[FIRAuthNotificationManager alloc]
  409|      1|           initWithApplication:application
  410|      1|          appCredentialManager:strongSelf->_appCredentialManager];
  411|      1|
  412|      1|      [[FIRAuthAppDelegateProxy sharedInstance] addHandler:strongSelf];
  413|      1|      #endif
  414|      1|    });
  415|      1|  }
  416|      1|  return self;
  417|      1|}
  418|       |
  419|      0|- (void)dealloc {
  420|      0|  @synchronized (self) {
  421|      0|    NSNotificationCenter *defaultCenter = [NSNotificationCenter defaultCenter];
  422|      0|    while (_listenerHandles.count != 0) {
  423|      0|      FIRAuthStateDidChangeListenerHandle handleToRemove = _listenerHandles.lastObject;
  424|      0|      [defaultCenter removeObserver:handleToRemove];
  425|      0|      [_listenerHandles removeLastObject];
  426|      0|    }
  427|      0|
  428|      0|    #if TARGET_OS_IOS
  429|      0|    [defaultCenter removeObserver:_applicationDidBecomeActiveObserver
  430|      0|                             name:UIApplicationDidBecomeActiveNotification
  431|      0|                           object:nil];
  432|      0|    [defaultCenter removeObserver:_applicationDidEnterBackgroundObserver
  433|      0|                             name:UIApplicationDidEnterBackgroundNotification
  434|      0|                           object:nil];
  435|      0|    #endif
  436|      0|  }
  437|      0|}
  438|       |
  439|       |#pragma mark - Public API
  440|       |
  441|      0|- (FIRUser *)currentUser {
  442|      0|  __block FIRUser *result;
  443|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
  444|      0|    result = self->_currentUser;
  445|      0|  });
  446|      0|  return result;
  447|      0|}
  448|       |
  449|       |- (void)fetchProvidersForEmail:(NSString *)email
  450|      0|                    completion:(FIRProviderQueryCallback)completion {
  451|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  452|      0|    FIRCreateAuthURIRequest *request =
  453|      0|        [[FIRCreateAuthURIRequest alloc] initWithIdentifier:email
  454|      0|                                                continueURI:@"http://www.google.com/"
  455|      0|                                       requestConfiguration:self->_requestConfiguration];
  456|      0|    [FIRAuthBackend createAuthURI:request callback:^(FIRCreateAuthURIResponse *_Nullable response,
  457|      0|                                                     NSError *_Nullable error) {
  458|      0|      if (completion) {
  459|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  460|      0|          completion(response.allProviders, error);
  461|      0|        });
  462|      0|      }
  463|      0|    }];
  464|      0|  });
  465|      0|}
  466|       |
  467|       |- (void)fetchSignInMethodsForEmail:(nonnull NSString *)email
  468|      0|                        completion:(nullable FIRSignInMethodQueryCallback)completion {
  469|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  470|      0|    FIRCreateAuthURIRequest *request =
  471|      0|        [[FIRCreateAuthURIRequest alloc] initWithIdentifier:email
  472|      0|                                                continueURI:@"http://www.google.com/"
  473|      0|                                       requestConfiguration:self->_requestConfiguration];
  474|      0|    [FIRAuthBackend createAuthURI:request callback:^(FIRCreateAuthURIResponse *_Nullable response,
  475|      0|                                                     NSError *_Nullable error) {
  476|      0|      if (completion) {
  477|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  478|      0|          completion(response.signinMethods, error);
  479|      0|        });
  480|      0|      }
  481|      0|    }];
  482|      0|  });
  483|      0|}
  484|       |
  485|       |- (void)signInWithEmail:(NSString *)email
  486|       |               password:(NSString *)password
  487|      0|             completion:(FIRAuthDataResultCallback)completion {
  488|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  489|      0|    FIRAuthDataResultCallback decoratedCallback =
  490|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  491|      0|    [self internalSignInAndRetrieveDataWithEmail:email
  492|      0|                                        password:password
  493|      0|                                      completion:^(FIRAuthDataResult *_Nullable authResult,
  494|      0|                                                   NSError *_Nullable error) {
  495|      0|      decoratedCallback(authResult, error);
  496|      0|    }];
  497|      0|  });
  498|      0|}
  499|       |
  500|       |- (void)signInWithEmail:(NSString *)email
  501|       |                   link:(NSString *)link
  502|      0|             completion:(FIRAuthDataResultCallback)completion {
  503|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  504|      0|    FIRAuthDataResultCallback decoratedCallback =
  505|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  506|      0|    FIREmailPasswordAuthCredential *credential =
  507|      0|        [[FIREmailPasswordAuthCredential alloc] initWithEmail:email link:link];
  508|      0|    [self internalSignInAndRetrieveDataWithCredential:credential
  509|      0|                                   isReauthentication:NO
  510|      0|                                             callback:^(FIRAuthDataResult *_Nullable authResult,
  511|      0|                                                        NSError *_Nullable error) {
  512|      0|      decoratedCallback(authResult, error);
  513|      0|    }];
  514|      0|  });
  515|      0|}
  516|       |
  517|       |/** @fn signInWithEmail:password:callback:
  518|       |    @brief Signs in using an email address and password.
  519|       |    @param email The user's email address.
  520|       |    @param password The user's password.
  521|       |    @param callback A block which is invoked when the sign in finishes (or is cancelled.) Invoked
  522|       |        asynchronously on the global auth work queue in the future.
  523|       |    @remarks This is the internal counterpart of this method, which uses a callback that does not
  524|       |        update the current user.
  525|       | */
  526|       |- (void)signInWithEmail:(NSString *)email
  527|       |               password:(NSString *)password
  528|      0|               callback:(FIRAuthResultCallback)callback {
  529|      0|
  530|      0|  FIRVerifyPasswordRequest *request =
  531|      0|      [[FIRVerifyPasswordRequest alloc] initWithEmail:email
  532|      0|                                             password:password
  533|      0|                                 requestConfiguration:_requestConfiguration];
  534|      0|
  535|      0|  if (![request.password length]) {
  536|      0|    callback(nil, [FIRAuthErrorUtils wrongPasswordErrorWithMessage:nil]);
  537|      0|    return;
  538|      0|  }
  539|      0|  [FIRAuthBackend verifyPassword:request
  540|      0|                        callback:^(FIRVerifyPasswordResponse *_Nullable response,
  541|      0|                                   NSError *_Nullable error) {
  542|      0|    if (error) {
  543|      0|      callback(nil, error);
  544|      0|      return;
  545|      0|    }
  546|      0|    [self completeSignInWithAccessToken:response.IDToken
  547|      0|              accessTokenExpirationDate:response.approximateExpirationDate
  548|      0|                           refreshToken:response.refreshToken
  549|      0|                              anonymous:NO
  550|      0|                               callback:callback];
  551|      0|  }];
  552|      0|}
  553|       |
  554|       |- (void)signInAndRetrieveDataWithEmail:(NSString *)email
  555|       |                              password:(NSString *)password
  556|      0|                            completion:(FIRAuthDataResultCallback)completion {
  557|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  558|      0|  FIRAuthDataResultCallback decoratedCallback =
  559|      0|      [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  560|      0|    [self internalSignInAndRetrieveDataWithEmail:email
  561|      0|                                        password:password
  562|      0|                                      completion:decoratedCallback];
  563|      0|  });
  564|      0|}
  565|       |
  566|       |/** @fn internalSignInAndRetrieveDataWithEmail:password:callback:
  567|       |    @brief Signs in using an email address and password.
  568|       |    @param email The user's email address.
  569|       |    @param password The user's password.
  570|       |    @param completion A block which is invoked when the sign in finishes (or is cancelled.) Invoked
  571|       |        asynchronously on the global auth work queue in the future.
  572|       |    @remarks This is the internal counterpart of this method, which uses a callback that does not
  573|       |        update the current user.
  574|       | */
  575|       |- (void)internalSignInAndRetrieveDataWithEmail:(NSString *)email
  576|       |                                      password:(NSString *)password
  577|      0|                                    completion:(FIRAuthDataResultCallback)completion {
  578|      0|  FIREmailPasswordAuthCredential *credentail =
  579|      0|      [[FIREmailPasswordAuthCredential alloc] initWithEmail:email password:password];
  580|      0|  [self internalSignInAndRetrieveDataWithCredential:credentail
  581|      0|                                 isReauthentication:NO
  582|      0|                                           callback:completion];
  583|      0|}
  584|       |
  585|       |/** @fn signInWithGameCenterCredential:callback:
  586|       |    @brief Signs in using a game center credential.
  587|       |    @param credential The Game Center Auth Credential used to sign in.
  588|       |    @param callback A block which is invoked when the sign in finished (or is cancelled). Invoked
  589|       |        asynchronously on the global auth work queue in the future.
  590|       | */
  591|       |- (void)signInWithGameCenterCredential:(FIRGameCenterAuthCredential *)credential
  592|      0|                              callback:(FIRAuthResultCallback)callback {
  593|      0|  FIRSignInWithGameCenterRequest *request =
  594|      0|    [[FIRSignInWithGameCenterRequest alloc] initWithPlayerID:credential.playerID
  595|      0|                                                publicKeyURL:credential.publicKeyURL
  596|      0|                                                   signature:credential.signature
  597|      0|                                                        salt:credential.salt
  598|      0|                                                   timestamp:credential.timestamp
  599|      0|                                                 displayName:credential.displayName
  600|      0|                                        requestConfiguration:_requestConfiguration];
  601|      0|  [FIRAuthBackend signInWithGameCenter:request
  602|      0|                              callback:^(FIRSignInWithGameCenterResponse *_Nullable response,
  603|      0|                                         NSError *_Nullable error) {
  604|      0|                                if (error) {
  605|      0|                                  if (callback) {
  606|      0|                                    callback(nil, error);
  607|      0|                                  }
  608|      0|                                  return;
  609|      0|                                }
  610|      0|
  611|      0|                                [self completeSignInWithAccessToken:response.IDToken
  612|      0|                                          accessTokenExpirationDate:response.approximateExpirationDate
  613|      0|                                                       refreshToken:response.refreshToken
  614|      0|                                                          anonymous:NO
  615|      0|                                                           callback:callback];
  616|      0|                              }];
  617|      0|}
  618|       |
  619|       |/** @fn internalSignInWithEmail:link:completion:
  620|       |    @brief Signs in using an email and email sign-in link.
  621|       |    @param email The user's email address.
  622|       |    @param link The email sign-in link.
  623|       |    @param callback A block which is invoked when the sign in finishes (or is cancelled.) Invoked
  624|       |        asynchronously on the global auth work queue in the future.
  625|       | */
  626|       |- (void)internalSignInWithEmail:(nonnull NSString *)email
  627|       |                           link:(nonnull NSString *)link
  628|      0|                       callback:(nullable FIRAuthResultCallback)callback {
  629|      0|  if (![self isSignInWithEmailLink:link]) {
  630|      0|    [FIRAuthExceptionUtils raiseInvalidParameterExceptionWithReason:
  631|      0|        kInvalidEmailSignInLinkExceptionMessage];
  632|      0|    return;
  633|      0|  }
  634|      0|  NSDictionary<NSString *, NSString *> *queryItems = FIRAuthParseURL(link);
  635|      0|  if (![queryItems count]) {
  636|      0|    NSURLComponents *urlComponents = [NSURLComponents componentsWithString:link];
  637|      0|    queryItems = FIRAuthParseURL(urlComponents.query);
  638|      0|  }
  639|      0|  NSString *actionCode = queryItems[@"oobCode"];
  640|      0|
  641|      0|  FIREmailLinkSignInRequest *request =
  642|      0|      [[FIREmailLinkSignInRequest alloc] initWithEmail:email
  643|      0|                                               oobCode:actionCode
  644|      0|                                  requestConfiguration:_requestConfiguration];
  645|      0|
  646|      0|  [FIRAuthBackend emailLinkSignin:request
  647|      0|                         callback:^(FIREmailLinkSignInResponse *_Nullable response,
  648|      0|                                    NSError *_Nullable error) {
  649|      0|    if (error) {
  650|      0|      callback(nil, error);
  651|      0|      return;
  652|      0|    }
  653|      0|    [self completeSignInWithAccessToken:response.IDToken
  654|      0|              accessTokenExpirationDate:response.approximateExpirationDate
  655|      0|                           refreshToken:response.refreshToken
  656|      0|                              anonymous:NO
  657|      0|                               callback:callback];
  658|      0|  }];
  659|      0|}
  660|       |
  661|       |- (void)signInWithCredential:(FIRAuthCredential *)credential
  662|      0|                  completion:(FIRAuthResultCallback)completion {
  663|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  664|      0|    FIRAuthResultCallback callback =
  665|      0|        [self signInFlowAuthResultCallbackByDecoratingCallback:completion];
  666|      0|    [self internalSignInWithCredential:credential callback:callback];
  667|      0|  });
  668|      0|}
  669|       |
  670|       |- (void)signInAndRetrieveDataWithCredential:(FIRAuthCredential *)credential
  671|      0|                                 completion:(nullable FIRAuthDataResultCallback)completion {
  672|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  673|      0|    FIRAuthDataResultCallback callback =
  674|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  675|      0|    [self internalSignInAndRetrieveDataWithCredential:credential
  676|      0|                                   isReauthentication:NO
  677|      0|                                             callback:callback];
  678|      0|  });
  679|      0|}
  680|       |
  681|       |- (void)internalSignInWithCredential:(FIRAuthCredential *)credential
  682|      0|                            callback:(FIRAuthResultCallback)callback {
  683|      0|  [self internalSignInAndRetrieveDataWithCredential:credential
  684|      0|                                 isReauthentication:NO
  685|      0|                                           callback:^(FIRAuthDataResult *_Nullable authResult,
  686|      0|                                                      NSError *_Nullable error) {
  687|      0|    callback(authResult.user, error);
  688|      0|  }];
  689|      0|}
  690|       |
  691|       |- (void)internalSignInAndRetrieveDataWithCredential:(FIRAuthCredential *)credential
  692|       |                                 isReauthentication:(BOOL)isReauthentication
  693|      0|                                           callback:(nullable FIRAuthDataResultCallback)callback {
  694|      0|  if ([credential isKindOfClass:[FIREmailPasswordAuthCredential class]]) {
  695|      0|    // Special case for email/password credentials
  696|      0|    FIREmailPasswordAuthCredential *emailPasswordCredential =
  697|      0|        (FIREmailPasswordAuthCredential *)credential;
  698|      0|    FIRAuthResultCallback completeEmailSignIn = ^(FIRUser *user, NSError *error) {
  699|      0|      if (callback) {
  700|      0|        if (error) {
  701|      0|          callback(nil, error);
  702|      0|          return;
  703|      0|        }
  704|      0|    FIRAdditionalUserInfo *additionalUserInfo =
  705|      0|        [[FIRAdditionalUserInfo alloc] initWithProviderID:FIREmailAuthProviderID
  706|      0|                                                  profile:nil
  707|      0|                                                 username:nil
  708|      0|                                                isNewUser:NO];
  709|      0|        FIRAuthDataResult *result = [[FIRAuthDataResult alloc] initWithUser:user
  710|      0|                                                         additionalUserInfo:additionalUserInfo];
  711|      0|        callback(result, error);
  712|      0|      }
  713|      0|    };
  714|      0|    if (emailPasswordCredential.link) {
  715|      0|      [self internalSignInWithEmail:emailPasswordCredential.email
  716|      0|                               link:emailPasswordCredential.link
  717|      0|                           callback:completeEmailSignIn];
  718|      0|    } else {
  719|      0|      [self signInWithEmail:emailPasswordCredential.email
  720|      0|                   password:emailPasswordCredential.password
  721|      0|                   callback:completeEmailSignIn];
  722|      0|    }
  723|      0|    return;
  724|      0|  }
  725|      0|
  726|      0|  if ([credential isKindOfClass:[FIRGameCenterAuthCredential class]]) {
  727|      0|    // Special case for Game Center credentials.
  728|      0|    [self signInWithGameCenterCredential:(FIRGameCenterAuthCredential *)credential
  729|      0|                                callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  730|      0|      if (callback) {
  731|      0|        FIRAuthDataResult *result;
  732|      0|        if (user) {
  733|      0|          result = [[FIRAuthDataResult alloc] initWithUser:user additionalUserInfo:nil];
  734|      0|        }
  735|      0|        callback(result, error);
  736|      0|      }
  737|      0|    }];
  738|      0|    return;
  739|      0|  }
  740|      0|
  741|      0|  #if TARGET_OS_IOS
  742|      0|  if ([credential isKindOfClass:[FIRPhoneAuthCredential class]]) {
  743|      0|    // Special case for phone auth credentials
  744|      0|    FIRPhoneAuthCredential *phoneCredential = (FIRPhoneAuthCredential *)credential;
  745|      0|    FIRAuthOperationType operation =
  746|      0|        isReauthentication ? FIRAuthOperationTypeReauth : FIRAuthOperationTypeSignUpOrSignIn;
  747|      0|    [self signInWithPhoneCredential:phoneCredential
  748|      0|                          operation:operation
  749|      0|                           callback:^(FIRVerifyPhoneNumberResponse *_Nullable response,
  750|      0|                                      NSError *_Nullable error) {
  751|      0|      if (callback) {
  752|      0|        if (error) {
  753|      0|          callback(nil, error);
  754|      0|          return;
  755|      0|        }
  756|      0|
  757|      0|        [self completeSignInWithAccessToken:response.IDToken
  758|      0|                  accessTokenExpirationDate:response.approximateExpirationDate
  759|      0|                               refreshToken:response.refreshToken
  760|      0|                                  anonymous:NO
  761|      0|                                   callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  762|      0|          FIRAdditionalUserInfo *additionalUserInfo =
  763|      0|              [[FIRAdditionalUserInfo alloc] initWithProviderID:FIRPhoneAuthProviderID
  764|      0|                                                        profile:nil
  765|      0|                                                       username:nil
  766|      0|                                                      isNewUser:response.isNewUser];
  767|      0|          FIRAuthDataResult *result = user ?
  768|      0|              [[FIRAuthDataResult alloc] initWithUser:user
  769|      0|                                   additionalUserInfo:additionalUserInfo] : nil;
  770|      0|          callback(result, error);
  771|      0|        }];
  772|      0|      }
  773|      0|    }];
  774|      0|    return;
  775|      0|  }
  776|      0|  #endif
  777|      0|  FIRVerifyAssertionRequest *request =
  778|      0|      [[FIRVerifyAssertionRequest alloc] initWithProviderID:credential.provider
  779|      0|                                       requestConfiguration:_requestConfiguration];
  780|      0|  request.autoCreate = !isReauthentication;
  781|      0|  [credential prepareVerifyAssertionRequest:request];
  782|      0|  [FIRAuthBackend verifyAssertion:request
  783|      0|                         callback:^(FIRVerifyAssertionResponse *response, NSError *error) {
  784|      0|    if (error) {
  785|      0|      if (callback) {
  786|      0|        callback(nil, error);
  787|      0|      }
  788|      0|      return;
  789|      0|    }
  790|      0|
  791|      0|    if (response.needConfirmation) {
  792|      0|      if (callback) {
  793|      0|        NSString *email = response.email;
  794|      0|        callback(nil, [FIRAuthErrorUtils accountExistsWithDifferentCredentialErrorWithEmail:email]);
  795|      0|      }
  796|      0|      return;
  797|      0|    }
  798|      0|
  799|      0|    if (!response.providerID.length) {
  800|      0|      if (callback) {
  801|      0|        callback(nil, [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:response]);
  802|      0|      }
  803|      0|      return;
  804|      0|    }
  805|      0|    [self completeSignInWithAccessToken:response.IDToken
  806|      0|              accessTokenExpirationDate:response.approximateExpirationDate
  807|      0|                           refreshToken:response.refreshToken
  808|      0|                              anonymous:NO
  809|      0|                               callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  810|      0|      if (callback) {
  811|      0|        FIRAdditionalUserInfo *additionalUserInfo =
  812|      0|            [FIRAdditionalUserInfo userInfoWithVerifyAssertionResponse:response];
  813|      0|        FIRAuthDataResult *result = user ?
  814|      0|            [[FIRAuthDataResult alloc] initWithUser:user
  815|      0|                                 additionalUserInfo:additionalUserInfo] : nil;
  816|      0|        callback(result, error);
  817|      0|      }
  818|      0|    }];
  819|      0|  }];
  820|      0|}
  821|       |
  822|       |- (void)signInWithCredential:(FIRAuthCredential *)credential
  823|      0|                    callback:(FIRAuthResultCallback)callback {
  824|      0|  [self signInAndRetrieveDataWithCredential:credential
  825|      0|                                 completion:^(FIRAuthDataResult *_Nullable authResult,
  826|      0|                                              NSError *_Nullable error) {
  827|      0|    callback(authResult.user, error);
  828|      0|  }];
  829|      0|}
  830|       |
  831|      0|- (void)signInAnonymouslyAndRetrieveDataWithCompletion:(FIRAuthDataResultCallback)completion {
  832|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  833|      0|    FIRAuthDataResultCallback decoratedCallback =
  834|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  835|      0|    if (self->_currentUser.anonymous) {
  836|      0|      FIRAdditionalUserInfo *additionalUserInfo =
  837|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:nil
  838|      0|                                                    profile:nil
  839|      0|                                                   username:nil
  840|      0|                                                  isNewUser:NO];
  841|      0|      FIRAuthDataResult *authDataResult =
  842|      0|          [[FIRAuthDataResult alloc] initWithUser:self->_currentUser
  843|      0|                               additionalUserInfo:additionalUserInfo];
  844|      0|      decoratedCallback(authDataResult, nil);
  845|      0|      return;
  846|      0|    }
  847|      0|    [self internalSignInAnonymouslyWithCompletion:^(FIRSignUpNewUserResponse *_Nullable response,
  848|      0|                                                    NSError *_Nullable error) {
  849|      0|      if (error) {
  850|      0|        decoratedCallback(nil, error);
  851|      0|        return;
  852|      0|      }
  853|      0|      [self completeSignInWithAccessToken:response.IDToken
  854|      0|                accessTokenExpirationDate:response.approximateExpirationDate
  855|      0|                             refreshToken:response.refreshToken
  856|      0|                                anonymous:YES
  857|      0|                                 callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  858|      0|        FIRAdditionalUserInfo *additionalUserInfo =
  859|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:nil
  860|      0|                                                    profile:nil
  861|      0|                                                   username:nil
  862|      0|                                                  isNewUser:YES];
  863|      0|        FIRAuthDataResult *authDataResult =
  864|      0|            [[FIRAuthDataResult alloc] initWithUser:user
  865|      0|                                 additionalUserInfo:additionalUserInfo];
  866|      0|        decoratedCallback(authDataResult, nil);
  867|      0|     }];
  868|      0|    }];
  869|      0|  });
  870|      0|}
  871|       |
  872|      0|- (void)signInAnonymouslyWithCompletion:(FIRAuthDataResultCallback)completion {
  873|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  874|      0|    FIRAuthDataResultCallback decoratedCallback =
  875|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  876|      0|    if (self->_currentUser.anonymous) {
  877|      0|      FIRAuthDataResult *result =
  878|      0|          [[FIRAuthDataResult alloc] initWithUser:self->_currentUser additionalUserInfo:nil];
  879|      0|      decoratedCallback(result, nil);
  880|      0|      return;
  881|      0|    }
  882|      0|    [self internalSignInAnonymouslyWithCompletion:^(FIRSignUpNewUserResponse *_Nullable response,
  883|      0|                                                    NSError *_Nullable error) {
  884|      0|      if (error) {
  885|      0|        decoratedCallback(nil, error);
  886|      0|        return;
  887|      0|      }
  888|      0|      [self completeSignInWithAccessToken:response.IDToken
  889|      0|                accessTokenExpirationDate:response.approximateExpirationDate
  890|      0|                             refreshToken:response.refreshToken
  891|      0|                                anonymous:YES
  892|      0|                                 callback:^(FIRUser * _Nullable user, NSError * _Nullable error) {
  893|      0|        FIRAdditionalUserInfo *additionalUserInfo =
  894|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:FIREmailAuthProviderID
  895|      0|                                                    profile:nil
  896|      0|                                                   username:nil
  897|      0|                                                  isNewUser:YES];
  898|      0|        FIRAuthDataResult *authDataResult =
  899|      0|            [[FIRAuthDataResult alloc] initWithUser:user
  900|      0|                                 additionalUserInfo:additionalUserInfo];
  901|      0|        decoratedCallback(authDataResult, nil);
  902|      0|      }];
  903|      0|    }];
  904|      0|  });
  905|      0|}
  906|       |
  907|       |- (void)signInWithCustomToken:(NSString *)token
  908|      0|                   completion:(nullable FIRAuthDataResultCallback)completion {
  909|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  910|      0|    FIRAuthDataResultCallback decoratedCallback =
  911|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  912|      0|    [self internalSignInAndRetrieveDataWithCustomToken:token
  913|      0|                                            completion:^(FIRAuthDataResult *_Nullable authResult,
  914|      0|                                                         NSError *_Nullable error) {
  915|      0|      decoratedCallback(authResult, error);
  916|      0|    }];
  917|      0|  });
  918|      0|}
  919|       |
  920|       |- (void)signInAndRetrieveDataWithCustomToken:(NSString *)token
  921|      0|                                  completion:(nullable FIRAuthDataResultCallback)completion {
  922|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  923|      0|    FIRAuthDataResultCallback decoratedCallback =
  924|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  925|      0|    [self internalSignInAndRetrieveDataWithCustomToken:token completion:decoratedCallback];
  926|      0|  });
  927|      0|}
  928|       |
  929|       |- (void)createUserWithEmail:(NSString *)email
  930|       |                   password:(NSString *)password
  931|      0|                 completion:(nullable FIRAuthDataResultCallback)completion {
  932|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  933|      0|    FIRAuthDataResultCallback decoratedCallback =
  934|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  935|      0|    [self internalCreateUserWithEmail:email
  936|      0|                             password:password
  937|      0|                           completion:^(FIRSignUpNewUserResponse *_Nullable response,
  938|      0|                                        NSError *_Nullable error) {
  939|      0|      if (error) {
  940|      0|        decoratedCallback(nil, error);
  941|      0|        return;
  942|      0|      }
  943|      0|      [self completeSignInWithAccessToken:response.IDToken
  944|      0|                accessTokenExpirationDate:response.approximateExpirationDate
  945|      0|                             refreshToken:response.refreshToken
  946|      0|                                anonymous:NO
  947|      0|                                 callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  948|      0|        FIRAdditionalUserInfo *additionalUserInfo =
  949|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:FIREmailAuthProviderID
  950|      0|                                                    profile:nil
  951|      0|                                                   username:nil
  952|      0|                                                  isNewUser:YES];
  953|      0|        FIRAuthDataResult *authDataResult =
  954|      0|            [[FIRAuthDataResult alloc] initWithUser:user
  955|      0|                                 additionalUserInfo:additionalUserInfo];
  956|      0|        decoratedCallback(authDataResult, nil);
  957|      0|      }];
  958|      0|    }];
  959|      0|  });
  960|      0|}
  961|       |
  962|       |- (void)createUserAndRetrieveDataWithEmail:(NSString *)email
  963|       |                                  password:(NSString *)password
  964|      0|                                completion:(FIRAuthDataResultCallback)completion {
  965|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  966|      0|    FIRAuthDataResultCallback decoratedCallback =
  967|      0|        [self signInFlowAuthDataResultCallbackByDecoratingCallback:completion];
  968|      0|    [self internalCreateUserWithEmail:email
  969|      0|                             password:password
  970|      0|                           completion:^(FIRSignUpNewUserResponse *_Nullable response,
  971|      0|                                        NSError *_Nullable error) {
  972|      0|      if (error) {
  973|      0|        decoratedCallback(nil, error);
  974|      0|        return;
  975|      0|      }
  976|      0|
  977|      0|      [self completeSignInWithAccessToken:response.IDToken
  978|      0|                accessTokenExpirationDate:response.approximateExpirationDate
  979|      0|                             refreshToken:response.refreshToken
  980|      0|                                anonymous:NO
  981|      0|                                 callback:^(FIRUser *_Nullable user, NSError *_Nullable error) {
  982|      0|        FIRAdditionalUserInfo *additionalUserInfo =
  983|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:FIREmailAuthProviderID
  984|      0|                                                    profile:nil
  985|      0|                                                   username:nil
  986|      0|                                                  isNewUser:YES];
  987|      0|        FIRAuthDataResult *authDataResult =
  988|      0|            [[FIRAuthDataResult alloc] initWithUser:user
  989|      0|                                 additionalUserInfo:additionalUserInfo];
  990|      0|        decoratedCallback(authDataResult, nil);
  991|      0|     }];
  992|      0|    }];
  993|      0|  });
  994|      0|}
  995|       |
  996|       |- (void)confirmPasswordResetWithCode:(NSString *)code
  997|       |                         newPassword:(NSString *)newPassword
  998|      0|                          completion:(FIRConfirmPasswordResetCallback)completion {
  999|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1000|      0|    FIRResetPasswordRequest *request =
 1001|      0|        [[FIRResetPasswordRequest alloc] initWithOobCode:code
 1002|      0|                                             newPassword:newPassword
 1003|      0|                                    requestConfiguration:self->_requestConfiguration];
 1004|      0|    [FIRAuthBackend resetPassword:request callback:^(FIRResetPasswordResponse *_Nullable response,
 1005|      0|                                                     NSError *_Nullable error) {
 1006|      0|      if (completion) {
 1007|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1008|      0|          if (error) {
 1009|      0|            completion(error);
 1010|      0|            return;
 1011|      0|          }
 1012|      0|          completion(nil);
 1013|      0|        });
 1014|      0|      }
 1015|      0|    }];
 1016|      0|  });
 1017|      0|}
 1018|       |
 1019|      0|- (void)checkActionCode:(NSString *)code completion:(FIRCheckActionCodeCallBack)completion {
 1020|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^ {
 1021|      0|    FIRResetPasswordRequest *request =
 1022|      0|    [[FIRResetPasswordRequest alloc] initWithOobCode:code
 1023|      0|                                         newPassword:nil
 1024|      0|                                requestConfiguration:self->_requestConfiguration];
 1025|      0|    [FIRAuthBackend resetPassword:request callback:^(FIRResetPasswordResponse *_Nullable response,
 1026|      0|                                                     NSError *_Nullable error) {
 1027|      0|      if (completion) {
 1028|      0|        if (error) {
 1029|      0|          dispatch_async(dispatch_get_main_queue(), ^{
 1030|      0|            completion(nil, error);
 1031|      0|          });
 1032|      0|          return;
 1033|      0|        }
 1034|      0|        FIRActionCodeOperation operation =
 1035|      0|            [FIRActionCodeInfo actionCodeOperationForRequestType:response.requestType];
 1036|      0|        FIRActionCodeInfo *actionCodeInfo =
 1037|      0|            [[FIRActionCodeInfo alloc] initWithOperation:operation
 1038|      0|                                                   email:response.email
 1039|      0|                                                newEmail:response.verifiedEmail];
 1040|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1041|      0|          completion(actionCodeInfo, nil);
 1042|      0|        });
 1043|      0|      }
 1044|      0|    }];
 1045|      0|  });
 1046|      0|}
 1047|       |
 1048|       |- (void)verifyPasswordResetCode:(NSString *)code
 1049|      0|                     completion:(FIRVerifyPasswordResetCodeCallback)completion {
 1050|      0|  [self checkActionCode:code completion:^(FIRActionCodeInfo *_Nullable info,
 1051|      0|                                          NSError *_Nullable error) {
 1052|      0|    if (completion) {
 1053|      0|      if (error) {
 1054|      0|        completion(nil, error);
 1055|      0|        return;
 1056|      0|      }
 1057|      0|      completion([info dataForKey:FIRActionCodeEmailKey], nil);
 1058|      0|    }
 1059|      0|  }];
 1060|      0|}
 1061|       |
 1062|      0|- (void)applyActionCode:(NSString *)code completion:(FIRApplyActionCodeCallback)completion {
 1063|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^ {
 1064|      0|    FIRSetAccountInfoRequest *request =
 1065|      0|        [[FIRSetAccountInfoRequest alloc] initWithRequestConfiguration:self->_requestConfiguration];
 1066|      0|    request.OOBCode = code;
 1067|      0|    [FIRAuthBackend setAccountInfo:request callback:^(FIRSetAccountInfoResponse *_Nullable response,
 1068|      0|                                                      NSError *_Nullable error) {
 1069|      0|      if (completion) {
 1070|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1071|      0|          completion(error);
 1072|      0|        });
 1073|      0|      }
 1074|      0|    }];
 1075|      0|  });
 1076|      0|}
 1077|       |
 1078|       |- (void)sendPasswordResetWithEmail:(NSString *)email
 1079|      0|                        completion:(nullable FIRSendPasswordResetCallback)completion {
 1080|      0|  [self sendPasswordResetWithNullableActionCodeSettings:nil email:email completion:completion];
 1081|      0|}
 1082|       |
 1083|       |- (void)sendPasswordResetWithEmail:(NSString *)email
 1084|       |                actionCodeSettings:(FIRActionCodeSettings *)actionCodeSettings
 1085|      0|                        completion:(nullable FIRSendPasswordResetCallback)completion {
 1086|      0|  [self sendPasswordResetWithNullableActionCodeSettings:actionCodeSettings
 1087|      0|                                                  email:email
 1088|      0|                                             completion:completion];
 1089|      0|}
 1090|       |
 1091|       |/** @fn sendPasswordResetWithNullableActionCodeSettings:actionCodeSetting:email:completion:
 1092|       |    @brief Initiates a password reset for the given email address and @FIRActionCodeSettings object.
 1093|       |
 1094|       |    @param actionCodeSettings Optionally, An @c FIRActionCodeSettings object containing settings
 1095|       |        related to the handling action codes.
 1096|       |    @param email The email address of the user.
 1097|       |    @param completion Optionally; a block which is invoked when the request finishes. Invoked
 1098|       |        asynchronously on the main thread in the future.
 1099|       | */
 1100|       |- (void)sendPasswordResetWithNullableActionCodeSettings:(nullable FIRActionCodeSettings *)
 1101|       |                                                        actionCodeSettings
 1102|       |                                                  email:(NSString *)email
 1103|       |                                             completion:(nullable FIRSendPasswordResetCallback)
 1104|      0|                                                        completion {
 1105|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1106|      0|    if (!email) {
 1107|      0|      [FIRAuthExceptionUtils raiseInvalidParameterExceptionWithReason:
 1108|      0|          kMissingEmailInvalidParameterExceptionReason];
 1109|      0|      return;
 1110|      0|    }
 1111|      0|    FIRGetOOBConfirmationCodeRequest *request =
 1112|      0|        [FIRGetOOBConfirmationCodeRequest passwordResetRequestWithEmail:email
 1113|      0|                                                     actionCodeSettings:actionCodeSettings
 1114|      0|                                                   requestConfiguration:self->_requestConfiguration
 1115|      0|        ];
 1116|      0|    [FIRAuthBackend getOOBConfirmationCode:request
 1117|      0|                                  callback:^(FIRGetOOBConfirmationCodeResponse *_Nullable response,
 1118|      0|                                             NSError *_Nullable error) {
 1119|      0|      if (completion) {
 1120|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1121|      0|          completion(error);
 1122|      0|        });
 1123|      0|      }
 1124|      0|    }];
 1125|      0|  });
 1126|      0|}
 1127|       |
 1128|       |- (void)sendSignInLinkToEmail:(nonnull NSString *)email
 1129|       |           actionCodeSettings:(nonnull FIRActionCodeSettings *)actionCodeSettings
 1130|      0|                   completion:(nullable FIRSendSignInLinkToEmailCallback)completion {
 1131|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1132|      0|    if (!email) {
 1133|      0|      [FIRAuthExceptionUtils raiseInvalidParameterExceptionWithReason:
 1134|      0|          kMissingEmailInvalidParameterExceptionReason];
 1135|      0|    }
 1136|      0|
 1137|      0|    if (!actionCodeSettings.handleCodeInApp) {
 1138|      0|      [FIRAuthExceptionUtils raiseInvalidParameterExceptionWithReason:
 1139|      0|          kHandleCodeInAppFalseExceptionReason];
 1140|      0|    }
 1141|      0|    FIRGetOOBConfirmationCodeRequest *request =
 1142|      0|        [FIRGetOOBConfirmationCodeRequest signInWithEmailLinkRequest:email
 1143|      0|                                                  actionCodeSettings:actionCodeSettings
 1144|      0|                                                requestConfiguration:self->_requestConfiguration];
 1145|      0|    [FIRAuthBackend getOOBConfirmationCode:request
 1146|      0|                                  callback:^(FIRGetOOBConfirmationCodeResponse *_Nullable response,
 1147|      0|                                             NSError *_Nullable error) {
 1148|      0|      if (completion) {
 1149|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1150|      0|          completion(error);
 1151|      0|        });
 1152|      0|      }
 1153|      0|    }];
 1154|      0|  });
 1155|      0|}
 1156|       |
 1157|      0|- (void)updateCurrentUser:(FIRUser *)user completion:(nullable FIRUserUpdateCallback)completion {
 1158|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1159|      0|    if (!user) {
 1160|      0|      if (completion) {
 1161|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1162|      0|          completion([FIRAuthErrorUtils nullUserErrorWithMessage:nil]);
 1163|      0|        });
 1164|      0|      }
 1165|      0|      return;
 1166|      0|    }
 1167|      0|    void (^updateUserBlock)(FIRUser *user) = ^(FIRUser *user) {
 1168|      0|      NSError *error;
 1169|      0|      [self updateCurrentUser:user byForce:YES savingToDisk:YES error:(&error)];
 1170|      0|      if (error) {
 1171|      0|        if (completion) {
 1172|      0|          dispatch_async(dispatch_get_main_queue(), ^{
 1173|      0|            completion(error);
 1174|      0|          });
 1175|      0|        }
 1176|      0|        return;
 1177|      0|      } if (completion) {
 1178|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1179|      0|          completion(nil);
 1180|      0|        });
 1181|      0|      }
 1182|      0|    };
 1183|      0|    if (![user.requestConfiguration.APIKey isEqualToString:self->_requestConfiguration.APIKey]) {
 1184|      0|      // If the API keys are different, then we need to confirm that the user belongs to the same
 1185|      0|      // project before proceeding.
 1186|      0|      user.requestConfiguration = self->_requestConfiguration;
 1187|      0|      [user reloadWithCompletion:^(NSError *_Nullable error) {
 1188|      0|        if (error) {
 1189|      0|          if (completion) {
 1190|      0|            dispatch_async(dispatch_get_main_queue(), ^{
 1191|      0|              completion(error);
 1192|      0|            });
 1193|      0|          }
 1194|      0|          return;
 1195|      0|        }
 1196|      0|        updateUserBlock(user);
 1197|      0|      }];
 1198|      0|    } else {
 1199|      0|      updateUserBlock(user);
 1200|      0|    }
 1201|      0|  });
 1202|      0|}
 1203|       |
 1204|      0|- (BOOL)signOut:(NSError *_Nullable __autoreleasing *_Nullable)error {
 1205|      0|  __block BOOL result = YES;
 1206|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1207|      0|    if (!self->_currentUser) {
 1208|      0|      return;
 1209|      0|    }
 1210|      0|    result = [self updateCurrentUser:nil byForce:NO savingToDisk:YES error:error];
 1211|      0|  });
 1212|      0|  return result;
 1213|      0|}
 1214|       |
 1215|      0|- (BOOL)signOutByForceWithUserID:(NSString *)userID error:(NSError *_Nullable *_Nullable)error {
 1216|      0|  if (_currentUser.uid != userID) {
 1217|      0|    return YES;
 1218|      0|  }
 1219|      0|  return [self updateCurrentUser:nil byForce:YES savingToDisk:YES error:error];
 1220|      0|}
 1221|       |
 1222|      0|- (BOOL)isSignInWithEmailLink:(NSString *)link {
 1223|      0|  if (link.length == 0) {
 1224|      0|    return NO;
 1225|      0|  }
 1226|      0|  NSDictionary<NSString *, NSString *> *queryItems = FIRAuthParseURL(link);
 1227|      0|  if (![queryItems count]) {
 1228|      0|    NSURLComponents *urlComponents = [NSURLComponents componentsWithString:link];
 1229|      0|    if (!urlComponents.query) {
 1230|      0|      return NO;
 1231|      0|    }
 1232|      0|    queryItems = FIRAuthParseURL(urlComponents.query);
 1233|      0|  }
 1234|      0|
 1235|      0|  if (![queryItems count]) {
 1236|      0|    return NO;
 1237|      0|  }
 1238|      0|
 1239|      0|  NSString *actionCode = queryItems[@"oobCode"];
 1240|      0|  NSString *mode = queryItems[@"mode"];
 1241|      0|
 1242|      0|  if (actionCode && [mode isEqualToString:@"signIn"]) {
 1243|      0|    return YES;
 1244|      0|  }
 1245|      0|  return NO;
 1246|      0|}
 1247|       |
 1248|       |/** @fn FIRAuthParseURL:NSString
 1249|       |    @brief Parses an incoming URL into all available query items.
 1250|       |    @param urlString The url to be parsed.
 1251|       |    @return A dictionary of available query items in the target URL.
 1252|       | */
 1253|      0|static NSDictionary<NSString *, NSString *> *FIRAuthParseURL(NSString *urlString) {
 1254|      0|  NSString *linkURL = [NSURLComponents componentsWithString:urlString].query;
 1255|      0|  if (!linkURL) {
 1256|      0|    return @{};
 1257|      0|  }
 1258|      0|  NSArray<NSString *> *URLComponents = [linkURL componentsSeparatedByString:@"&"];
 1259|      0|  NSMutableDictionary<NSString *, NSString *> *queryItems =
 1260|      0|      [[NSMutableDictionary alloc] initWithCapacity:URLComponents.count];
 1261|      0|  for (NSString *component in URLComponents) {
 1262|      0|    NSRange equalRange = [component rangeOfString:@"="];
 1263|      0|    if (equalRange.location != NSNotFound) {
 1264|      0|      NSString *queryItemKey =
 1265|      0|          [[component substringToIndex:equalRange.location] stringByRemovingPercentEncoding];
 1266|      0|      NSString *queryItemValue =
 1267|      0|          [[component substringFromIndex:equalRange.location + 1] stringByRemovingPercentEncoding];
 1268|      0|      if (queryItemKey && queryItemValue) {
 1269|      0|        queryItems[queryItemKey] = queryItemValue;
 1270|      0|      }
 1271|      0|    }
 1272|      0|  }
 1273|      0|  return queryItems;
 1274|      0|}
 1275|       |
 1276|       |- (FIRAuthStateDidChangeListenerHandle)addAuthStateDidChangeListener:
 1277|      0|    (FIRAuthStateDidChangeListenerBlock)listener {
 1278|      0|  __block BOOL firstInvocation = YES;
 1279|      0|  __block NSString *previousUserID;
 1280|      0|  return [self addIDTokenDidChangeListener:^(FIRAuth *_Nonnull auth, FIRUser *_Nullable user) {
 1281|      0|    BOOL shouldCallListener = firstInvocation ||
 1282|      0|         !(previousUserID == user.uid || [previousUserID isEqualToString:user.uid]);
 1283|      0|    firstInvocation = NO;
 1284|      0|    previousUserID = [user.uid copy];
 1285|      0|    if (shouldCallListener) {
 1286|      0|      listener(auth, user);
 1287|      0|    }
 1288|      0|  }];
 1289|      0|}
 1290|       |
 1291|      0|- (void)removeAuthStateDidChangeListener:(FIRAuthStateDidChangeListenerHandle)listenerHandle {
 1292|      0|  [self removeIDTokenDidChangeListener:listenerHandle];
 1293|      0|}
 1294|       |
 1295|       |- (FIRIDTokenDidChangeListenerHandle)addIDTokenDidChangeListener:
 1296|      0|    (FIRIDTokenDidChangeListenerBlock)listener {
 1297|      0|  if (!listener) {
 1298|      0|    [NSException raise:NSInvalidArgumentException format:@"listener must not be nil."];
 1299|      0|    return nil;
 1300|      0|  }
 1301|      0|  FIRAuthStateDidChangeListenerHandle handle;
 1302|      0|  NSNotificationCenter *notifications = [NSNotificationCenter defaultCenter];
 1303|      0|  handle = [notifications addObserverForName:FIRAuthStateDidChangeNotification
 1304|      0|                                      object:self
 1305|      0|                                       queue:[NSOperationQueue mainQueue]
 1306|      0|                                  usingBlock:^(NSNotification *_Nonnull notification) {
 1307|      0|    FIRAuth *auth = notification.object;
 1308|      0|    listener(auth, auth.currentUser);
 1309|      0|  }];
 1310|      0|  @synchronized (self) {
 1311|      0|    [_listenerHandles addObject:handle];
 1312|      0|  }
 1313|      0|  dispatch_async(dispatch_get_main_queue(), ^{
 1314|      0|    listener(self, self->_currentUser);
 1315|      0|  });
 1316|      0|  return handle;
 1317|      0|}
 1318|       |
 1319|      0|- (void)removeIDTokenDidChangeListener:(FIRIDTokenDidChangeListenerHandle)listenerHandle {
 1320|      0|  [[NSNotificationCenter defaultCenter] removeObserver:listenerHandle];
 1321|      0|  @synchronized (self) {
 1322|      0|    [_listenerHandles removeObject:listenerHandle];
 1323|      0|  }
 1324|      0|}
 1325|       |
 1326|      0|- (void)useAppLanguage {
 1327|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1328|      0|    self->_requestConfiguration.languageCode =
 1329|      0|        [NSBundle mainBundle].preferredLocalizations.firstObject;
 1330|      0|  });
 1331|      0|}
 1332|       |
 1333|      0|- (nullable NSString *)languageCode {
 1334|      0|  return _requestConfiguration.languageCode;
 1335|      0|}
 1336|       |
 1337|      0|- (void)setLanguageCode:(nullable NSString *)languageCode {
 1338|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1339|      0|    self->_requestConfiguration.languageCode = [languageCode copy];
 1340|      0|  });
 1341|      0|}
 1342|       |
 1343|      0|- (NSString *)additionalFrameworkMarker {
 1344|      0|  return self->_requestConfiguration.additionalFrameworkMarker;
 1345|      0|}
 1346|       |
 1347|      0|- (void)setAdditionalFrameworkMarker:(NSString *)additionalFrameworkMarker {
 1348|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1349|      0|    self->_requestConfiguration.additionalFrameworkMarker = [additionalFrameworkMarker copy];
 1350|      0|  });
 1351|      0|}
 1352|       |
 1353|       |#if TARGET_OS_IOS
 1354|      0|- (NSData *)APNSToken {
 1355|      0|  __block NSData *result = nil;
 1356|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1357|      0|    result = self->_tokenManager.token.data;
 1358|      0|  });
 1359|      0|  return result;
 1360|      0|}
 1361|       |
 1362|      0|- (void)setAPNSToken:(NSData *)APNSToken {
 1363|      0|  [self setAPNSToken:APNSToken type:FIRAuthAPNSTokenTypeUnknown];
 1364|      0|}
 1365|       |
 1366|      0|- (void)setAPNSToken:(NSData *)token type:(FIRAuthAPNSTokenType)type {
 1367|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1368|      0|    self->_tokenManager.token = [[FIRAuthAPNSToken alloc] initWithData:token type:type];
 1369|      0|  });
 1370|      0|}
 1371|       |
 1372|      0|- (void)handleAPNSTokenError:(NSError *)error {
 1373|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1374|      0|    [self->_tokenManager cancelWithError:error];
 1375|      0|  });
 1376|      0|}
 1377|       |
 1378|      0|- (BOOL)canHandleNotification:(NSDictionary *)userInfo {
 1379|      0|  __block BOOL result = NO;
 1380|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1381|      0|    result = [self->_notificationManager canHandleNotification:userInfo];
 1382|      0|  });
 1383|      0|  return result;
 1384|      0|}
 1385|       |
 1386|      0|- (BOOL)canHandleURL:(NSURL *)URL {
 1387|      0|  __block BOOL result = NO;
 1388|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1389|      0|    result = [self->_authURLPresenter canHandleURL:URL];
 1390|      0|  });
 1391|      0|  return result;
 1392|      0|}
 1393|       |#endif
 1394|       |
 1395|       |#pragma mark - Internal Methods
 1396|       |
 1397|       |#if TARGET_OS_IOS
 1398|       |/** @fn signInWithPhoneCredential:callback:
 1399|       |    @brief Signs in using a phone credential.
 1400|       |    @param credential The Phone Auth credential used to sign in.
 1401|       |    @param operation The type of operation for which this sign-in attempt is initiated.
 1402|       |    @param callback A block which is invoked when the sign in finishes (or is cancelled.) Invoked
 1403|       |        asynchronously on the global auth work queue in the future.
 1404|       | */
 1405|       |- (void)signInWithPhoneCredential:(FIRPhoneAuthCredential *)credential
 1406|       |                        operation:(FIRAuthOperationType)operation
 1407|      0|                         callback:(FIRVerifyPhoneNumberResponseCallback)callback {
 1408|      0|  if (credential.temporaryProof.length && credential.phoneNumber.length) {
 1409|      0|    FIRVerifyPhoneNumberRequest *request =
 1410|      0|      [[FIRVerifyPhoneNumberRequest alloc] initWithTemporaryProof:credential.temporaryProof
 1411|      0|                                                      phoneNumber:credential.phoneNumber
 1412|      0|                                                        operation:operation
 1413|      0|                                             requestConfiguration:_requestConfiguration];
 1414|      0|    [FIRAuthBackend verifyPhoneNumber:request callback:callback];
 1415|      0|    return;
 1416|      0|  }
 1417|      0|
 1418|      0|  if (!credential.verificationID.length) {
 1419|      0|    callback(nil, [FIRAuthErrorUtils missingVerificationIDErrorWithMessage:nil]);
 1420|      0|    return;
 1421|      0|  }
 1422|      0|  if (!credential.verificationCode.length) {
 1423|      0|    callback(nil, [FIRAuthErrorUtils missingVerificationCodeErrorWithMessage:nil]);
 1424|      0|    return;
 1425|      0|  }
 1426|      0|  FIRVerifyPhoneNumberRequest *request =
 1427|      0|      [[FIRVerifyPhoneNumberRequest alloc]initWithVerificationID:credential.verificationID
 1428|      0|                                                verificationCode:credential.verificationCode
 1429|      0|                                                       operation:operation
 1430|      0|                                            requestConfiguration:_requestConfiguration];
 1431|      0|  [FIRAuthBackend verifyPhoneNumber:request callback:callback];
 1432|      0|}
 1433|       |
 1434|       |#endif
 1435|       |
 1436|       |/** @fn internalSignInAndRetrieveDataWithCustomToken:completion:
 1437|       |    @brief Signs in a Firebase user given a custom token.
 1438|       |    @param token A self-signed custom auth token.
 1439|       |    @param completion A block which is invoked when the custom token sign in request completes.
 1440|       | */
 1441|       |- (void)internalSignInAndRetrieveDataWithCustomToken:(NSString *)token
 1442|       |                                          completion:(nullable FIRAuthDataResultCallback)
 1443|      0|                                              completion {
 1444|      0|  FIRVerifyCustomTokenRequest *request =
 1445|      0|    [[FIRVerifyCustomTokenRequest alloc] initWithToken:token
 1446|      0|                                  requestConfiguration:_requestConfiguration];
 1447|      0|  [FIRAuthBackend verifyCustomToken:request
 1448|      0|                           callback:^(FIRVerifyCustomTokenResponse *_Nullable response,
 1449|      0|                                      NSError *_Nullable error) {
 1450|      0|    if (error) {
 1451|      0|      if (completion) {
 1452|      0|        completion(nil, error);
 1453|      0|        return;
 1454|      0|      }
 1455|      0|    }
 1456|      0|    [self completeSignInWithAccessToken:response.IDToken
 1457|      0|              accessTokenExpirationDate:response.approximateExpirationDate
 1458|      0|                           refreshToken:response.refreshToken
 1459|      0|                              anonymous:NO
 1460|      0|                               callback:^(FIRUser *_Nullable user,
 1461|      0|                                          NSError *_Nullable error) {
 1462|      0|      if (error) {
 1463|      0|        if (completion) {
 1464|      0|          completion(nil, error);
 1465|      0|        }
 1466|      0|        return;
 1467|      0|      }
 1468|      0|      FIRAdditionalUserInfo *additonalUserInfo =
 1469|      0|          [[FIRAdditionalUserInfo alloc] initWithProviderID:nil
 1470|      0|                                                   profile:nil
 1471|      0|                                                  username:nil
 1472|      0|                                                 isNewUser:response.isNewUser];
 1473|      0|      FIRAuthDataResult *result =
 1474|      0|          [[FIRAuthDataResult alloc] initWithUser:user additionalUserInfo:additonalUserInfo];
 1475|      0|      if (completion) {
 1476|      0|        completion(result, nil);
 1477|      0|      }
 1478|      0|    }];
 1479|      0|  }];
 1480|      0|}
 1481|       |
 1482|       |/** @fn internalCreateUserWithEmail:password:completion:
 1483|       |    @brief Makes a backend request attempting to create a new Firebase user given an email address
 1484|       |        and password.
 1485|       |    @param email The email address used to create the new Firebase user.
 1486|       |    @param password The password used to create the new Firebase user.
 1487|       |    @param completion Optionally; a block which is invoked when the request finishes.
 1488|       | */
 1489|       |- (void)internalCreateUserWithEmail:(NSString *)email
 1490|       |                           password:(NSString *)password
 1491|      0|                         completion:(nullable FIRSignupNewUserCallback)completion {
 1492|      0|  FIRSignUpNewUserRequest *request =
 1493|      0|      [[FIRSignUpNewUserRequest alloc] initWithEmail:email
 1494|      0|                                            password:password
 1495|      0|                                         displayName:nil
 1496|      0|                                requestConfiguration:_requestConfiguration];
 1497|      0|  if (![request.password length]) {
 1498|      0|    completion(nil, [FIRAuthErrorUtils
 1499|      0|        weakPasswordErrorWithServerResponseReason:kMissingPasswordReason]);
 1500|      0|    return;
 1501|      0|  }
 1502|      0|  if (![request.email length]) {
 1503|      0|    completion(nil, [FIRAuthErrorUtils missingEmailErrorWithMessage:nil]);
 1504|      0|    return;
 1505|      0|  }
 1506|      0|  [FIRAuthBackend signUpNewUser:request callback:completion];
 1507|      0|}
 1508|       |
 1509|       |/** @fn internalSignInAnonymouslyWithCompletion:
 1510|       |    @param completion A block which is invoked when the anonymous sign in request completes.
 1511|       | */
 1512|      0|- (void)internalSignInAnonymouslyWithCompletion:(FIRSignupNewUserCallback)completion {
 1513|      0|  FIRSignUpNewUserRequest *request =
 1514|      0|      [[FIRSignUpNewUserRequest alloc]initWithRequestConfiguration:_requestConfiguration];
 1515|      0|  [FIRAuthBackend signUpNewUser:request
 1516|      0|                       callback:completion];
 1517|      0|}
 1518|       |
 1519|       |/** @fn possiblyPostAuthStateChangeNotification
 1520|       |    @brief Posts the auth state change notificaton if current user's token has been changed.
 1521|       | */
 1522|      1|- (void)possiblyPostAuthStateChangeNotification {
 1523|      1|  NSString *token = _currentUser.rawAccessToken;
 1524|      1|  if (_lastNotifiedUserToken == token ||
 1525|      1|      (token != nil && [_lastNotifiedUserToken isEqualToString:token])) {
 1526|      1|    return;
 1527|      1|  }
 1528|      0|  _lastNotifiedUserToken = token;
 1529|      0|  if (_autoRefreshTokens) {
 1530|      0|    // Shedule new refresh task after successful attempt.
 1531|      0|    [self scheduleAutoTokenRefresh];
 1532|      0|  }
 1533|      0|  NSMutableDictionary *internalNotificationParameters = [NSMutableDictionary dictionary];
 1534|      0|  if (self.app) {
 1535|      0|    internalNotificationParameters[FIRAuthStateDidChangeInternalNotificationAppKey] = self.app;
 1536|      0|  }
 1537|      0|  if (token.length) {
 1538|      0|    internalNotificationParameters[FIRAuthStateDidChangeInternalNotificationTokenKey] = token;
 1539|      0|  }
 1540|      0|  internalNotificationParameters[FIRAuthStateDidChangeInternalNotificationUIDKey] = _currentUser.uid;
 1541|      0|  NSNotificationCenter *notifications = [NSNotificationCenter defaultCenter];
 1542|      0|  dispatch_async(dispatch_get_main_queue(), ^{
 1543|      0|    [notifications postNotificationName:FIRAuthStateDidChangeInternalNotification
 1544|      0|                                 object:self
 1545|      0|                               userInfo:internalNotificationParameters];
 1546|      0|    [notifications postNotificationName:FIRAuthStateDidChangeNotification
 1547|      0|                                 object:self];
 1548|      0|  });
 1549|      0|}
 1550|       |
 1551|      0|- (BOOL)updateKeychainWithUser:(FIRUser *)user error:(NSError *_Nullable *_Nullable)error {
 1552|      0|  if (user != _currentUser) {
 1553|      0|    // No-op if the user is no longer signed in. This is not considered an error as we don't check
 1554|      0|    // whether the user is still current on other callbacks of user operations either.
 1555|      0|    return YES;
 1556|      0|  }
 1557|      0|  if ([self saveUser:user error:error]) {
 1558|      0|    [self possiblyPostAuthStateChangeNotification];
 1559|      0|    return YES;
 1560|      0|  }
 1561|      0|  return NO;
 1562|      0|}
 1563|       |
 1564|       |/** @fn setKeychainServiceNameForApp
 1565|       |    @brief Sets the keychain service name global data for the particular app.
 1566|       |    @param app The Firebase app to set keychain service name for.
 1567|       | */
 1568|      1|+ (void)setKeychainServiceNameForApp:(FIRApp *)app {
 1569|      1|  @synchronized (self) {
 1570|      1|    gKeychainServiceNameForAppName[app.name] =
 1571|      1|        [@"firebase_auth_" stringByAppendingString:app.options.googleAppID];
 1572|      1|  }
 1573|      1|}
 1574|       |
 1575|       |/** @fn keychainServiceNameForAppName:
 1576|       |    @brief Gets the keychain service name global data for the particular app by name.
 1577|       |    @param appName The name of the Firebase app to get keychain service name for.
 1578|       | */
 1579|      1|+ (NSString *)keychainServiceNameForAppName:(NSString *)appName {
 1580|      1|  @synchronized (self) {
 1581|      1|    return gKeychainServiceNameForAppName[appName];
 1582|      1|  }
 1583|      1|}
 1584|       |
 1585|       |/** @fn deleteKeychainServiceNameForAppName:
 1586|       |    @brief Deletes the keychain service name global data for the particular app by name.
 1587|       |    @param appName The name of the Firebase app to delete keychain service name for.
 1588|       | */
 1589|      0|+ (void)deleteKeychainServiceNameForAppName:(NSString *)appName {
 1590|      0|  @synchronized (self) {
 1591|      0|    [gKeychainServiceNameForAppName removeObjectForKey:appName];
 1592|      0|  }
 1593|      0|}
 1594|       |
 1595|       |/** @fn scheduleAutoTokenRefreshWithDelay:
 1596|       |    @brief Schedules a task to automatically refresh tokens on the current user. The token refresh
 1597|       |        is scheduled 5 minutes before the  scheduled expiration time.
 1598|       |    @remarks If the token expires in less than 5 minutes, schedule the token refresh immediately.
 1599|       | */
 1600|      0|- (void)scheduleAutoTokenRefresh {
 1601|      0|  NSTimeInterval tokenExpirationInterval =
 1602|      0|      [_currentUser.accessTokenExpirationDate timeIntervalSinceNow] - kTokenRefreshHeadStart;
 1603|      0|  [self scheduleAutoTokenRefreshWithDelay:MAX(tokenExpirationInterval, 0) retry:NO];
 1604|      0|}
 1605|       |
 1606|       |/** @fn scheduleAutoTokenRefreshWithDelay:
 1607|       |    @brief Schedules a task to automatically refresh tokens on the current user.
 1608|       |    @param delay The delay in seconds after which the token refresh task should be scheduled to be
 1609|       |        executed.
 1610|       |    @param retry Flag to determine whether the invocation is a retry attempt or not.
 1611|       | */
 1612|      0|- (void)scheduleAutoTokenRefreshWithDelay:(NSTimeInterval)delay retry:(BOOL)retry {
 1613|      0|  NSString *accessToken = _currentUser.rawAccessToken;
 1614|      0|  if (!accessToken) {
 1615|      0|    return;
 1616|      0|  }
 1617|      0|  if (retry) {
 1618|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000003",
 1619|      0|               @"Token auto-refresh re-scheduled in %02d:%02d "
 1620|      0|               @"because of error on previous refresh attempt.",
 1621|      0|               (int)ceil(delay) / 60, (int)ceil(delay) % 60);
 1622|      0|  } else {
 1623|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000004",
 1624|      0|               @"Token auto-refresh scheduled in %02d:%02d for the new token.",
 1625|      0|               (int)ceil(delay) / 60, (int)ceil(delay) % 60);
 1626|      0|  }
 1627|      0|  _autoRefreshScheduled = YES;
 1628|      0|  __weak FIRAuth *weakSelf = self;
 1629|      0|  [[FIRAuthDispatcher sharedInstance] dispatchAfterDelay:delay
 1630|      0|                                                   queue:FIRAuthGlobalWorkQueue()
 1631|      0|                                                    task:^(void) {
 1632|      0|    FIRAuth *strongSelf = weakSelf;
 1633|      0|    if (!strongSelf) {
 1634|      0|      return;
 1635|      0|    }
 1636|      0|    if (![strongSelf->_currentUser.rawAccessToken isEqualToString:accessToken]) {
 1637|      0|      // Another auto refresh must have been scheduled, so keep _autoRefreshScheduled unchanged.
 1638|      0|      return;
 1639|      0|    }
 1640|      0|    strongSelf->_autoRefreshScheduled = NO;
 1641|      0|    if (strongSelf->_isAppInBackground) {
 1642|      0|      return;
 1643|      0|    }
 1644|      0|    NSString *uid = strongSelf->_currentUser.uid;
 1645|      0|    [strongSelf->_currentUser internalGetTokenForcingRefresh:YES
 1646|      0|                                                    callback:^(NSString *_Nullable token,
 1647|      0|                                                               NSError *_Nullable error) {
 1648|      0|      if (![strongSelf->_currentUser.uid isEqualToString:uid]) {
 1649|      0|        return;
 1650|      0|      }
 1651|      0|      if (error) {
 1652|      0|        // Kicks off exponential back off logic to retry failed attempt. Starts with one minute
 1653|      0|        // delay (60 seconds) if this is the first failed attempt.
 1654|      0|        NSTimeInterval rescheduleDelay;
 1655|      0|        if (retry) {
 1656|      0|          rescheduleDelay = MIN(delay * 2, kMaxWaitTimeForBackoff);
 1657|      0|        } else {
 1658|      0|          rescheduleDelay = 60;
 1659|      0|        }
 1660|      0|        [strongSelf scheduleAutoTokenRefreshWithDelay:rescheduleDelay retry:YES];
 1661|      0|      }
 1662|      0|    }];
 1663|      0|  }];
 1664|      0|}
 1665|       |
 1666|       |#pragma mark -
 1667|       |
 1668|       |/** @fn completeSignInWithTokenService:callback:
 1669|       |    @brief Completes a sign-in flow once we have access and refresh tokens for the user.
 1670|       |    @param accessToken The STS access token.
 1671|       |    @param accessTokenExpirationDate The approximate expiration date of the access token.
 1672|       |    @param refreshToken The STS refresh token.
 1673|       |    @param anonymous Whether or not the user is anonymous.
 1674|       |    @param callback Called when the user has been signed in or when an error occurred. Invoked
 1675|       |        asynchronously on the global auth work queue in the future.
 1676|       | */
 1677|       |- (void)completeSignInWithAccessToken:(NSString *)accessToken
 1678|       |            accessTokenExpirationDate:(NSDate *)accessTokenExpirationDate
 1679|       |                         refreshToken:(NSString *)refreshToken
 1680|       |                            anonymous:(BOOL)anonymous
 1681|      0|                             callback:(FIRAuthResultCallback)callback {
 1682|      0|  [FIRUser retrieveUserWithAuth:self
 1683|      0|                    accessToken:accessToken
 1684|      0|      accessTokenExpirationDate:accessTokenExpirationDate
 1685|      0|                   refreshToken:refreshToken
 1686|      0|                      anonymous:anonymous
 1687|      0|                       callback:callback];
 1688|      0|}
 1689|       |
 1690|       |/** @fn signInFlowAuthResultCallbackByDecoratingCallback:
 1691|       |    @brief Creates a FIRAuthResultCallback block which wraps another FIRAuthResultCallback; trying
 1692|       |        to update the current user before forwarding it's invocations along to a subject block
 1693|       |    @param callback Called when the user has been updated or when an error has occurred. Invoked
 1694|       |        asynchronously on the main thread in the future.
 1695|       |    @return Returns a block that updates the current user.
 1696|       |    @remarks Typically invoked as part of the complete sign-in flow. For any other uses please
 1697|       |        consider alternative ways of updating the current user.
 1698|       |*/
 1699|       |- (FIRAuthResultCallback)signInFlowAuthResultCallbackByDecoratingCallback:
 1700|      0|    (nullable FIRAuthResultCallback)callback {
 1701|      0|  return ^(FIRUser *_Nullable user, NSError *_Nullable error) {
 1702|      0|    if (error) {
 1703|      0|      if (callback) {
 1704|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1705|      0|          callback(nil, error);
 1706|      0|        });
 1707|      0|      }
 1708|      0|      return;
 1709|      0|    }
 1710|      0|    if (![self updateCurrentUser:user byForce:NO savingToDisk:YES error:&error]) {
 1711|      0|      if (callback) {
 1712|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1713|      0|          callback(nil, error);
 1714|      0|        });
 1715|      0|      }
 1716|      0|      return;
 1717|      0|    }
 1718|      0|    if (callback) {
 1719|      0|      dispatch_async(dispatch_get_main_queue(), ^{
 1720|      0|        callback(user, nil);
 1721|      0|      });
 1722|      0|    }
 1723|      0|  };
 1724|      0|}
 1725|       |
 1726|       |/** @fn signInFlowAuthDataResultCallbackByDecoratingCallback:
 1727|       |    @brief Creates a FIRAuthDataResultCallback block which wraps another FIRAuthDataResultCallback;
 1728|       |        trying to update the current user before forwarding it's invocations along to a subject
 1729|       |        block.
 1730|       |    @param callback Called when the user has been updated or when an error has occurred. Invoked
 1731|       |        asynchronously on the main thread in the future.
 1732|       |    @return Returns a block that updates the current user.
 1733|       |    @remarks Typically invoked as part of the complete sign-in flow. For any other uses please
 1734|       |        consider alternative ways of updating the current user.
 1735|       |*/
 1736|       |- (FIRAuthDataResultCallback)signInFlowAuthDataResultCallbackByDecoratingCallback:
 1737|      0|    (nullable FIRAuthDataResultCallback)callback {
 1738|      0|  return ^(FIRAuthDataResult *_Nullable authResult, NSError *_Nullable error) {
 1739|      0|    if (error) {
 1740|      0|      if (callback) {
 1741|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1742|      0|          callback(nil, error);
 1743|      0|        });
 1744|      0|      }
 1745|      0|      return;
 1746|      0|    }
 1747|      0|    if (![self updateCurrentUser:authResult.user byForce:NO savingToDisk:YES error:&error]) {
 1748|      0|      if (callback) {
 1749|      0|        dispatch_async(dispatch_get_main_queue(), ^{
 1750|      0|          callback(nil, error);
 1751|      0|        });
 1752|      0|      }
 1753|      0|      return;
 1754|      0|    }
 1755|      0|    if (callback) {
 1756|      0|      dispatch_async(dispatch_get_main_queue(), ^{
 1757|      0|        callback(authResult, nil);
 1758|      0|      });
 1759|      0|    }
 1760|      0|  };
 1761|      0|}
 1762|       |
 1763|       |#pragma mark - User-Related Methods
 1764|       |
 1765|       |/** @fn updateCurrentUser:savingToDisk:
 1766|       |    @brief Update the current user; initializing the user's internal properties correctly, and
 1767|       |        optionally saving the user to disk.
 1768|       |    @remarks This method is called during: sign in and sign out events, as well as during class
 1769|       |        initialization time. The only time the saveToDisk parameter should be set to NO is during
 1770|       |        class initialization time because the user was just read from disk.
 1771|       |    @param user The user to use as the current user (including nil, which is passed at sign out
 1772|       |        time.)
 1773|       |    @param saveToDisk Indicates the method should persist the user data to disk.
 1774|       | */
 1775|       |- (BOOL)updateCurrentUser:(FIRUser *)user
 1776|       |                  byForce:(BOOL)force
 1777|       |             savingToDisk:(BOOL)saveToDisk
 1778|      1|                    error:(NSError *_Nullable *_Nullable)error {
 1779|      1|  if (user == _currentUser) {
 1780|      1|    [self possiblyPostAuthStateChangeNotification];
 1781|      1|    return YES;
 1782|      1|  }
 1783|      0|  BOOL success = YES;
 1784|      0|  if (saveToDisk) {
 1785|      0|    success = [self saveUser:user error:error];
 1786|      0|  }
 1787|      0|  if (success || force) {
 1788|      0|    _currentUser = user;
 1789|      0|    [self possiblyPostAuthStateChangeNotification];
 1790|      0|  }
 1791|      0|  return success;
 1792|      0|}
 1793|       |
 1794|       |/** @fn saveUser:error:
 1795|       |    @brief Persists user.
 1796|       |    @param user The user to save.
 1797|       |    @param error Return value for any error which occurs.
 1798|       |    @return @YES on success, @NO otherwise.
 1799|       | */
 1800|       |- (BOOL)saveUser:(FIRUser *)user
 1801|      0|           error:(NSError *_Nullable *_Nullable)error {
 1802|      0|  BOOL success;
 1803|      0|  NSString *userKey = [NSString stringWithFormat:kUserKey, _firebaseAppName];
 1804|      0|
 1805|      0|  if (!user) {
 1806|      0|    success = [_keychain removeDataForKey:userKey error:error];
 1807|      0|  } else {
 1808|      0|    // Encode the user object.
 1809|      0|    NSMutableData *archiveData = [NSMutableData data];
 1810|      0|    NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:archiveData];
 1811|      0|    [archiver encodeObject:user forKey:userKey];
 1812|      0|    [archiver finishEncoding];
 1813|      0|
 1814|      0|    // Save the user object's encoded value.
 1815|      0|    success = [_keychain setData:archiveData forKey:userKey error:error];
 1816|      0|  }
 1817|      0|  return success;
 1818|      0|}
 1819|       |
 1820|       |/** @fn getUser:error:
 1821|       |    @brief Retrieves the saved user associated, if one exists, from the keychain.
 1822|       |    @param outUser An out parameter which is populated with the saved user, if one exists.
 1823|       |    @param error Return value for any error which occurs.
 1824|       |    @return YES if the operation was a success (irrespective of whether or not a saved user existed
 1825|       |        for the given @c firebaseAppId,) NO if an error occurred.
 1826|       | */
 1827|       |- (BOOL)getUser:(FIRUser *_Nullable *)outUser
 1828|      1|          error:(NSError *_Nullable *_Nullable)error {
 1829|      1|  NSString *userKey = [NSString stringWithFormat:kUserKey, _firebaseAppName];
 1830|      1|
 1831|      1|  NSError *keychainError;
 1832|      1|  NSData *encodedUserData = [_keychain dataForKey:userKey error:&keychainError];
 1833|      1|  if (keychainError) {
 1834|      0|    if (error) {
 1835|      0|      *error = keychainError;
 1836|      0|    }
 1837|      0|    return NO;
 1838|      0|  }
 1839|      1|  if (!encodedUserData) {
 1840|      1|    *outUser = nil;
 1841|      1|    return YES;
 1842|      1|  }
 1843|      0|  NSKeyedUnarchiver *unarchiver =
 1844|      0|      [[NSKeyedUnarchiver alloc] initForReadingWithData:encodedUserData];
 1845|      0|  FIRUser *user = [unarchiver decodeObjectOfClass:[FIRUser class] forKey:userKey];
 1846|      0|  user.auth = self;
 1847|      0|  *outUser = user;
 1848|      0|  return YES;
 1849|      0|}
 1850|       |
 1851|       |#pragma mark - Interoperability
 1852|       |
 1853|      1|+ (nonnull NSArray<FIRComponent *> *)componentsToRegister {
 1854|      1|  FIRComponentCreationBlock authCreationBlock =
 1855|      1|  ^id _Nullable(FIRComponentContainer *_Nonnull container, BOOL *_Nonnull isCacheable) {
 1856|      1|    *isCacheable = YES;
 1857|      1|    return [[FIRAuth alloc] initWithApp:container.app];
 1858|      1|  };
 1859|      1|  FIRComponent *authInterop = [FIRComponent componentWithProtocol:@protocol(FIRAuthInterop)
 1860|      1|                                                    creationBlock:authCreationBlock];
 1861|      1|  return @[authInterop];
 1862|      1|}
 1863|       |
 1864|       |#pragma mark - FIRCoreConfigurable
 1865|       |
 1866|      1|+ (void)configureWithApp:(nonnull FIRApp *)app {
 1867|      1|  // TODO: Evaluate what actually needs to be configured here instead of initializing a full
 1868|      1|  // instance.
 1869|      1|  // Ensures the @c FIRAuth instance for a given app gets loaded as soon as the app is ready.
 1870|      1|  [FIRAuth authWithApp:app];
 1871|      1|}
 1872|       |
 1873|       |#pragma mark - FIRComponentLifecycleMaintainer
 1874|       |
 1875|      0|- (void)appWillBeDeleted:(nonnull FIRApp *)app {
 1876|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1877|      0|    // This doesn't stop any request already issued, see b/27704535 .
 1878|      0|    NSString *keychainServiceName = [FIRAuth keychainServiceNameForAppName:app.name];
 1879|      0|    if (keychainServiceName) {
 1880|      0|      [[self class] deleteKeychainServiceNameForAppName:app.name];
 1881|      0|      FIRAuthKeychain *keychain = [[FIRAuthKeychain alloc] initWithService:keychainServiceName];
 1882|      0|      NSString *userKey = [NSString stringWithFormat:kUserKey, app.name];
 1883|      0|      [keychain removeDataForKey:userKey error:NULL];
 1884|      0|    }
 1885|      0|    dispatch_async(dispatch_get_main_queue(), ^{
 1886|      0|      // TODO: Move over to fire an event instead, once ready.
 1887|      0|      [[NSNotificationCenter defaultCenter] postNotificationName:FIRAuthStateDidChangeNotification
 1888|      0|                                                          object:nil];
 1889|      0|    });
 1890|      0|  });
 1891|      0|}
 1892|       |
 1893|       |#pragma mark - FIRAuthInterop
 1894|       |
 1895|      0|- (void)getTokenForcingRefresh:(BOOL)forceRefresh withCallback:(FIRTokenCallback)callback {
 1896|      0|  __weak FIRAuth *weakSelf = self;
 1897|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1898|      0|    FIRAuth *strongSelf = weakSelf;
 1899|      0|    // Enable token auto-refresh if not aleady enabled.
 1900|      0|    if (strongSelf && !strongSelf->_autoRefreshTokens) {
 1901|      0|      FIRLogInfo(kFIRLoggerAuth, @"I-AUT000002", @"Token auto-refresh enabled.");
 1902|      0|      strongSelf->_autoRefreshTokens = YES;
 1903|      0|      [strongSelf scheduleAutoTokenRefresh];
 1904|      0|
 1905|      0|#if TARGET_OS_IOS || TARGET_OS_TV // TODO: Is a similar mechanism needed on macOS?
 1906|      0|      strongSelf->_applicationDidBecomeActiveObserver = [[NSNotificationCenter defaultCenter]
 1907|      0|                                                         addObserverForName:UIApplicationDidBecomeActiveNotification
 1908|      0|                                                         object:nil
 1909|      0|                                                         queue:nil
 1910|      0|                                                         usingBlock:^(NSNotification *notification) {
 1911|      0|                                                           FIRAuth *strongSelf = weakSelf;
 1912|      0|                                                           if (strongSelf) {
 1913|      0|                                                             strongSelf->_isAppInBackground = NO;
 1914|      0|                                                             if (!strongSelf->_autoRefreshScheduled) {
 1915|      0|                                                               [weakSelf scheduleAutoTokenRefresh];
 1916|      0|                                                             }
 1917|      0|                                                           }
 1918|      0|                                                         }];
 1919|      0|      strongSelf->_applicationDidEnterBackgroundObserver = [[NSNotificationCenter defaultCenter]
 1920|      0|                                                            addObserverForName:UIApplicationDidEnterBackgroundNotification
 1921|      0|                                                            object:nil
 1922|      0|                                                            queue:nil
 1923|      0|                                                            usingBlock:^(NSNotification *notification) {
 1924|      0|                                                              FIRAuth *strongSelf = weakSelf;
 1925|      0|                                                              if (strongSelf) {
 1926|      0|                                                                strongSelf->_isAppInBackground = YES;
 1927|      0|                                                              }
 1928|      0|                                                            }];
 1929|      0|#endif
 1930|      0|    }
 1931|      0|    // Call back with 'nil' if there is no current user.
 1932|      0|    if (!strongSelf || !strongSelf->_currentUser) {
 1933|      0|      dispatch_async(dispatch_get_main_queue(), ^{
 1934|      0|        callback(nil, nil);
 1935|      0|      });
 1936|      0|      return;
 1937|      0|    }
 1938|      0|    // Call back with current user token.
 1939|      0|    [strongSelf->_currentUser internalGetTokenForcingRefresh:forceRefresh
 1940|      0|                                                    callback:^(NSString *_Nullable token,
 1941|      0|                                                               NSError *_Nullable error) {
 1942|      0|                                                      dispatch_async(dispatch_get_main_queue(), ^{
 1943|      0|                                                        callback(token, error);
 1944|      0|                                                      });
 1945|      0|                                                    }];
 1946|      0|  });
 1947|      0|}
 1948|       |
 1949|      0|- (nullable NSString *)getUserID {
 1950|      0|  return _currentUser.uid;
 1951|      0|}
 1952|       |
 1953|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthAPNSToken.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthAPNSToken.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRAuthAPNSToken {
   22|       |  /** @var _string
   23|       |      @brief The lazy-initialized string form of the token data.
   24|       |   */
   25|       |  NSString *_string;
   26|       |}
   27|       |
   28|      0|- (instancetype)initWithData:(NSData *)data type:(FIRAuthAPNSTokenType)type {
   29|      0|  self = [super init];
   30|      0|  if (self) {
   31|      0|    _data = [data copy];
   32|      0|    _type = type;
   33|      0|  }
   34|      0|  return self;
   35|      0|}
   36|       |
   37|      0|- (NSString *)string {
   38|      0|  if (!_string) {
   39|      0|    NSUInteger capacity = _data.length * 2;
   40|      0|    NSMutableString *tokenString = [NSMutableString stringWithCapacity:capacity];
   41|      0|    const unsigned char *tokenData = _data.bytes;
   42|      0|    for (int idx = 0; idx < _data.length; ++idx) {
   43|      0|      [tokenString appendFormat:@"%02X", (int)tokenData[idx]];
   44|      0|    }
   45|      0|    _string = tokenString;
   46|      0|  }
   47|      0|  return _string;
   48|      0|}
   49|       |
   50|       |@end
   51|       |
   52|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthAPNSTokenManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthAPNSTokenManager.h"
   18|       |
   19|       |#import <FirebaseCore/FIRLogger.h>
   20|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   21|       |
   22|       |#import "FIRAuthAPNSToken.h"
   23|       |#import "FIRAuthGlobalWorkQueue.h"
   24|       |
   25|       |NS_ASSUME_NONNULL_BEGIN
   26|       |
   27|       |/** @var kRegistrationTimeout
   28|       |    @brief Timeout for registration for remote notification.
   29|       |    @remarks Once we start to handle `application:didFailToRegisterForRemoteNotificationsWithError:`
   30|       |        we probably don't have to use timeout at all.
   31|       | */
   32|       |static const NSTimeInterval kRegistrationTimeout = 5;
   33|       |
   34|       |/** @var kLegacyRegistrationTimeout
   35|       |    @brief Timeout for registration for remote notification on iOS 7.
   36|       | */
   37|       |static const NSTimeInterval kLegacyRegistrationTimeout = 30;
   38|       |
   39|       |@implementation FIRAuthAPNSTokenManager {
   40|       |  /** @var _application
   41|       |      @brief The @c UIApplication to request the token from.
   42|       |   */
   43|       |  UIApplication *_application;
   44|       |
   45|       |  /** @var _pendingCallbacks
   46|       |      @brief The list of all pending callbacks for the APNs token.
   47|       |   */
   48|       |  NSMutableArray<FIRAuthAPNSTokenCallback> *_pendingCallbacks;
   49|       |}
   50|       |
   51|      1|- (instancetype)initWithApplication:(UIApplication *)application {
   52|      1|  self = [super init];
   53|      1|  if (self) {
   54|      1|    _application = application;
   55|      1|    _timeout = [_application respondsToSelector:@selector(registerForRemoteNotifications)] ?
   56|      1|        kRegistrationTimeout : kLegacyRegistrationTimeout;
   57|      1|  }
   58|      1|  return self;
   59|      1|}
   60|       |
   61|      0|- (void)getTokenWithCallback:(FIRAuthAPNSTokenCallback)callback {
   62|      0|  if (_token) {
   63|      0|    callback(_token, nil);
   64|      0|    return;
   65|      0|  }
   66|      0|  if (_pendingCallbacks) {
   67|      0|    [_pendingCallbacks addObject:callback];
   68|      0|    return;
   69|      0|  }
   70|      0|  _pendingCallbacks =
   71|      0|      [[NSMutableArray<FIRAuthAPNSTokenCallback> alloc] initWithObjects:callback, nil];
   72|      0|  dispatch_async(dispatch_get_main_queue(), ^{
   73|      0|    if ([self->_application respondsToSelector:@selector(registerForRemoteNotifications)]) {
   74|      0|      [self->_application registerForRemoteNotifications];
   75|      0|    } else {
   76|      0|#pragma clang diagnostic push
   77|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
   78|      0|#if TARGET_OS_IOS
   79|      0|      [self->_application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert];
   80|      0|#endif  // TARGET_OS_IOS
   81|      0|#pragma clang diagnostic pop
   82|      0|    }
   83|      0|  });
   84|      0|  NSArray<FIRAuthAPNSTokenCallback> *applicableCallbacks = _pendingCallbacks;
   85|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_timeout * NSEC_PER_SEC)),
   86|      0|                               FIRAuthGlobalWorkQueue(), ^{
   87|      0|    // Only cancel if the pending callbacks remain the same, i.e., not triggered yet.
   88|      0|    if (applicableCallbacks == self->_pendingCallbacks) {
   89|      0|      [self callBackWithToken:nil error:nil];
   90|      0|    }
   91|      0|  });
   92|      0|}
   93|       |
   94|      0|- (void)setToken:(nullable FIRAuthAPNSToken *)token {
   95|      0|  if (!token) {
   96|      0|    _token = nil;
   97|      0|    return;
   98|      0|  }
   99|      0|  if (token.type == FIRAuthAPNSTokenTypeUnknown) {
  100|      0|    static FIRAuthAPNSTokenType detectedTokenType = FIRAuthAPNSTokenTypeUnknown;
  101|      0|    if (detectedTokenType == FIRAuthAPNSTokenTypeUnknown) {
  102|      0|      detectedTokenType =
  103|      0|          [[self class] isProductionApp] ? FIRAuthAPNSTokenTypeProd : FIRAuthAPNSTokenTypeSandbox;
  104|      0|    }
  105|      0|    token = [[FIRAuthAPNSToken alloc] initWithData:token.data type:detectedTokenType];
  106|      0|  }
  107|      0|  _token = token;
  108|      0|  [self callBackWithToken:token error:nil];
  109|      0|}
  110|       |
  111|      0|- (void)cancelWithError:(NSError *)error {
  112|      0|  [self callBackWithToken:nil error:error];
  113|      0|}
  114|       |
  115|       |#pragma mark - Internal methods
  116|       |
  117|       |/** @fn callBack
  118|       |    @brief Calls back all pending callbacks with APNs token or error.
  119|       |    @param token The APNs token if one is available.
  120|       |    @param error The error occurred, if any.
  121|       | */
  122|      0|- (void)callBackWithToken:(nullable FIRAuthAPNSToken *)token error:(nullable NSError *)error {
  123|      0|  if (!_pendingCallbacks) {
  124|      0|    return;
  125|      0|  }
  126|      0|  NSArray<FIRAuthAPNSTokenCallback> *allCallbacks = _pendingCallbacks;
  127|      0|  _pendingCallbacks = nil;
  128|      0|  for (FIRAuthAPNSTokenCallback callback in allCallbacks) {
  129|      0|    callback(token, error);
  130|      0|  }
  131|      0|};
  132|       |
  133|       |/** @fn isProductionApp
  134|       |    @brief Whether or not the app has production (versus sandbox) provisioning profile.
  135|       |    @remarks This method is adapted from @c FIRInstanceID .
  136|       | */
  137|      0|+ (BOOL)isProductionApp {
  138|      0|  const BOOL defaultAppTypeProd = YES;
  139|      0|
  140|      0|  NSError *error = nil;
  141|      0|
  142|      0|  if ([GULAppEnvironmentUtil isSimulator]) {
  143|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000006", @"Assuming prod APNs token type on simulator.");
  144|      0|    return defaultAppTypeProd;
  145|      0|  }
  146|      0|
  147|      0|  // Apps distributed via AppStore or TestFlight use the Production APNS certificates.
  148|      0|  if ([GULAppEnvironmentUtil isFromAppStore]) {
  149|      0|    return defaultAppTypeProd;
  150|      0|  }
  151|      0|  NSString *path = [[[NSBundle mainBundle] bundlePath]
  152|      0|                    stringByAppendingPathComponent:@"embedded.mobileprovision"];
  153|      0|  if ([GULAppEnvironmentUtil isAppStoreReceiptSandbox] && !path.length) {
  154|      0|    // Distributed via TestFlight
  155|      0|    return defaultAppTypeProd;
  156|      0|  }
  157|      0|
  158|      0|  NSMutableData *profileData = [NSMutableData dataWithContentsOfFile:path options:0 error:&error];
  159|      0|
  160|      0|  if (!profileData.length || error) {
  161|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000007",
  162|      0|               @"Error while reading embedded mobileprovision %@", error);
  163|      0|    return defaultAppTypeProd;
  164|      0|  }
  165|      0|
  166|      0|  // The "embedded.mobileprovision" sometimes contains characters with value 0, which signals the
  167|      0|  // end of a c-string and halts the ASCII parser, or with value > 127, which violates strict 7-bit
  168|      0|  // ASCII. Replace any 0s or invalid characters in the input.
  169|      0|  uint8_t *profileBytes = (uint8_t *)profileData.bytes;
  170|      0|  for (int i = 0; i < profileData.length; i++) {
  171|      0|    uint8_t currentByte = profileBytes[i];
  172|      0|    if (!currentByte || currentByte > 127) {
  173|      0|      profileBytes[i] = '.';
  174|      0|    }
  175|      0|  }
  176|      0|
  177|      0|  NSString *embeddedProfile = [[NSString alloc] initWithBytesNoCopy:profileBytes
  178|      0|                                                             length:profileData.length
  179|      0|                                                           encoding:NSASCIIStringEncoding
  180|      0|                                                       freeWhenDone:NO];
  181|      0|
  182|      0|  if (error || !embeddedProfile.length) {
  183|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000008",
  184|      0|               @"Error while reading embedded mobileprovision %@", error);
  185|      0|    return defaultAppTypeProd;
  186|      0|  }
  187|      0|
  188|      0|  NSScanner *scanner = [NSScanner scannerWithString:embeddedProfile];
  189|      0|  NSString *plistContents;
  190|      0|  if ([scanner scanUpToString:@"<plist" intoString:nil]) {
  191|      0|    if ([scanner scanUpToString:@"</plist>" intoString:&plistContents]) {
  192|      0|      plistContents = [plistContents stringByAppendingString:@"</plist>"];
  193|      0|    }
  194|      0|  }
  195|      0|
  196|      0|  if (!plistContents.length) {
  197|      0|    return defaultAppTypeProd;
  198|      0|  }
  199|      0|
  200|      0|  NSData *data = [plistContents dataUsingEncoding:NSUTF8StringEncoding];
  201|      0|  if (!data.length) {
  202|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000009",
  203|      0|               @"Couldn't read plist fetched from embedded mobileprovision");
  204|      0|    return defaultAppTypeProd;
  205|      0|  }
  206|      0|
  207|      0|  NSError *plistMapError;
  208|      0|  id plistData = [NSPropertyListSerialization propertyListWithData:data
  209|      0|                                                           options:NSPropertyListImmutable
  210|      0|                                                            format:nil
  211|      0|                                                             error:&plistMapError];
  212|      0|  if (plistMapError || ![plistData isKindOfClass:[NSDictionary class]]) {
  213|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000010",
  214|      0|               @"Error while converting assumed plist to dict %@",
  215|      0|               plistMapError.localizedDescription);
  216|      0|    return defaultAppTypeProd;
  217|      0|  }
  218|      0|  NSDictionary *plistMap = (NSDictionary *)plistData;
  219|      0|
  220|      0|  if ([plistMap valueForKeyPath:@"ProvisionedDevices"]) {
  221|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000011",
  222|      0|               @"Provisioning profile has specifically provisioned devices, "
  223|      0|               @"most likely a Dev profile.");
  224|      0|  }
  225|      0|
  226|      0|  NSString *apsEnvironment = [plistMap valueForKeyPath:@"Entitlements.aps-environment"];
  227|      0|  FIRLogDebug(kFIRLoggerAuth, @"I-AUT000012",
  228|      0|              @"APNS Environment in profile: %@", apsEnvironment);
  229|      0|
  230|      0|  // No aps-environment in the profile.
  231|      0|  if (!apsEnvironment.length) {
  232|      0|    FIRLogInfo(kFIRLoggerAuth, @"I-AUT000013",
  233|      0|               @"No aps-environment set. If testing on a device APNS is not "
  234|      0|               @"correctly configured. Please recheck your provisioning profiles.");
  235|      0|    return defaultAppTypeProd;
  236|      0|  }
  237|      0|
  238|      0|  if ([apsEnvironment isEqualToString:@"development"]) {
  239|      0|    return NO;
  240|      0|  }
  241|      0|
  242|      0|  return defaultAppTypeProd;
  243|      0|}
  244|       |
  245|       |@end
  246|       |
  247|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthAppCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthAppCredential.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kReceiptKey
   22|       |    @brief The key used to encode the receipt property for NSSecureCoding.
   23|       | */
   24|       |static NSString *const kReceiptKey = @"receipt";
   25|       |
   26|       |/** @var kSecretKey
   27|       |    @brief The key used to encode the secret property for NSSecureCoding.
   28|       | */
   29|       |static NSString *const kSecretKey = @"secret";
   30|       |
   31|       |@implementation FIRAuthAppCredential
   32|       |
   33|      0|- (instancetype)initWithReceipt:(NSString *)receipt secret:(nullable NSString *)secret {
   34|      0|  self = [super init];
   35|      0|  if (self) {
   36|      0|    _receipt = [receipt copy];
   37|      0|    _secret = [secret copy];
   38|      0|  }
   39|      0|  return self;
   40|      0|}
   41|       |
   42|       |#pragma mark - NSSecureCoding
   43|       |
   44|      0|+ (BOOL)supportsSecureCoding {
   45|      0|  return YES;
   46|      0|}
   47|       |
   48|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   49|      0|  NSString *receipt = [aDecoder decodeObjectOfClass:[NSString class] forKey:kReceiptKey];
   50|      0|  if (!receipt) {
   51|      0|    return nil;
   52|      0|  }
   53|      0|  NSString *secret = [aDecoder decodeObjectOfClass:[NSString class] forKey:kSecretKey];
   54|      0|  return [self initWithReceipt:receipt secret:secret];
   55|      0|}
   56|       |
   57|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   58|      0|  [aCoder encodeObject:_receipt forKey:kReceiptKey];
   59|      0|  [aCoder encodeObject:_secret forKey:kSecretKey];
   60|      0|}
   61|       |
   62|       |@end
   63|       |
   64|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthAppCredentialManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthAppCredentialManager.h"
   18|       |
   19|       |#import "FIRAuthAppCredential.h"
   20|       |#import "FIRAuthGlobalWorkQueue.h"
   21|       |#import "FIRAuthKeychain.h"
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |/** @var kKeychainDataKey
   26|       |    @brief The keychain key for the data.
   27|       | */
   28|       |static NSString *const kKeychainDataKey = @"app_credentials";
   29|       |
   30|       |/** @var kFullCredentialKey
   31|       |    @brief The data key for the full app credential.
   32|       | */
   33|       |static NSString *const kFullCredentialKey = @"full_credential";
   34|       |
   35|       |/** @var kPendingReceiptsKey
   36|       |    @brief The data key for the array of pending receipts.
   37|       | */
   38|       |static NSString *const kPendingReceiptsKey = @"pending_receipts";
   39|       |
   40|       |/** @var kMaximumNumberOfPendingReceipts
   41|       |    @brief The maximum number of partial credentials kept by this class.
   42|       | */
   43|       |static const NSUInteger kMaximumNumberOfPendingReceipts = 32;
   44|       |
   45|       |@implementation FIRAuthAppCredentialManager {
   46|       |  /** @var _keychain
   47|       |      @brief The keychain for app credentials to load from and to save to.
   48|       |   */
   49|       |  FIRAuthKeychain *_keychain;
   50|       |
   51|       |  /** @var _pendingReceipts
   52|       |      @brief A list of pending receipts sorted in the order they were recorded.
   53|       |   */
   54|       |  NSMutableArray<NSString *> *_pendingReceipts;
   55|       |
   56|       |  /** @var _callbacksByReceipt
   57|       |      @brief A map from pending receipts to callbacks.
   58|       |   */
   59|       |  NSMutableDictionary<NSString *, FIRAuthAppCredentialCallback> *_callbacksByReceipt;
   60|       |}
   61|       |
   62|      1|- (instancetype)initWithKeychain:(FIRAuthKeychain *)keychain {
   63|      1|  self = [super init];
   64|      1|  if (self) {
   65|      1|    _keychain = keychain;
   66|      1|    // Load the credentials from keychain if possible.
   67|      1|    NSError *error;
   68|      1|    NSData *encodedData = [_keychain dataForKey:kKeychainDataKey error:&error];
   69|      1|    if (!error && encodedData) {
   70|      0|      NSKeyedUnarchiver *unarchiver =
   71|      0|          [[NSKeyedUnarchiver alloc] initForReadingWithData:encodedData];
   72|      0|      FIRAuthAppCredential *credential =
   73|      0|          [unarchiver decodeObjectOfClass:[FIRAuthAppCredential class]
   74|      0|                                   forKey:kFullCredentialKey];
   75|      0|      if ([credential isKindOfClass:[FIRAuthAppCredential class]]) {
   76|      0|        _credential = credential;
   77|      0|      }
   78|      0|      NSSet<Class> *allowedClasses =
   79|      0|          [NSSet<Class> setWithObjects:[NSArray class], [NSString class], nil];
   80|      0|      NSArray<NSString *> *pendingReceipts =
   81|      0|          [unarchiver decodeObjectOfClasses:allowedClasses forKey:kPendingReceiptsKey];
   82|      0|      if ([pendingReceipts isKindOfClass:[NSArray class]]) {
   83|      0|        _pendingReceipts = [pendingReceipts mutableCopy];
   84|      0|      }
   85|      0|    }
   86|      1|    if (!_pendingReceipts) {
   87|      1|      _pendingReceipts = [[NSMutableArray<NSString *> alloc] init];
   88|      1|    }
   89|      1|    _callbacksByReceipt =
   90|      1|        [[NSMutableDictionary<NSString *, FIRAuthAppCredentialCallback> alloc] init];
   91|      1|  }
   92|      1|  return self;
   93|      1|}
   94|       |
   95|      0|- (NSUInteger)maximumNumberOfPendingReceipts {
   96|      0|  return kMaximumNumberOfPendingReceipts;
   97|      0|}
   98|       |
   99|       |- (void)didStartVerificationWithReceipt:(NSString *)receipt
  100|       |                                timeout:(NSTimeInterval)timeout
  101|      0|                               callback:(FIRAuthAppCredentialCallback)callback {
  102|      0|  [_pendingReceipts removeObject:receipt];
  103|      0|  if (_pendingReceipts.count >= kMaximumNumberOfPendingReceipts) {
  104|      0|    [_pendingReceipts removeObjectAtIndex:0];
  105|      0|  }
  106|      0|  [_pendingReceipts addObject:receipt];
  107|      0|  _callbacksByReceipt[receipt] = callback;
  108|      0|  [self saveData];
  109|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeout * NSEC_PER_SEC)),
  110|      0|                               FIRAuthGlobalWorkQueue(), ^{
  111|      0|    [self callBackWithReceipt:receipt];
  112|      0|  });
  113|      0|}
  114|       |
  115|      0|- (BOOL)canFinishVerificationWithReceipt:(NSString *)receipt secret:(NSString *)secret {
  116|      0|  if (![_pendingReceipts containsObject:receipt]) {
  117|      0|    return NO;
  118|      0|  }
  119|      0|  [_pendingReceipts removeObject:receipt];
  120|      0|  _credential = [[FIRAuthAppCredential alloc] initWithReceipt:receipt secret:secret];
  121|      0|  [self saveData];
  122|      0|  [self callBackWithReceipt:receipt];
  123|      0|  return YES;
  124|      0|}
  125|       |
  126|      0|- (void)clearCredential {
  127|      0|  _credential = nil;
  128|      0|  [self saveData];
  129|      0|}
  130|       |
  131|       |#pragma mark - Internal methods
  132|       |
  133|       |/** @fn saveData
  134|       |    @brief Save the data in memory to the keychain ignoring any errors.
  135|       | */
  136|      0|- (void)saveData {
  137|      0|  NSMutableData *archiveData = [NSMutableData data];
  138|      0|  NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:archiveData];
  139|      0|  [archiver encodeObject:_credential forKey:kFullCredentialKey];
  140|      0|  [archiver encodeObject:_pendingReceipts forKey:kPendingReceiptsKey];
  141|      0|  [archiver finishEncoding];
  142|      0|  [_keychain setData:archiveData forKey:kKeychainDataKey error:NULL];
  143|      0|}
  144|       |
  145|       |/** @fn callBackWithReceipt:
  146|       |    @brief Calls the saved callback for the specifc receipt.
  147|       |    @param receipt The receipt associated with the callback.
  148|       | */
  149|      0|- (void)callBackWithReceipt:(NSString *)receipt {
  150|      0|  FIRAuthAppCredentialCallback callback = _callbacksByReceipt[receipt];
  151|      0|  if (!callback) {
  152|      0|    return;
  153|      0|  }
  154|      0|  [_callbacksByReceipt removeObjectForKey:receipt];
  155|      0|  if (_credential) {
  156|      0|    callback(_credential);
  157|      0|  } else {
  158|      0|    callback([[FIRAuthAppCredential alloc] initWithReceipt:receipt secret:nil]);
  159|      0|  }
  160|      0|}
  161|       |
  162|       |@end
  163|       |
  164|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthAppDelegateProxy.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthAppDelegateProxy.h"
   18|       |
   19|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   20|       |
   21|       |#import <objc/runtime.h>
   22|       |
   23|       |NS_ASSUME_NONNULL_BEGIN
   24|       |
   25|       |/** @var kProxyEnabledBundleKey
   26|       |    @brief The key in application's bundle plist for whether or not proxy should be enabled.
   27|       |    @remarks This key is a shared constant with Analytics and FCM.
   28|       | */
   29|       |static NSString *const kProxyEnabledBundleKey = @"FirebaseAppDelegateProxyEnabled";
   30|       |
   31|       |/** @fn noop
   32|       |    @brief A function that does nothing.
   33|       |    @remarks This is used as the placeholder for unimplemented UApplicationDelegate methods,
   34|       |        because once we added a method there is no way to remove it from the class.
   35|       | */
   36|       |#if !OBJC_OLD_DISPATCH_PROTOTYPES
   37|      0|static void noop(void) {
   38|      0|}
   39|       |#else
   40|       |static id noop(id object, SEL cmd, ...) {
   41|       |  return nil;
   42|       |}
   43|       |#endif
   44|       |
   45|       |/** @fn isIOS9orLater
   46|       |    @brief Checks whether the iOS version is 9 or later.
   47|       |    @returns Whether the iOS version is 9 or later.
   48|       | */
   49|      1|static BOOL isIOS9orLater() {
   50|      1|#if defined(__IPHONE_11_0) && (__IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_11_0)
   51|      1|  if (@available(iOS 9.0, *)) {
   52|      1|    return YES;
   53|      1|  }
   54|      0|  return NO;
   55|       |#else
   56|       |  // UIApplicationOpenURLOptionsAnnotationKey is only available on iOS 9+.
   57|       |  return &UIApplicationOpenURLOptionsAnnotationKey != NULL;
   58|       |#endif
   59|       |}
   60|       |
   61|       |@implementation FIRAuthAppDelegateProxy {
   62|       |  /** @var _appDelegate
   63|       |      @brief The application delegate whose method is being swizzled.
   64|       |   */
   65|       |  id<UIApplicationDelegate> _appDelegate;
   66|       |
   67|       |  /** @var _orginalImplementationsBySelector
   68|       |      @brief A map from selectors to original implementations that have been swizzled.
   69|       |   */
   70|       |  NSMutableDictionary<NSValue *, NSValue *> *_originalImplementationsBySelector;
   71|       |
   72|       |  /** @var _handlers
   73|       |      @brief The array of weak pointers of `id<FIRAuthAppDelegateHandler>`.
   74|       |   */
   75|       |  NSPointerArray *_handlers;
   76|       |}
   77|       |
   78|      1|- (nullable instancetype)initWithApplication:(nullable UIApplication *)application {
   79|      1|  self = [super init];
   80|      1|  if (self) {
   81|      1|    id proxyEnabled = [[NSBundle mainBundle] objectForInfoDictionaryKey:kProxyEnabledBundleKey];
   82|      1|    if ([proxyEnabled isKindOfClass:[NSNumber class]] && !((NSNumber *)proxyEnabled).boolValue) {
   83|      0|      return nil;
   84|      0|    }
   85|      1|    _appDelegate = application.delegate;
   86|      1|    if (![_appDelegate conformsToProtocol:@protocol(UIApplicationDelegate)]) {
   87|      0|      return nil;
   88|      0|    }
   89|      1|    _originalImplementationsBySelector = [[NSMutableDictionary<NSValue *, NSValue *> alloc] init];
   90|      1|    _handlers = [[NSPointerArray alloc] initWithOptions:NSPointerFunctionsWeakMemory];
   91|      1|
   92|      1|    // Swizzle the methods.
   93|      1|    __weak FIRAuthAppDelegateProxy *weakSelf = self;
   94|      1|    SEL registerDeviceTokenSelector =
   95|      1|        @selector(application:didRegisterForRemoteNotificationsWithDeviceToken:);
   96|      1|    [self replaceSelector:registerDeviceTokenSelector
   97|      1|                withBlock:^(id object, UIApplication* application, NSData *deviceToken) {
   98|      0|      [weakSelf object:object
   99|      0|                                                  selector:registerDeviceTokenSelector
  100|      0|                                               application:application
  101|      0|          didRegisterForRemoteNotificationsWithDeviceToken:deviceToken];
  102|      0|    }];
  103|      1|    SEL failToRegisterRemoteNotificationSelector =
  104|      1|        @selector(application:didFailToRegisterForRemoteNotificationsWithError:);
  105|      1|    [self replaceSelector:failToRegisterRemoteNotificationSelector
  106|      1|                withBlock:^(id object, UIApplication* application, NSError *error) {
  107|      0|      [weakSelf object:object
  108|      0|                                                  selector:failToRegisterRemoteNotificationSelector
  109|      0|                                               application:application
  110|      0|          didFailToRegisterForRemoteNotificationsWithError:error];
  111|      0|    }];
  112|      1|    SEL receiveNotificationSelector = @selector(application:didReceiveRemoteNotification:);
  113|      1|    SEL receiveNotificationWithHandlerSelector =
  114|      1|        @selector(application:didReceiveRemoteNotification:fetchCompletionHandler:);
  115|      1|    if ([_appDelegate respondsToSelector:receiveNotificationWithHandlerSelector] ||
  116|      1|        ![_appDelegate respondsToSelector:receiveNotificationSelector]) {
  117|      1|      // Replace the modern selector which is available on iOS 7 and above.
  118|      1|      [self replaceSelector:receiveNotificationWithHandlerSelector
  119|      1|                  withBlock:^(id object, UIApplication *application, NSDictionary *notification,
  120|      1|                              void (^completionHandler)(UIBackgroundFetchResult)) {
  121|      0|        [weakSelf object:object
  122|      0|                                selector:receiveNotificationWithHandlerSelector
  123|      0|                             application:application
  124|      0|            didReceiveRemoteNotification:notification
  125|      0|                  fetchCompletionHandler:completionHandler];
  126|      0|      }];
  127|      1|    } else {
  128|      0|      // Replace the deprecated selector because this is the only one that the client app uses.
  129|      0|      [self replaceSelector:receiveNotificationSelector
  130|      0|                  withBlock:^(id object, UIApplication *application, NSDictionary *notification) {
  131|      0|        [weakSelf object:object
  132|      0|                                selector:receiveNotificationSelector
  133|      0|                             application:application
  134|      0|            didReceiveRemoteNotification:notification];
  135|      0|      }];
  136|      0|    }
  137|      1|    SEL openURLOptionsSelector = @selector(application:openURL:options:);
  138|      1|    SEL openURLAnnotationSelector = @selector(application:openURL:sourceApplication:annotation:);
  139|      1|    SEL handleOpenURLSelector = @selector(application:handleOpenURL:);
  140|      1|    if (isIOS9orLater() &&
  141|      1|        ([_appDelegate respondsToSelector:openURLOptionsSelector] ||
  142|      1|         (![_appDelegate respondsToSelector:openURLAnnotationSelector] &&
  143|      1|          ![_appDelegate respondsToSelector:handleOpenURLSelector]))) {
  144|      1|      // Replace the modern selector which is avaliable on iOS 9 and above because this is the one
  145|      1|      // that the client app uses or the client app doesn't use any of them.
  146|      1|      [self replaceSelector:openURLOptionsSelector
  147|      1|                  withBlock:^BOOL(id object, UIApplication *application, NSURL *url,
  148|      1|                                  NSDictionary *options) {
  149|      0|        return [weakSelf object:object
  150|      0|                       selector:openURLOptionsSelector
  151|      0|                    application:application
  152|      0|                        openURL:url
  153|      0|                        options:options];
  154|      0|       }];
  155|      1|    } else if ([_appDelegate respondsToSelector:openURLAnnotationSelector] ||
  156|      0|               ![_appDelegate respondsToSelector:handleOpenURLSelector]) {
  157|      0|      // Replace the longer form of the deprecated selectors on iOS 8 and below because this is the
  158|      0|      // one that the client app uses or the client app doesn't use either of the applicable ones.
  159|      0|      [self replaceSelector:openURLAnnotationSelector
  160|      0|                  withBlock:^(id object, UIApplication *application, NSURL *url,
  161|      0|                              NSString *sourceApplication, id annotation) {
  162|      0|        return [weakSelf object:object
  163|      0|                       selector:openURLAnnotationSelector
  164|      0|                    application:application
  165|      0|                        openURL:url
  166|      0|              sourceApplication:sourceApplication
  167|      0|                     annotation:annotation];
  168|      0|       }];
  169|      0|    } else {
  170|      0|      // Replace the shorter form of the deprecated selectors on iOS 8 and below because this is
  171|      0|      // the only one that the client app uses.
  172|      0|      [self replaceSelector:handleOpenURLSelector
  173|      0|                  withBlock:^(id object, UIApplication *application, NSURL *url) {
  174|      0|        return [weakSelf object:object
  175|      0|                       selector:handleOpenURLSelector
  176|      0|                    application:application
  177|      0|                  handleOpenURL:url];
  178|      0|       }];
  179|      0|    }
  180|      1|    // Reset the application delegate to clear the system cache that indicates whether each of the
  181|      1|    // openURL: methods is implemented on the application delegate.
  182|      1|    application.delegate = nil;
  183|      1|    application.delegate = _appDelegate;
  184|      1|  }
  185|      1|  return self;
  186|      1|}
  187|       |
  188|      0|- (void)dealloc {
  189|      0|  for (NSValue *selector in _originalImplementationsBySelector) {
  190|      0|    IMP implementation = _originalImplementationsBySelector[selector].pointerValue;
  191|      0|    Method method = class_getInstanceMethod([_appDelegate class], selector.pointerValue);
  192|      0|    imp_removeBlock(method_setImplementation(method, implementation));
  193|      0|  }
  194|      0|}
  195|       |
  196|      1|- (void)addHandler:(__weak id<FIRAuthAppDelegateHandler>)handler {
  197|      1|  @synchronized (_handlers) {
  198|      1|    [_handlers addPointer:(__bridge void *)handler];
  199|      1|  }
  200|      1|}
  201|       |
  202|      2|+ (nullable instancetype)sharedInstance {
  203|      2|  static dispatch_once_t onceToken;
  204|      2|  static FIRAuthAppDelegateProxy *_Nullable sharedInstance;
  205|      2|  // iOS App extensions should not call [UIApplication sharedApplication], even if UIApplication
  206|      2|  // responds to it.
  207|      2|  static Class applicationClass = nil;
  208|      2|  dispatch_once(&onceToken, ^{
  209|      1|    if (![GULAppEnvironmentUtil isAppExtension]) {
  210|      1|      Class cls = NSClassFromString(@"UIApplication");
  211|      1|      if (cls && [cls respondsToSelector:NSSelectorFromString(@"sharedApplication")]) {
  212|      1|        applicationClass = cls;
  213|      1|      }
  214|      1|    }
  215|      1|    UIApplication *application = [applicationClass sharedApplication];
  216|      1|    sharedInstance = [[self alloc] initWithApplication:application];
  217|      1|  });
  218|      2|  return sharedInstance;
  219|      2|}
  220|       |
  221|       |#pragma mark - UIApplicationDelegate proxy methods.
  222|       |
  223|       |- (void)object:(id)object
  224|       |                                            selector:(SEL)selector
  225|       |                                         application:(UIApplication *)application
  226|      0|    didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
  227|      0|  if (object == _appDelegate) {
  228|      0|    for (id<FIRAuthAppDelegateHandler> handler in [self handlers]) {
  229|      0|      [handler setAPNSToken:deviceToken];
  230|      0|    }
  231|      0|  }
  232|      0|  IMP originalImplementation = [self originalImplementationForSelector:selector];
  233|      0|  if (originalImplementation && originalImplementation != &noop) {
  234|      0|    typedef void (*Implmentation)(id, SEL, UIApplication*, NSData *);
  235|      0|    ((Implmentation)originalImplementation)(object, selector, application, deviceToken);
  236|      0|  }
  237|      0|}
  238|       |
  239|       |- (void)object:(id)object
  240|       |                                            selector:(SEL)selector
  241|       |                                         application:(UIApplication *)application
  242|      0|    didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {
  243|      0|  if (object == _appDelegate) {
  244|      0|    for (id<FIRAuthAppDelegateHandler> handler in [self handlers]) {
  245|      0|      [handler handleAPNSTokenError:error];
  246|      0|    }
  247|      0|  }
  248|      0|  IMP originalImplementation = [self originalImplementationForSelector:selector];
  249|      0|  if (originalImplementation && originalImplementation != &noop) {
  250|      0|    typedef void (*Implmentation)(id, SEL, UIApplication *, NSError *);
  251|      0|    ((Implmentation)originalImplementation)(object, selector, application, error);
  252|      0|  }
  253|      0|}
  254|       |
  255|       |- (void)object:(id)object
  256|       |                        selector:(SEL)selector
  257|       |                     application:(UIApplication *)application
  258|       |    didReceiveRemoteNotification:(NSDictionary *)notification
  259|      0|          fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler {
  260|      0|  if (object == _appDelegate) {
  261|      0|    for (id<FIRAuthAppDelegateHandler> handler in [self handlers]) {
  262|      0|      if ([handler canHandleNotification:notification]) {
  263|      0|        completionHandler(UIBackgroundFetchResultNoData);
  264|      0|        return;
  265|      0|      };
  266|      0|    }
  267|      0|  }
  268|      0|  IMP originalImplementation = [self originalImplementationForSelector:selector];
  269|      0|  if (originalImplementation && originalImplementation != &noop) {
  270|      0|    typedef void (*Implmentation)(id, SEL, UIApplication*, NSDictionary *,
  271|      0|                                  void (^)(UIBackgroundFetchResult));
  272|      0|    ((Implmentation)originalImplementation)(object, selector, application, notification,
  273|      0|                                            completionHandler);
  274|      0|  }
  275|      0|}
  276|       |
  277|       |- (void)object:(id)object
  278|       |                        selector:(SEL)selector
  279|       |                     application:(UIApplication *)application
  280|      0|    didReceiveRemoteNotification:(NSDictionary *)notification {
  281|      0|  if (object == _appDelegate) {
  282|      0|    for (id<FIRAuthAppDelegateHandler> handler in [self handlers]) {
  283|      0|      if ([handler canHandleNotification:notification]) {
  284|      0|        return;
  285|      0|      };
  286|      0|    }
  287|      0|  }
  288|      0|  IMP originalImplementation = [self originalImplementationForSelector:selector];
  289|      0|  if (originalImplementation && originalImplementation != &noop) {
  290|      0|    typedef void (*Implmentation)(id, SEL, UIApplication*, NSDictionary *);
  291|      0|    ((Implmentation)originalImplementation)(object, selector, application, notification);
  292|      0|  }
  293|      0|}
  294|       |
  295|       |- (BOOL)object:(id)object
  296|       |       selector:(SEL)selector
  297|       |    application:(UIApplication *)application
  298|       |        openURL:(NSURL *)url
  299|      0|        options:(NSDictionary *)options {
  300|      0|  if (object == _appDelegate && [self delegateCanHandleURL:url]) {
  301|      0|    return YES;
  302|      0|  }
  303|      0|  IMP originalImplementation = [self originalImplementationForSelector:selector];
  304|      0|  if (originalImplementation && originalImplementation != &noop) {
  305|      0|    typedef BOOL (*Implmentation)(id, SEL, UIApplication*, NSURL *, NSDictionary *);
  306|      0|    return ((Implmentation)originalImplementation)(object, selector, application, url, options);
  307|      0|  }
  308|      0|  return NO;
  309|      0|}
  310|       |
  311|       |- (BOOL)object:(id)object
  312|       |             selector:(SEL)selector
  313|       |          application:(UIApplication *)application
  314|       |              openURL:(NSURL *)url
  315|       |    sourceApplication:(NSString *)sourceApplication
  316|      0|           annotation:(id)annotation {
  317|      0|  if (object == _appDelegate && [self delegateCanHandleURL:url]) {
  318|      0|    return YES;
  319|      0|  }
  320|      0|  IMP originalImplementation = [self originalImplementationForSelector:selector];
  321|      0|  if (originalImplementation && originalImplementation != &noop) {
  322|      0|    typedef BOOL (*Implmentation)(id, SEL, UIApplication*, NSURL *, NSString *, id);
  323|      0|    return ((Implmentation)originalImplementation)(object, selector, application, url,
  324|      0|                                                   sourceApplication, annotation);
  325|      0|  }
  326|      0|  return NO;
  327|      0|}
  328|       |
  329|       |- (BOOL)object:(id)object
  330|       |         selector:(SEL)selector
  331|       |      application:(UIApplication *)application
  332|      0|    handleOpenURL:(NSURL *)url {
  333|      0|  if (object == _appDelegate && [self delegateCanHandleURL:url]) {
  334|      0|    return YES;
  335|      0|  }
  336|      0|  IMP originalImplementation = [self originalImplementationForSelector:selector];
  337|      0|  if (originalImplementation && originalImplementation != &noop) {
  338|      0|    typedef BOOL (*Implmentation)(id, SEL, UIApplication*, NSURL *);
  339|      0|    return ((Implmentation)originalImplementation)(object, selector, application, url);
  340|      0|  }
  341|      0|  return NO;
  342|      0|}
  343|       |
  344|       |#pragma mark - Internal Methods
  345|       |
  346|       |/** @fn delegateCanHandleURL:
  347|       |    @brief Checks for whether any of the delegates can handle the URL.
  348|       |    @param url The URL in question.
  349|       |    @return Whether any of the delegate can handle the URL.
  350|       | */
  351|      0|- (BOOL)delegateCanHandleURL:(NSURL *)url {
  352|      0|  for (id<FIRAuthAppDelegateHandler> handler in [self handlers]) {
  353|      0|    if ([handler canHandleURL:url]) {
  354|      0|      return YES;
  355|      0|    };
  356|      0|  }
  357|      0|  return NO;
  358|      0|}
  359|       |
  360|       |/** @fn handlers
  361|       |    @brief Gets the list of handlers from `_handlers` safely.
  362|       | */
  363|      0|- (NSArray<id<FIRAuthAppDelegateHandler>> *)handlers {
  364|      0|  @synchronized (_handlers) {
  365|      0|    NSMutableArray<id<FIRAuthAppDelegateHandler>> *liveHandlers =
  366|      0|       [[NSMutableArray<id<FIRAuthAppDelegateHandler>> alloc] initWithCapacity:_handlers.count];
  367|      0|    for (__weak id<FIRAuthAppDelegateHandler> handler in _handlers) {
  368|      0|      if (handler) {
  369|      0|        [liveHandlers addObject:handler];
  370|      0|      }
  371|      0|    }
  372|      0|    if (liveHandlers.count < _handlers.count) {
  373|      0|      [_handlers compact];
  374|      0|    }
  375|      0|    return liveHandlers;
  376|      0|  }
  377|      0|}
  378|       |
  379|       |/** @fn replaceSelector:withBlock:
  380|       |    @brief replaces the implementation for a method of `_appDelegate` specified by a selector.
  381|       |    @param selector The selector for the method.
  382|       |    @param block The block as the new implementation of the method.
  383|       | */
  384|      4|- (void)replaceSelector:(SEL)selector withBlock:(id)block {
  385|      4|  Method originalMethod = class_getInstanceMethod([_appDelegate class], selector);
  386|      4|  IMP newImplementation = imp_implementationWithBlock(block);
  387|      4|  IMP originalImplementation;
  388|      4|  if (originalMethod) {
  389|      1|    originalImplementation = method_setImplementation(originalMethod, newImplementation) ?: &noop;
  390|      3|  } else {
  391|      3|    // The original method was not implemented in the class, add it with the new implementation.
  392|      3|    struct objc_method_description methodDescription =
  393|      3|        protocol_getMethodDescription(@protocol(UIApplicationDelegate), selector, NO, YES);
  394|      3|    class_addMethod([_appDelegate class], selector, newImplementation, methodDescription.types);
  395|      3|    originalImplementation = &noop;
  396|      3|  }
  397|      4|  _originalImplementationsBySelector[[NSValue valueWithPointer:selector]] =
  398|      4|      [NSValue valueWithPointer:originalImplementation];
  399|      4|}
  400|       |
  401|       |/** @fn originalImplementationForSelector:
  402|       |    @brief Gets the original implementation for the given selector.
  403|       |    @param selector The selector for the method that has been replaced.
  404|       |    @return The original implementation if there was one.
  405|       | */
  406|      0|- (IMP)originalImplementationForSelector:(SEL)selector {
  407|      0|  return _originalImplementationsBySelector[[NSValue valueWithPointer:selector]].pointerValue;
  408|      0|}
  409|       |
  410|       |@end
  411|       |
  412|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthCredential.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthCredential_Internal.h"
   18|       |
   19|       |@implementation FIRAuthCredential
   20|       |
   21|      0|- (instancetype)init {
   22|      0|  @throw [NSException exceptionWithName:@"Attempt to call unavailable initializer."
   23|      0|                                 reason:@"This class is an abstract base class. It's init method "
   24|      0|          "should not be called directly."
   25|      0|                               userInfo:nil];
   26|      0|}
   27|       |
   28|      0|- (nullable instancetype)initWithProvider:(NSString *)provider {
   29|      0|  self = [super init];
   30|      0|  if (self) {
   31|      0|    _provider = [provider copy];
   32|      0|  }
   33|      0|  return self;
   34|      0|}
   35|       |
   36|      0|- (void)prepareVerifyAssertionRequest:(FIRVerifyAssertionRequest *)request {
   37|      0|  @throw [NSException exceptionWithName:@"Attempt to call virtual method."
   38|      0|                                 reason:@"This method must be overridden by a subclass."
   39|      0|                               userInfo:nil];
   40|      0|}
   41|       |
   42|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthDataResult.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthDataResult_Internal.h"
   18|       |
   19|       |#import "FIRAdditionalUserInfo.h"
   20|       |#import "FIRUser.h"
   21|       |
   22|       |NS_ASSUME_NONNULL_BEGIN
   23|       |
   24|       |@implementation FIRAuthDataResult
   25|       |
   26|       |/** @var kAdditionalUserInfoCodingKey
   27|       |    @brief The key used to encode the additionalUserInfo property for NSSecureCoding.
   28|       | */
   29|       |static NSString *const kAdditionalUserInfoCodingKey = @"additionalUserInfo";
   30|       |
   31|       |/** @var kUserCodingKey
   32|       |    @brief The key used to encode the user property for NSSecureCoding.
   33|       | */
   34|       |static NSString *const kUserCodingKey = @"user";
   35|       |
   36|       |- (nullable instancetype)initWithUser:(nullable FIRUser *)user
   37|      0|                   additionalUserInfo:(nullable FIRAdditionalUserInfo *)additionalUserInfo {
   38|      0|  self = [super init];
   39|      0|  if (self) {
   40|      0|    _additionalUserInfo = additionalUserInfo;
   41|      0|    _user = user;
   42|      0|  }
   43|      0|  return self;
   44|      0|}
   45|       |
   46|       |#pragma mark - NSSecureCoding
   47|       |
   48|      0|+ (BOOL)supportsSecureCoding {
   49|      0|  return YES;
   50|      0|}
   51|       |
   52|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   53|      0|  FIRUser *user =
   54|      0|      [aDecoder decodeObjectOfClass:[FIRUser class] forKey:kUserCodingKey];
   55|      0|  FIRAdditionalUserInfo *additionalUserInfo =
   56|      0|      [aDecoder decodeObjectOfClass:[FIRAdditionalUserInfo class]
   57|      0|                             forKey:kAdditionalUserInfoCodingKey];
   58|      0|
   59|      0|  return [self initWithUser:user additionalUserInfo:additionalUserInfo];
   60|      0|}
   61|       |
   62|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   63|      0|  [aCoder encodeObject:_user forKey:kUserCodingKey];
   64|      0|  [aCoder encodeObject:_additionalUserInfo forKey:kAdditionalUserInfoCodingKey];
   65|      0|}
   66|       |
   67|       |@end
   68|       |
   69|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthDefaultUIDelegate.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthDefaultUIDelegate.h"
   18|       |
   19|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |@interface FIRAuthDefaultUIDelegate ()
   24|       |
   25|       |/** @fn initWithViewController:
   26|       |    @brief Initializes the instance with a view controller.
   27|       |    @param viewController The view controller as the presenting view controller in @c
   28|       |        FIRAuthUIDelegate.
   29|       |    @return The initialized instance.
   30|       | */
   31|       |- (instancetype)initWithViewController:(nullable UIViewController *)viewController NS_DESIGNATED_INITIALIZER;
   32|       |
   33|       |@end
   34|       |
   35|       |@implementation FIRAuthDefaultUIDelegate {
   36|       |  /** @var _viewController
   37|       |      @brief The presenting view controller.
   38|       |   */
   39|       |  UIViewController *_viewController;
   40|       |}
   41|       |
   42|      0|- (instancetype)initWithViewController:(nullable UIViewController *)viewController {
   43|      0|  self = [super init];
   44|      0|  if (self) {
   45|      0|    _viewController = viewController;
   46|      0|  }
   47|      0|  return self;
   48|      0|}
   49|       |
   50|       |- (void)presentViewController:(UIViewController *)viewControllerToPresent
   51|       |                     animated:(BOOL)flag
   52|      0|                   completion:(nullable void (^)(void))completion {
   53|      0|  [_viewController presentViewController:viewControllerToPresent
   54|      0|                                animated:flag
   55|      0|                              completion:completion];
   56|      0|}
   57|       |
   58|      0|- (void)dismissViewControllerAnimated:(BOOL)flag completion:(nullable void (^)(void))completion {
   59|      0|  [_viewController dismissViewControllerAnimated:flag completion:completion];
   60|      0|}
   61|       |
   62|      0|+ (id<FIRAuthUIDelegate>)defaultUIDelegate {
   63|      0|  // iOS App extensions should not call [UIApplication sharedApplication], even if UIApplication
   64|      0|  // responds to it.
   65|      0|  static Class applicationClass = nil;
   66|      0|  if (![GULAppEnvironmentUtil isAppExtension]) {
   67|      0|    Class cls = NSClassFromString(@"UIApplication");
   68|      0|    if (cls && [cls respondsToSelector:NSSelectorFromString(@"sharedApplication")]) {
   69|      0|      applicationClass = cls;
   70|      0|    }
   71|      0|  }
   72|      0|  UIApplication *application = [applicationClass sharedApplication];
   73|      0|  UIViewController *topViewController = application.keyWindow.rootViewController;
   74|      0|  while (true){
   75|      0|    if (topViewController.presentedViewController) {
   76|      0|      topViewController = topViewController.presentedViewController;
   77|      0|    } else if ([topViewController isKindOfClass:[UINavigationController class]]) {
   78|      0|      UINavigationController *nav = (UINavigationController *)topViewController;
   79|      0|      topViewController = nav.topViewController;
   80|      0|    } else if ([topViewController isKindOfClass:[UITabBarController class]]) {
   81|      0|      UITabBarController *tab = (UITabBarController *)topViewController;
   82|      0|      topViewController = tab.selectedViewController;
   83|      0|    } else {
   84|      0|      break;
   85|      0|    }
   86|      0|  }
   87|      0|  return [[FIRAuthDefaultUIDelegate alloc] initWithViewController:topViewController];
   88|      0|}
   89|       |
   90|       |@end
   91|       |
   92|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthDispatcher.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthDispatcher.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRAuthDispatcher
   22|       |
   23|       |@synthesize dispatchAfterImplementation = _dispatchAfterImplementation;
   24|       |
   25|      0|+ (instancetype)sharedInstance {
   26|      0|  static dispatch_once_t onceToken;
   27|      0|  static FIRAuthDispatcher *sharedInstance;
   28|      0|   dispatch_once(&onceToken, ^{
   29|      0|     sharedInstance = [[self alloc] init];
   30|      0|   });
   31|      0|  return sharedInstance;
   32|      0|}
   33|       |
   34|       |- (void)dispatchAfterDelay:(NSTimeInterval)delay
   35|       |                     queue:(dispatch_queue_t)queue
   36|      0|                      task:(void (^)(void))task {
   37|      0|  if (_dispatchAfterImplementation) {
   38|      0|    _dispatchAfterImplementation(delay, queue, task);
   39|      0|    return;
   40|      0|  }
   41|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, delay * NSEC_PER_SEC), queue, task);
   42|      0|}
   43|       |
   44|       |@end
   45|       |
   46|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthErrorUtils.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthErrorUtils.h"
   18|       |
   19|       |#import "FIRAuthCredential.h"
   20|       |#import "FIRAuthInternalErrors.h"
   21|       |
   22|       |NS_ASSUME_NONNULL_BEGIN
   23|       |
   24|       |NSString *const FIRAuthErrorDomain = @"FIRAuthErrorDomain";
   25|       |
   26|       |NSString *const FIRAuthInternalErrorDomain = @"FIRAuthInternalErrorDomain";
   27|       |
   28|       |NSString *const FIRAuthErrorUserInfoDeserializedResponseKey =
   29|       |    @"FIRAuthErrorUserInfoDeserializedResponseKey";
   30|       |
   31|       |NSString *const FIRAuthErrorUserInfoDataKey = @"FIRAuthErrorUserInfoDataKey";
   32|       |
   33|       |NSString *const FIRAuthErrorUserInfoEmailKey = @"FIRAuthErrorUserInfoEmailKey";
   34|       |
   35|       |NSString *const FIRAuthErrorNameKey = @"error_name";
   36|       |
   37|       |NSString *const FIRAuthUpdatedCredentialKey = @"FIRAuthUpdatedCredentialKey";
   38|       |
   39|       |/** @var kServerErrorDetailMarker
   40|       |    @brief This marker indicates that the server error message contains a detail error message which
   41|       |        should be used instead of the hardcoded client error message.
   42|       | */
   43|       |static NSString *const kServerErrorDetailMarker = @" : ";
   44|       |
   45|       |#pragma mark - URL response error codes
   46|       |
   47|       |/** @var kURLResponseErrorCodeInvalidClientID
   48|       |    @brief Error code that indicates that the client ID provided was invalid.
   49|       | */
   50|       |static NSString *const kURLResponseErrorCodeInvalidClientID = @"auth/invalid-oauth-client-id";
   51|       |
   52|       |/** @var kURLResponseErrorCodeNetworkRequestFailed
   53|       |    @brief Error code that indicates that a network request within the SFSafariViewController or
   54|       |        UIWebView failed.
   55|       | */
   56|       |static NSString *const kURLResponseErrorCodeNetworkRequestFailed = @"auth/network-request-failed";
   57|       |
   58|       |/** @var kURLResponseErrorCodeInternalError
   59|       |    @brief Error code that indicates that an internal error occurred within the
   60|       |        SFSafariViewController or UIWebView failed.
   61|       | */
   62|       |static NSString *const kURLResponseErrorCodeInternalError = @"auth/internal-error";
   63|       |
   64|       |#pragma mark - Standard Error Messages
   65|       |
   66|       |/** @var kFIRAuthErrorMessageInvalidCustomToken
   67|       |    @brief Message for @c FIRAuthErrorCodeInvalidCustomToken error code.
   68|       | */
   69|       |static NSString *const kFIRAuthErrorMessageInvalidCustomToken = @"The custom token format is "
   70|       |    "incorrect. Please check the documentation.";
   71|       |
   72|       |/** @var kFIRAuthErrorMessageCustomTokenMismatch
   73|       |    @brief Message for @c FIRAuthErrorCodeCustomTokenMismatch error code.
   74|       | */
   75|       |static NSString *const kFIRAuthErrorMessageCustomTokenMismatch = @"The custom token corresponds to "
   76|       |    "a different audience.";
   77|       |
   78|       |/** @var kFIRAuthErrorMessageInvalidEmail
   79|       |    @brief Message for @c FIRAuthErrorCodeInvalidEmail error code.
   80|       | */
   81|       |static NSString *const kFIRAuthErrorMessageInvalidEmail = @"The email address is badly formatted.";
   82|       |
   83|       |/** @var kFIRAuthErrorMessageInvalidCredential
   84|       |    @brief Message for @c FIRAuthErrorCodeInvalidCredential error code.
   85|       | */
   86|       |static NSString *const kFIRAuthErrorMessageInvalidCredential = @"The supplied auth credential is "
   87|       |    "malformed or has expired.";
   88|       |
   89|       |/** @var kFIRAuthErrorMessageUserDisabled
   90|       |    @brief Message for @c FIRAuthErrorCodeUserDisabled error code.
   91|       | */
   92|       |static NSString *const kFIRAuthErrorMessageUserDisabled = @"The user account has been disabled by "
   93|       |    "an administrator.";
   94|       |
   95|       |/** @var kFIRAuthErrorMessageEmailAlreadyInUse
   96|       |    @brief Message for @c FIRAuthErrorCodeEmailAlreadyInUse error code.
   97|       | */
   98|       |static NSString *const kFIRAuthErrorMessageEmailAlreadyInUse = @"The email address is already in "
   99|       |    "use by another account.";
  100|       |
  101|       |/** @var kFIRAuthErrorMessageWrongPassword
  102|       |    @brief Message for @c FIRAuthErrorCodeWrongPassword error code.
  103|       | */
  104|       |static NSString *const kFIRAuthErrorMessageWrongPassword = @"The password is invalid or the user "
  105|       |    "does not have a password.";
  106|       |
  107|       |/** @var kFIRAuthErrorMessageTooManyRequests
  108|       |    @brief Message for @c FIRAuthErrorCodeTooManyRequests error code.
  109|       | */
  110|       |static NSString *const kFIRAuthErrorMessageTooManyRequests = @"We have blocked all requests from "
  111|       |    "this device due to unusual activity. Try again later.";
  112|       |
  113|       |/** @var kFIRAuthErrorMessageAccountExistsWithDifferentCredential
  114|       |    @brief Message for @c FIRAuthErrorCodeAccountExistsWithDifferentCredential error code.
  115|       | */
  116|       |static NSString *const kFIRAuthErrorMessageAccountExistsWithDifferentCredential = @"An account "
  117|       |    "already exists with the same email address but different sign-in credentials. Sign in using a "
  118|       |    "provider associated with this email address.";
  119|       |
  120|       |/** @var kFIRAuthErrorMessageRequiresRecentLogin
  121|       |    @brief Message for @c FIRAuthErrorCodeRequiresRecentLogin error code.
  122|       | */
  123|       |static NSString *const kFIRAuthErrorMessageRequiresRecentLogin= @"This operation is sensitive and "
  124|       |    "requires recent authentication. Log in again before retrying this request.";
  125|       |
  126|       |/** @var kFIRAuthErrorMessageProviderAlreadyLinked
  127|       |    @brief Message for @c FIRAuthErrorCodeProviderAlreadyExists error code.
  128|       | */
  129|       |static NSString *const kFIRAuthErrorMessageProviderAlreadyLinked =
  130|       |    @"[ERROR_PROVIDER_ALREADY_LINKED] - User can only be linked to one identity for the given "
  131|       |        "provider.";
  132|       |
  133|       |/** @var kFIRAuthErrorMessageNoSuchProvider
  134|       |    @brief Message for @c FIRAuthErrorCodeNoSuchProvider error code.
  135|       | */
  136|       |static NSString *const kFIRAuthErrorMessageNoSuchProvider = @"User was not linked to an account "
  137|       |    "with the given provider.";
  138|       |
  139|       |/** @var kFIRAuthErrorMessageInvalidUserToken
  140|       |    @brief Message for @c FIRAuthErrorCodeInvalidUserToken error code.
  141|       | */
  142|       |static NSString *const kFIRAuthErrorMessageInvalidUserToken = @"This user's credential isn't valid "
  143|       |    "for this project. This can happen if the user's token has been tampered with, or if the user "
  144|       |    "doesn’t belong to the project associated with the API key used in your request.";
  145|       |
  146|       |/** @var kFIRAuthErrorMessageNetworkError
  147|       |    @brief Message for @c FIRAuthErrorCodeNetworkError error code.
  148|       | */
  149|       |static NSString *const kFIRAuthErrorMessageNetworkError = @"Network error (such as timeout, "
  150|       |    "interrupted connection or unreachable host) has occurred.";
  151|       |
  152|       |/** @var kFIRAuthErrorMessageKeychainError
  153|       |    @brief Message for @c FIRAuthErrorCodeKeychainError error code.
  154|       | */
  155|       |static NSString *const kFIRAuthErrorMessageKeychainError = @"An error occurred when accessing the "
  156|       |    "keychain. The @c NSLocalizedFailureReasonErrorKey field in the @c NSError.userInfo dictionary "
  157|       |    "will contain more information about the error encountered";
  158|       |
  159|       |/** @var kFIRAuthErrorMessageUserTokenExpired
  160|       |    @brief Message for @c FIRAuthErrorCodeTokenExpired error code.
  161|       | */
  162|       |static NSString *const kFIRAuthErrorMessageUserTokenExpired = @"The user's credential is no longer "
  163|       |    "valid. The user must sign in again.";
  164|       |
  165|       |/** @var kFIRAuthErrorMessageUserNotFound
  166|       |    @brief Message for @c FIRAuthErrorCodeUserNotFound error code.
  167|       | */
  168|       |static NSString *const kFIRAuthErrorMessageUserNotFound = @"There is no user record corresponding "
  169|       |    "to this identifier. The user may have been deleted.";
  170|       |
  171|       |/** @var kFIRAuthErrorMessageInvalidAPIKey
  172|       |    @brief Message for @c FIRAuthErrorCodeInvalidAPIKey error code.
  173|       |    @remarks This error is not thrown by the server.
  174|       | */
  175|       |static NSString *const kFIRAuthErrorMessageInvalidAPIKey = @"An invalid API Key was supplied in "
  176|       |    "the request.";
  177|       |
  178|       |/** @var kFIRAuthErrorMessageUserMismatch.
  179|       |    @brief Message for @c FIRAuthErrorCodeInvalidAPIKey error code.
  180|       | */
  181|       |static NSString *const FIRAuthErrorMessageUserMismatch = @"The supplied credentials do not "
  182|       |    "correspond to the previously signed in user.";
  183|       |
  184|       |/** @var kFIRAuthErrorMessageCredentialAlreadyInUse
  185|       |    @brief Message for @c FIRAuthErrorCodeCredentialAlreadyInUse error code.
  186|       | */
  187|       |static NSString *const kFIRAuthErrorMessageCredentialAlreadyInUse = @"This credential is already "
  188|       |    "associated with a different user account.";
  189|       |
  190|       |/** @var kFIRAuthErrorMessageOperationNotAllowed
  191|       |    @brief Message for @c FIRAuthErrorCodeOperationNotAllowed error code.
  192|       | */
  193|       |static NSString *const kFIRAuthErrorMessageOperationNotAllowed = @"The given sign-in provider is "
  194|       |    "disabled for this Firebase project. Enable it in the Firebase console, under the sign-in "
  195|       |    "method tab of the Auth section.";
  196|       |
  197|       |/** @var kFIRAuthErrorMessageWeakPassword
  198|       |    @brief Message for @c FIRAuthErrorCodeWeakPassword error code.
  199|       | */
  200|       |static NSString *const kFIRAuthErrorMessageWeakPassword = @"The password must be 6 characters long "
  201|       |    "or more.";
  202|       |
  203|       |/** @var kFIRAuthErrorMessageAppNotAuthorized
  204|       |    @brief Message for @c FIRAuthErrorCodeAppNotAuthorized error code.
  205|       | */
  206|       |static NSString *const kFIRAuthErrorMessageAppNotAuthorized = @"This app is not authorized to use "
  207|       |    "Firebase Authentication with the provided API key. Review your key configuration in the "
  208|       |    "Google API console and ensure that it accepts requests from your app's bundle ID.";
  209|       |
  210|       |/** @var kFIRAuthErrorMessageExpiredActionCode
  211|       |    @brief Message for @c FIRAuthErrorCodeExpiredActionCode error code.
  212|       | */
  213|       |static NSString *const kFIRAuthErrorMessageExpiredActionCode = @"The action code has expired.";
  214|       |
  215|       |/** @var kFIRAuthErrorMessageInvalidActionCode
  216|       |    @brief Message for @c FIRAuthErrorCodeInvalidActionCode error code.
  217|       | */
  218|       |static NSString *const kFIRAuthErrorMessageInvalidActionCode = @"The action code is invalid. This "
  219|       |   "can happen if the code is malformed, expired, or has already been used.";
  220|       |
  221|       |/** @var kFIRAuthErrorMessageInvalidMessagePayload
  222|       |    @brief Message for @c FIRAuthErrorCodeInvalidMessagePayload error code.
  223|       | */
  224|       |static NSString *const kFIRAuthErrorMessageInvalidMessagePayload = @"The action code is invalid. "
  225|       |   "This can happen if the code is malformed, expired, or has already been used.";
  226|       |
  227|       |/** @var kFIRAuthErrorMessageInvalidSender
  228|       |    @brief Message for @c FIRAuthErrorCodeInvalidSender error code.
  229|       | */
  230|       |static NSString *const kFIRAuthErrorMessageInvalidSender = @"The email template corresponding to "
  231|       |    "this action contains invalid characters in its message. Please fix by going to the Auth email "
  232|       |    "templates section in the Firebase Console.";
  233|       |
  234|       |/** @var kFIRAuthErrorMessageInvalidRecipientEmail
  235|       |    @brief Message for @c FIRAuthErrorCodeInvalidRecipient error code.
  236|       | */
  237|       |static NSString *const kFIRAuthErrorMessageInvalidRecipientEmail = @"The action code is invalid. "
  238|       |   "This can happen if the code is malformed, expired, or has already been used.";
  239|       |
  240|       |/** @var kFIRAuthErrorMessageMissingIosBundleID
  241|       |    @brief Message for @c FIRAuthErrorCodeMissingIosbundleID error code.
  242|       | */
  243|       |static NSString *const kFIRAuthErrorMessageMissingIosBundleID =
  244|       |    @"An iOS Bundle ID must be provided if an App Store ID is provided.";
  245|       |
  246|       |/** @var kFIRAuthErrorMessageMissingAndroidPackageName
  247|       |    @brief Message for @c FIRAuthErrorCodeMissingAndroidPackageName error code.
  248|       | */
  249|       |static NSString *const kFIRAuthErrorMessageMissingAndroidPackageName =
  250|       |    @"An Android Package Name must be provided if the Android App is required to be installed.";
  251|       |
  252|       |/** @var kFIRAuthErrorMessageUnauthorizedDomain
  253|       |    @brief Message for @c FIRAuthErrorCodeUnauthorizedDomain error code.
  254|       | */
  255|       |static NSString *const kFIRAuthErrorMessageUnauthorizedDomain = @"The domain of the continue URL "
  256|       |    "is not whitelisted. Please whitelist the domain in the Firebase console.";
  257|       |
  258|       |/** @var kFIRAuthErrorMessageInvalidContinueURI
  259|       |    @brief Message for @c FIRAuthErrorCodeInvalidContinueURI error code.
  260|       | */
  261|       |static NSString *const kFIRAuthErrorMessageInvalidContinueURI =
  262|       |    @"The continue URL provided in the request is invalid.";
  263|       |
  264|       |/** @var kFIRAuthErrorMessageMissingEmail
  265|       |    @brief Message for @c FIRAuthErrorCodeMissingEmail error code.
  266|       | */
  267|       |static NSString *const kFIRAuthErrorMessageMissingEmail = @"An email address must be provided.";
  268|       |
  269|       |/** @var kFIRAuthErrorMessageMissingContinueURI
  270|       |    @brief Message for @c FIRAuthErrorCodeMissingContinueURI error code.
  271|       | */
  272|       |static NSString *const kFIRAuthErrorMessageMissingContinueURI =
  273|       |    @"A continue URL must be provided in the request.";
  274|       |
  275|       |/** @var kFIRAuthErrorMessageMissingPhoneNumber
  276|       |    @brief Message for @c FIRAuthErrorCodeMissingPhoneNumber error code.
  277|       | */
  278|       |static NSString *const kFIRAuthErrorMessageMissingPhoneNumber =
  279|       |    @"To send verification codes, provide a phone number for the recipient.";
  280|       |
  281|       |/** @var kFIRAuthErrorMessageInvalidPhoneNumber
  282|       |    @brief Message for @c FIRAuthErrorCodeInvalidPhoneNumber error code.
  283|       | */
  284|       |static NSString *const kFIRAuthErrorMessageInvalidPhoneNumber =
  285|       |    @"The format of the phone number provided is incorrect. Please enter the phone number in a "
  286|       |    "format that can be parsed into E.164 format. E.164 phone numbers are written in the format "
  287|       |    "[+][country code][subscriber number including area code].";
  288|       |
  289|       |/** @var kFIRAuthErrorMessageMissingVerificationCode
  290|       |    @brief Message for @c FIRAuthErrorCodeMissingVerificationCode error code.
  291|       | */
  292|       |static NSString *const kFIRAuthErrorMessageMissingVerificationCode =
  293|       |    @"The phone auth credential was created with an empty SMS verification Code.";
  294|       |
  295|       |/** @var kFIRAuthErrorMessageInvalidVerificationCode
  296|       |    @brief Message for @c FIRAuthErrorCodeInvalidVerificationCode error code.
  297|       | */
  298|       |static NSString *const kFIRAuthErrorMessageInvalidVerificationCode =
  299|       |    @"The SMS verification code used to create the phone auth credential is invalid. Please resend "
  300|       |    "the verification code SMS and be sure to use the verification code provided by the user.";
  301|       |
  302|       |/** @var kFIRAuthErrorMessageMissingVerificationID
  303|       |    @brief Message for @c FIRAuthErrorCodeInvalidVerificationID error code.
  304|       | */
  305|       |static NSString *const kFIRAuthErrorMessageMissingVerificationID =
  306|       |    @"The phone auth credential was created with an empty verification ID.";
  307|       |
  308|       |/** @var kFIRAuthErrorMessageInvalidVerificationID
  309|       |    @brief Message for @c FIRAuthErrorCodeInvalidVerificationID error code.
  310|       | */
  311|       |static NSString *const kFIRAuthErrorMessageInvalidVerificationID =
  312|       |    @"The verification ID used to create the phone auth credential is invalid.";
  313|       |
  314|       |/** @var kFIRAuthErrorMessageLocalPlayerNotAuthenticated
  315|       | @brief Message for @c FIRAuthErrorCodeLocalPlayerNotAuthenticated error code.
  316|       | */
  317|       |static NSString *const kFIRAuthErrorMessageLocalPlayerNotAuthenticated =
  318|       |    @"The local player is not authenticated. Please log the local player in to Game Center.";
  319|       |
  320|       |/** @var kFIRAuthErrorMessageSessionExpired
  321|       |    @brief Message for @c FIRAuthErrorCodeSessionExpired error code.
  322|       | */
  323|       |static NSString *const kFIRAuthErrorMessageSessionExpired = @"The SMS code has expired. Please "
  324|       |    @"re-send the verification code to try again.";
  325|       |
  326|       |/** @var kFIRAuthErrorMessageMissingAppCredential
  327|       |    @brief Message for @c FIRAuthErrorCodeMissingAppCredential error code.
  328|       | */
  329|       |static NSString *const kFIRAuthErrorMessageMissingAppCredential = @"The phone verification request "
  330|       |    "is missing an APNs Device token. Firebase Auth automatically detects APNs Device Tokens, "
  331|       |    "however, if method swizzling is disabled, the APNs token must be set via the APNSToken "
  332|       |    "property on FIRAuth or by calling setAPNSToken:type on FIRAuth.";
  333|       |
  334|       |/** @var kFIRAuthErrorMessageInvalidAppCredential
  335|       |    @brief Message for @c FIRAuthErrorCodeInvalidAppCredential error code.
  336|       | */
  337|       |static NSString *const kFIRAuthErrorMessageInvalidAppCredential = @"The APNs device token provided "
  338|       |    "is either incorrect or does not match the private certificate uploaded to the Firebase "
  339|       |    "Console.";
  340|       |
  341|       |/** @var kFIRAuthErrorMessageQuotaExceeded
  342|       |    @brief Message for @c FIRAuthErrorCodeQuotaExceeded error code.
  343|       | */
  344|       |static NSString *const kFIRAuthErrorMessageQuotaExceeded = @"The phone verification quota for this "
  345|       |    "project has been exceeded.";
  346|       |
  347|       |/** @var kFIRAuthErrorMessageMissingAppToken
  348|       |    @brief Message for @c FIRAuthErrorCodeMissingAppToken error code.
  349|       | */
  350|       |static NSString *const kFIRAuthErrorMessageMissingAppToken = @"There seems to be a problem with "
  351|       |    "your project's Firebase phone number authentication set-up, please make sure to follow the "
  352|       |    "instructions found at https://firebase.google.com/docs/auth/ios/phone-auth";
  353|       |
  354|       |/** @var kFIRAuthErrorMessageMissingAppToken
  355|       |    @brief Message for @c FIRAuthErrorCodeMissingAppToken error code.
  356|       | */
  357|       |static NSString *const kFIRAuthErrorMessageNotificationNotForwarded = @"If app delegate swizzling "
  358|       |    "is disabled, remote notifications received by UIApplicationDelegate need to be forwarded to "
  359|       |    "FIRAuth's canHandleNotificaton: method.";
  360|       |
  361|       |/** @var kFIRAuthErrorMessageAppNotVerified
  362|       |    @brief Message for @c FIRAuthErrorCodeMissingAppToken error code.
  363|       | */
  364|       |static NSString *const kFIRAuthErrorMessageAppNotVerified = @"Firebase could not retrieve the "
  365|       |    "silent push notification and therefore could not verify your app. Ensure that you configured "
  366|       |    "your app correctly to receive push notifications.";
  367|       |
  368|       |/** @var kFIRAuthErrorMessageCaptchaCheckFailed
  369|       |    @brief Message for @c FIRAuthErrorCodeCaptchaCheckFailed error code.
  370|       | */
  371|       |static NSString *const kFIRAuthErrorMessageCaptchaCheckFailed = @"The reCAPTCHA response token "
  372|       |    "provided is either invalid, expired or already";
  373|       |
  374|       |/** @var kFIRAuthErrorMessageWebContextAlreadyPresented
  375|       |    @brief Message for @c FIRAuthErrorCodeWebContextAlreadyPresented error code.
  376|       | */
  377|       |static NSString *const kFIRAuthErrorMessageWebContextAlreadyPresented = @"User interaction is "
  378|       |    "still ongoing, another view cannot be presented.";
  379|       |
  380|       |/** @var kFIRAuthErrorMessageWebContextCancelled
  381|       |    @brief Message for @c FIRAuthErrorCodeWebContextCancelled error code.
  382|       | */
  383|       |static NSString *const kFIRAuthErrorMessageWebContextCancelled = @"The interaction was cancelled "
  384|       |    "by the user.";
  385|       |
  386|       |/** @var kFIRAuthErrorMessageInvalidClientID
  387|       |    @brief Message for @c FIRAuthErrorCodeInvalidClientID error code.
  388|       | */
  389|       |static NSString *const kFIRAuthErrorMessageInvalidClientID = @"The OAuth client ID provided is "
  390|       |    "either invalid or does not match the specified API key.";
  391|       |
  392|       |/** @var kFIRAuthErrorMessageWebRequestFailed
  393|       |    @brief Message for @c FIRAuthErrorCodeWebRequestFailed error code.
  394|       | */
  395|       |static NSString *const kFIRAuthErrorMessageWebRequestFailed = @"A network error (such as timeout, "
  396|       |    "interrupted connection, or unreachable host) has occurred within the web context.";
  397|       |
  398|       |/** @var kFIRAuthErrorMessageWebInternalError
  399|       |    @brief Message for @c FIRAuthErrorCodeWebInternalError error code.
  400|       | */
  401|       |static NSString *const kFIRAuthErrorMessageWebInternalError = @"An internal error has occurred "
  402|       |    "within the SFSafariViewController or UIWebView.";
  403|       |
  404|       |/** @var kFIRAuthErrorMessageAppVerificationUserInteractionFailure
  405|       |    @brief Message for @c FIRAuthErrorCodeInvalidClientID error code.
  406|       | */
  407|       |static NSString *const kFIRAuthErrorMessageAppVerificationUserInteractionFailure = @"The app "
  408|       |  "verification process has failed, print and inspect the error details for more information";
  409|       |
  410|       |/** @var kFIRAuthErrorMessageNullUser
  411|       |    @brief Message for @c FIRAuthErrorCodeNullUser error code.
  412|       | */
  413|       |static NSString *const kFIRAuthErrorMessageNullUser = @"A null user object was provided as the "
  414|       |    "argument for an operation which requires a non-null user object.";
  415|       |
  416|       |/** @var kFIRAuthErrorMessageInvalidDynamicLinkDomain
  417|       |    @brief Message for @c kFIRAuthErrorMessageInvalidDynamicLinkDomain error code.
  418|       | */
  419|       |static NSString *const kFIRAuthErrorMessageInvalidDynamicLinkDomain = @"The "
  420|       |    "Firebase Dynamic Link domain used is either not configured or is unauthorized "
  421|       |    "for the current project.";
  422|       |
  423|       |/** @var kFIRAuthErrorMessageInternalError
  424|       |    @brief Message for @c FIRAuthErrorCodeInternalError error code.
  425|       | */
  426|       |static NSString *const kFIRAuthErrorMessageInternalError = @"An internal error has occurred, "
  427|       |    "print and inspect the error details for more information.";
  428|       |
  429|       |/** @var kFIRAuthErrorMessageMalformedJWT
  430|       |    @brief Error message constant describing @c FIRAuthErrorCodeMalformedJWT errors.
  431|       | */
  432|       |static NSString *const kFIRAuthErrorMessageMalformedJWT =
  433|       |    @"Failed to parse JWT. Check the userInfo dictionary for the full token.";
  434|       |
  435|       |/** @var FIRAuthErrorDescription
  436|       |    @brief The error descrioption, based on the error code.
  437|       |    @remarks No default case so that we get a compiler warning if a new value was added to the enum.
  438|       | */
  439|      0|static NSString *FIRAuthErrorDescription(FIRAuthErrorCode code) {
  440|      0|  switch (code) {
  441|      0|    case FIRAuthErrorCodeInvalidCustomToken:
  442|      0|      return kFIRAuthErrorMessageInvalidCustomToken;
  443|      0|    case FIRAuthErrorCodeCustomTokenMismatch:
  444|      0|      return kFIRAuthErrorMessageCustomTokenMismatch;
  445|      0|    case FIRAuthErrorCodeInvalidEmail:
  446|      0|      return kFIRAuthErrorMessageInvalidEmail;
  447|      0|    case FIRAuthErrorCodeInvalidCredential:
  448|      0|      return kFIRAuthErrorMessageInvalidCredential;
  449|      0|    case FIRAuthErrorCodeUserDisabled:
  450|      0|      return kFIRAuthErrorMessageUserDisabled;
  451|      0|    case FIRAuthErrorCodeEmailAlreadyInUse:
  452|      0|      return kFIRAuthErrorMessageEmailAlreadyInUse;
  453|      0|    case FIRAuthErrorCodeWrongPassword:
  454|      0|      return kFIRAuthErrorMessageWrongPassword;
  455|      0|    case FIRAuthErrorCodeTooManyRequests:
  456|      0|      return kFIRAuthErrorMessageTooManyRequests;
  457|      0|    case FIRAuthErrorCodeAccountExistsWithDifferentCredential:
  458|      0|      return kFIRAuthErrorMessageAccountExistsWithDifferentCredential;
  459|      0|    case FIRAuthErrorCodeRequiresRecentLogin:
  460|      0|      return kFIRAuthErrorMessageRequiresRecentLogin;
  461|      0|    case FIRAuthErrorCodeProviderAlreadyLinked:
  462|      0|      return kFIRAuthErrorMessageProviderAlreadyLinked;
  463|      0|    case FIRAuthErrorCodeNoSuchProvider:
  464|      0|      return kFIRAuthErrorMessageNoSuchProvider;
  465|      0|    case FIRAuthErrorCodeInvalidUserToken:
  466|      0|      return kFIRAuthErrorMessageInvalidUserToken;
  467|      0|    case FIRAuthErrorCodeNetworkError:
  468|      0|      return kFIRAuthErrorMessageNetworkError;
  469|      0|    case FIRAuthErrorCodeKeychainError:
  470|      0|      return kFIRAuthErrorMessageKeychainError;
  471|      0|    case FIRAuthErrorCodeUserTokenExpired:
  472|      0|      return kFIRAuthErrorMessageUserTokenExpired;
  473|      0|    case FIRAuthErrorCodeUserNotFound:
  474|      0|      return kFIRAuthErrorMessageUserNotFound;
  475|      0|    case FIRAuthErrorCodeInvalidAPIKey:
  476|      0|      return kFIRAuthErrorMessageInvalidAPIKey;
  477|      0|    case FIRAuthErrorCodeCredentialAlreadyInUse:
  478|      0|      return kFIRAuthErrorMessageCredentialAlreadyInUse;
  479|      0|    case FIRAuthErrorCodeInternalError:
  480|      0|      return kFIRAuthErrorMessageInternalError;
  481|      0|    case FIRAuthErrorCodeUserMismatch:
  482|      0|      return FIRAuthErrorMessageUserMismatch;
  483|      0|    case FIRAuthErrorCodeOperationNotAllowed:
  484|      0|      return kFIRAuthErrorMessageOperationNotAllowed;
  485|      0|    case FIRAuthErrorCodeWeakPassword:
  486|      0|      return kFIRAuthErrorMessageWeakPassword;
  487|      0|    case FIRAuthErrorCodeAppNotAuthorized:
  488|      0|      return kFIRAuthErrorMessageAppNotAuthorized;
  489|      0|    case FIRAuthErrorCodeExpiredActionCode:
  490|      0|      return kFIRAuthErrorMessageExpiredActionCode;
  491|      0|    case FIRAuthErrorCodeInvalidActionCode:
  492|      0|      return kFIRAuthErrorMessageInvalidActionCode;
  493|      0|    case FIRAuthErrorCodeInvalidSender:
  494|      0|      return kFIRAuthErrorMessageInvalidSender;
  495|      0|    case FIRAuthErrorCodeInvalidMessagePayload:
  496|      0|      return kFIRAuthErrorMessageInvalidMessagePayload;
  497|      0|    case FIRAuthErrorCodeInvalidRecipientEmail:
  498|      0|      return kFIRAuthErrorMessageInvalidRecipientEmail;
  499|      0|    case FIRAuthErrorCodeMissingIosBundleID:
  500|      0|      return kFIRAuthErrorMessageMissingIosBundleID;
  501|      0|    case FIRAuthErrorCodeMissingAndroidPackageName:
  502|      0|      return kFIRAuthErrorMessageMissingAndroidPackageName;
  503|      0|    case FIRAuthErrorCodeUnauthorizedDomain:
  504|      0|      return kFIRAuthErrorMessageUnauthorizedDomain;
  505|      0|    case FIRAuthErrorCodeInvalidContinueURI:
  506|      0|      return kFIRAuthErrorMessageInvalidContinueURI;
  507|      0|    case FIRAuthErrorCodeMissingContinueURI:
  508|      0|      return kFIRAuthErrorMessageMissingContinueURI;
  509|      0|    case FIRAuthErrorCodeMissingEmail:
  510|      0|      return kFIRAuthErrorMessageMissingEmail;
  511|      0|    case FIRAuthErrorCodeMissingPhoneNumber:
  512|      0|      return kFIRAuthErrorMessageMissingPhoneNumber;
  513|      0|    case FIRAuthErrorCodeInvalidPhoneNumber:
  514|      0|      return kFIRAuthErrorMessageInvalidPhoneNumber;
  515|      0|    case FIRAuthErrorCodeMissingVerificationCode:
  516|      0|      return kFIRAuthErrorMessageMissingVerificationCode;
  517|      0|    case FIRAuthErrorCodeInvalidVerificationCode:
  518|      0|      return kFIRAuthErrorMessageInvalidVerificationCode;
  519|      0|    case FIRAuthErrorCodeMissingVerificationID:
  520|      0|      return kFIRAuthErrorMessageMissingVerificationID;
  521|      0|    case FIRAuthErrorCodeInvalidVerificationID:
  522|      0|      return kFIRAuthErrorMessageInvalidVerificationID;
  523|      0|    case FIRAuthErrorCodeSessionExpired:
  524|      0|      return kFIRAuthErrorMessageSessionExpired;
  525|      0|    case FIRAuthErrorCodeMissingAppCredential:
  526|      0|      return kFIRAuthErrorMessageMissingAppCredential;
  527|      0|    case FIRAuthErrorCodeInvalidAppCredential:
  528|      0|      return kFIRAuthErrorMessageInvalidAppCredential;
  529|      0|    case FIRAuthErrorCodeQuotaExceeded:
  530|      0|      return kFIRAuthErrorMessageQuotaExceeded;
  531|      0|    case FIRAuthErrorCodeMissingAppToken:
  532|      0|      return kFIRAuthErrorMessageMissingAppToken;
  533|      0|    case FIRAuthErrorCodeNotificationNotForwarded:
  534|      0|      return kFIRAuthErrorMessageNotificationNotForwarded;
  535|      0|    case FIRAuthErrorCodeAppNotVerified:
  536|      0|      return kFIRAuthErrorMessageAppNotVerified;
  537|      0|    case FIRAuthErrorCodeCaptchaCheckFailed:
  538|      0|      return kFIRAuthErrorMessageCaptchaCheckFailed;
  539|      0|    case FIRAuthErrorCodeWebContextAlreadyPresented:
  540|      0|      return kFIRAuthErrorMessageWebContextAlreadyPresented;
  541|      0|    case FIRAuthErrorCodeWebContextCancelled:
  542|      0|      return kFIRAuthErrorMessageWebContextCancelled;
  543|      0|    case FIRAuthErrorCodeInvalidClientID:
  544|      0|      return kFIRAuthErrorMessageInvalidClientID;
  545|      0|    case FIRAuthErrorCodeAppVerificationUserInteractionFailure:
  546|      0|      return kFIRAuthErrorMessageAppVerificationUserInteractionFailure;
  547|      0|    case FIRAuthErrorCodeWebNetworkRequestFailed:
  548|      0|      return kFIRAuthErrorMessageWebRequestFailed;
  549|      0|    case FIRAuthErrorCodeNullUser:
  550|      0|      return kFIRAuthErrorMessageNullUser;
  551|      0|    case FIRAuthErrorCodeInvalidDynamicLinkDomain:
  552|      0|      return kFIRAuthErrorMessageInvalidDynamicLinkDomain;
  553|      0|    case FIRAuthErrorCodeWebInternalError:
  554|      0|      return kFIRAuthErrorMessageWebInternalError;
  555|      0|    case FIRAuthErrorCodeMalformedJWT:
  556|      0|      return kFIRAuthErrorMessageMalformedJWT;
  557|      0|    case FIRAuthErrorCodeLocalPlayerNotAuthenticated:
  558|      0|      return kFIRAuthErrorMessageLocalPlayerNotAuthenticated;
  559|      0|  }
  560|      0|}
  561|       |
  562|       |/** @var FIRAuthErrorCodeString
  563|       |    @brief The the error short string, based on the error code.
  564|       |    @remarks No default case so that we get a compiler warning if a new value was added to the enum.
  565|       | */
  566|      0|static NSString *const FIRAuthErrorCodeString(FIRAuthErrorCode code) {
  567|      0|  switch (code) {
  568|      0|    case FIRAuthErrorCodeInvalidCustomToken:
  569|      0|      return @"ERROR_INVALID_CUSTOM_TOKEN";
  570|      0|    case FIRAuthErrorCodeCustomTokenMismatch:
  571|      0|      return @"ERROR_CUSTOM_TOKEN_MISMATCH";
  572|      0|    case FIRAuthErrorCodeInvalidEmail:
  573|      0|      return @"ERROR_INVALID_EMAIL";
  574|      0|    case FIRAuthErrorCodeInvalidCredential:
  575|      0|      return @"ERROR_INVALID_CREDENTIAL";
  576|      0|    case FIRAuthErrorCodeUserDisabled:
  577|      0|      return @"ERROR_USER_DISABLED";
  578|      0|    case FIRAuthErrorCodeEmailAlreadyInUse:
  579|      0|      return @"ERROR_EMAIL_ALREADY_IN_USE";
  580|      0|    case FIRAuthErrorCodeWrongPassword:
  581|      0|      return @"ERROR_WRONG_PASSWORD";
  582|      0|    case FIRAuthErrorCodeTooManyRequests:
  583|      0|      return @"ERROR_TOO_MANY_REQUESTS";
  584|      0|    case FIRAuthErrorCodeAccountExistsWithDifferentCredential:
  585|      0|      return @"ERROR_ACCOUNT_EXISTS_WITH_DIFFERENT_CREDENTIAL";
  586|      0|    case FIRAuthErrorCodeRequiresRecentLogin:
  587|      0|      return @"ERROR_REQUIRES_RECENT_LOGIN";
  588|      0|    case FIRAuthErrorCodeProviderAlreadyLinked:
  589|      0|      return @"ERROR_PROVIDER_ALREADY_LINKED";
  590|      0|    case FIRAuthErrorCodeNoSuchProvider:
  591|      0|      return @"ERROR_NO_SUCH_PROVIDER";
  592|      0|    case FIRAuthErrorCodeInvalidUserToken:
  593|      0|      return @"ERROR_INVALID_USER_TOKEN";
  594|      0|    case FIRAuthErrorCodeNetworkError:
  595|      0|      return @"ERROR_NETWORK_REQUEST_FAILED";
  596|      0|    case FIRAuthErrorCodeKeychainError:
  597|      0|      return @"ERROR_KEYCHAIN_ERROR";
  598|      0|    case FIRAuthErrorCodeUserTokenExpired:
  599|      0|      return @"ERROR_USER_TOKEN_EXPIRED";
  600|      0|    case FIRAuthErrorCodeUserNotFound:
  601|      0|      return @"ERROR_USER_NOT_FOUND";
  602|      0|    case FIRAuthErrorCodeInvalidAPIKey:
  603|      0|      return @"ERROR_INVALID_API_KEY";
  604|      0|    case FIRAuthErrorCodeCredentialAlreadyInUse:
  605|      0|      return @"ERROR_CREDENTIAL_ALREADY_IN_USE";
  606|      0|    case FIRAuthErrorCodeInternalError:
  607|      0|      return @"ERROR_INTERNAL_ERROR";
  608|      0|    case FIRAuthErrorCodeUserMismatch:
  609|      0|      return @"ERROR_USER_MISMATCH";
  610|      0|    case FIRAuthErrorCodeOperationNotAllowed:
  611|      0|      return @"ERROR_OPERATION_NOT_ALLOWED";
  612|      0|    case FIRAuthErrorCodeWeakPassword:
  613|      0|      return @"ERROR_WEAK_PASSWORD";
  614|      0|    case FIRAuthErrorCodeAppNotAuthorized:
  615|      0|      return @"ERROR_APP_NOT_AUTHORIZED";
  616|      0|    case FIRAuthErrorCodeExpiredActionCode:
  617|      0|      return @"ERROR_EXPIRED_ACTION_CODE";
  618|      0|    case FIRAuthErrorCodeInvalidActionCode:
  619|      0|      return @"ERROR_INVALID_ACTION_CODE";
  620|      0|    case FIRAuthErrorCodeInvalidMessagePayload:
  621|      0|      return @"ERROR_INVALID_MESSAGE_PAYLOAD";
  622|      0|    case FIRAuthErrorCodeInvalidSender:
  623|      0|      return @"ERROR_INVALID_SENDER";
  624|      0|    case FIRAuthErrorCodeInvalidRecipientEmail:
  625|      0|      return @"ERROR_INVALID_RECIPIENT_EMAIL";
  626|      0|    case FIRAuthErrorCodeMissingIosBundleID:
  627|      0|      return @"ERROR_MISSING_IOS_BUNDLE_ID";
  628|      0|    case FIRAuthErrorCodeMissingAndroidPackageName:
  629|      0|      return @"ERROR_MISSING_ANDROID_PKG_NAME";
  630|      0|    case FIRAuthErrorCodeUnauthorizedDomain:
  631|      0|      return @"ERROR_UNAUTHORIZED_DOMAIN";
  632|      0|    case FIRAuthErrorCodeInvalidContinueURI:
  633|      0|      return @"ERROR_INVALID_CONTINUE_URI";
  634|      0|    case FIRAuthErrorCodeMissingContinueURI:
  635|      0|      return @"ERROR_MISSING_CONTINUE_URI";
  636|      0|    case FIRAuthErrorCodeMissingEmail:
  637|      0|      return @"ERROR_MISSING_EMAIL";
  638|      0|    case FIRAuthErrorCodeMissingPhoneNumber:
  639|      0|      return @"ERROR_MISSING_PHONE_NUMBER";
  640|      0|    case FIRAuthErrorCodeInvalidPhoneNumber:
  641|      0|      return @"ERROR_INVALID_PHONE_NUMBER";
  642|      0|    case FIRAuthErrorCodeMissingVerificationCode:
  643|      0|      return @"ERROR_MISSING_VERIFICATION_CODE";
  644|      0|    case FIRAuthErrorCodeInvalidVerificationCode:
  645|      0|      return @"ERROR_INVALID_VERIFICATION_CODE";
  646|      0|    case FIRAuthErrorCodeMissingVerificationID:
  647|      0|      return @"ERROR_MISSING_VERIFICATION_ID";
  648|      0|    case FIRAuthErrorCodeInvalidVerificationID:
  649|      0|      return @"ERROR_INVALID_VERIFICATION_ID";
  650|      0|    case FIRAuthErrorCodeSessionExpired:
  651|      0|      return @"ERROR_SESSION_EXPIRED";
  652|      0|    case FIRAuthErrorCodeMissingAppCredential:
  653|      0|      return @"MISSING_APP_CREDENTIAL";
  654|      0|    case FIRAuthErrorCodeInvalidAppCredential:
  655|      0|      return @"INVALID_APP_CREDENTIAL";
  656|      0|    case FIRAuthErrorCodeQuotaExceeded:
  657|      0|      return @"ERROR_QUOTA_EXCEEDED";
  658|      0|    case FIRAuthErrorCodeMissingAppToken:
  659|      0|      return @"ERROR_MISSING_APP_TOKEN";
  660|      0|    case FIRAuthErrorCodeNotificationNotForwarded:
  661|      0|      return @"ERROR_NOTIFICATION_NOT_FORWARDED";
  662|      0|    case FIRAuthErrorCodeAppNotVerified:
  663|      0|      return @"ERROR_APP_NOT_VERIFIED";
  664|      0|    case FIRAuthErrorCodeCaptchaCheckFailed:
  665|      0|      return @"ERROR_CAPTCHA_CHECK_FAILED";
  666|      0|    case FIRAuthErrorCodeWebContextAlreadyPresented:
  667|      0|      return @"ERROR_WEB_CONTEXT_ALREADY_PRESENTED";
  668|      0|    case FIRAuthErrorCodeWebContextCancelled:
  669|      0|      return @"ERROR_WEB_CONTEXT_CANCELLED";
  670|      0|    case FIRAuthErrorCodeInvalidClientID:
  671|      0|      return @"ERROR_INVALID_CLIENT_ID";
  672|      0|    case FIRAuthErrorCodeAppVerificationUserInteractionFailure:
  673|      0|      return @"ERROR_APP_VERIFICATION_FAILED";
  674|      0|    case FIRAuthErrorCodeWebNetworkRequestFailed:
  675|      0|      return @"ERROR_WEB_NETWORK_REQUEST_FAILED";
  676|      0|    case FIRAuthErrorCodeNullUser:
  677|      0|      return @"ERROR_NULL_USER";
  678|      0|    case FIRAuthErrorCodeInvalidDynamicLinkDomain:
  679|      0|      return @"ERROR_INVALID_DYNAMIC_LINK_DOMAIN";
  680|      0|    case FIRAuthErrorCodeWebInternalError:
  681|      0|      return @"ERROR_WEB_INTERNAL_ERROR";
  682|      0|    case FIRAuthErrorCodeMalformedJWT:
  683|      0|      return @"ERROR_MALFORMED_JWT";
  684|      0|    case FIRAuthErrorCodeLocalPlayerNotAuthenticated:
  685|      0|      return @"ERROR_LOCAL_PLAYER_NOT_AUTHENTICATED";
  686|      0|  }
  687|      0|}
  688|       |
  689|       |@implementation FIRAuthErrorUtils
  690|       |
  691|      0|+ (NSError *)errorWithCode:(FIRAuthInternalErrorCode)code {
  692|      0|  return [self errorWithCode:code message:nil];
  693|      0|}
  694|       |
  695|       |+ (NSError *)errorWithCode:(FIRAuthInternalErrorCode)code
  696|      0|                   message:(nullable NSString *)message {
  697|      0|  NSDictionary *userInfo = nil;
  698|      0|  if (message.length) {
  699|      0|    userInfo = @{
  700|      0|      NSLocalizedDescriptionKey : message
  701|      0|    };
  702|      0|  }
  703|      0|  return [self errorWithCode:code userInfo:userInfo];
  704|      0|}
  705|       |
  706|       |+ (NSError *)errorWithCode:(FIRAuthInternalErrorCode)code
  707|      0|           underlyingError:(nullable NSError *)underlyingError {
  708|      0|  NSDictionary *errorUserInfo = nil;
  709|      0|  if (underlyingError) {
  710|      0|    errorUserInfo = @{
  711|      0|      NSUnderlyingErrorKey : underlyingError
  712|      0|    };
  713|      0|  }
  714|      0|  return [self errorWithCode:code userInfo:errorUserInfo];
  715|      0|}
  716|       |
  717|       |+ (NSError *)errorWithCode:(FIRAuthInternalErrorCode)code
  718|      0|                  userInfo:(nullable NSDictionary *)userInfo {
  719|      0|  BOOL isPublic = (code & FIRAuthPublicErrorCodeFlag) == FIRAuthPublicErrorCodeFlag;
  720|      0|  if (isPublic) {
  721|      0|    // This is a public error. Return it as a public error and add a description.
  722|      0|    NSInteger errorCode = code & ~FIRAuthPublicErrorCodeFlag;
  723|      0|    NSMutableDictionary *errorUserInfo = [NSMutableDictionary dictionaryWithDictionary:userInfo];
  724|      0|    if (!errorUserInfo[NSLocalizedDescriptionKey]) {
  725|      0|      errorUserInfo[NSLocalizedDescriptionKey] = FIRAuthErrorDescription(errorCode);
  726|      0|    }
  727|      0|    errorUserInfo[FIRAuthErrorNameKey] = FIRAuthErrorCodeString(errorCode);
  728|      0|    return [NSError errorWithDomain:FIRAuthErrorDomain code:errorCode userInfo:errorUserInfo];
  729|      0|  } else {
  730|      0|    // This is an internal error. Wrap it in an internal error.
  731|      0|    NSError *error =
  732|      0|        [NSError errorWithDomain:FIRAuthInternalErrorDomain code:code userInfo:userInfo];
  733|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeInternalError underlyingError:error];
  734|      0|  }
  735|      0|}
  736|       |
  737|      0|+ (NSError *)RPCRequestEncodingErrorWithUnderlyingError:(NSError *)underlyingError {
  738|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeRPCRequestEncodingError
  739|      0|             underlyingError:underlyingError];
  740|      0|}
  741|       |
  742|      0|+ (NSError *)JSONSerializationErrorForUnencodableType {
  743|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeJSONSerializationError];
  744|      0|}
  745|       |
  746|      0|+ (NSError *)JSONSerializationErrorWithUnderlyingError:(NSError *)underlyingError {
  747|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeJSONSerializationError
  748|      0|             underlyingError:underlyingError];
  749|      0|}
  750|       |
  751|      0|+ (NSError *)networkErrorWithUnderlyingError:(NSError *)underlyingError {
  752|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeNetworkError
  753|      0|             underlyingError:underlyingError];
  754|      0|}
  755|       |
  756|       |+ (NSError *)unexpectedErrorResponseWithData:(NSData *)data
  757|      0|                             underlyingError:(NSError *)underlyingError {
  758|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedErrorResponse userInfo:@{
  759|      0|    FIRAuthErrorUserInfoDataKey : data,
  760|      0|    NSUnderlyingErrorKey : underlyingError
  761|      0|  }];
  762|      0|}
  763|       |
  764|      0|+ (NSError *)unexpectedErrorResponseWithDeserializedResponse:(id)deserializedResponse {
  765|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedErrorResponse userInfo:@{
  766|      0|    FIRAuthErrorUserInfoDeserializedResponseKey : deserializedResponse
  767|      0|  }];
  768|      0|}
  769|       |
  770|       |+ (NSError *)malformedJWTErrorWithToken:(NSString *)token
  771|      0|                        underlyingError:(NSError *_Nullable)underlyingError {
  772|      0|  NSMutableDictionary *userInfo =
  773|      0|      [NSMutableDictionary dictionaryWithObject:kFIRAuthErrorMessageMalformedJWT
  774|      0|                                         forKey:NSLocalizedDescriptionKey];
  775|      0|  [userInfo setObject:token forKey:FIRAuthErrorUserInfoDataKey];
  776|      0|  if (underlyingError != nil) {
  777|      0|    [userInfo setObject:underlyingError forKey:NSUnderlyingErrorKey];
  778|      0|  }
  779|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMalformedJWT userInfo:[userInfo copy]];
  780|      0|}
  781|       |
  782|       |+ (NSError *)unexpectedResponseWithData:(NSData *)data
  783|      0|                        underlyingError:(NSError *)underlyingError {
  784|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedResponse userInfo:@{
  785|      0|    FIRAuthErrorUserInfoDataKey : data,
  786|      0|    NSUnderlyingErrorKey : underlyingError
  787|      0|  }];
  788|      0|}
  789|       |
  790|      0|+ (NSError *)unexpectedResponseWithDeserializedResponse:(id)deserializedResponse {
  791|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedResponse userInfo:@{
  792|      0|    FIRAuthErrorUserInfoDeserializedResponseKey : deserializedResponse
  793|      0|  }];
  794|      0|}
  795|       |
  796|       |+ (NSError *)unexpectedResponseWithDeserializedResponse:(nullable id)deserializedResponse
  797|      0|                                        underlyingError:(NSError *)underlyingError {
  798|      0|  NSMutableDictionary *userInfo =
  799|      0|      [NSMutableDictionary dictionaryWithDictionary:@{ NSUnderlyingErrorKey : underlyingError }];
  800|      0|  if (deserializedResponse) {
  801|      0|    userInfo[FIRAuthErrorUserInfoDeserializedResponseKey] = deserializedResponse;
  802|      0|  }
  803|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnexpectedResponse userInfo:userInfo];
  804|      0|}
  805|       |
  806|       |+ (NSError *)RPCResponseDecodingErrorWithDeserializedResponse:(id)deserializedResponse
  807|      0|                                              underlyingError:(NSError *)underlyingError {
  808|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeRPCResponseDecodingError userInfo:@{
  809|      0|    FIRAuthErrorUserInfoDeserializedResponseKey : deserializedResponse,
  810|      0|    NSUnderlyingErrorKey : underlyingError
  811|      0|  }];
  812|      0|}
  813|       |
  814|      0|+ (NSError *)emailAlreadyInUseErrorWithEmail:(nullable NSString *)email {
  815|      0|  NSMutableDictionary *userInfo = [[NSMutableDictionary alloc] init];
  816|      0|  if (email.length) {
  817|      0|    userInfo[FIRAuthErrorUserInfoEmailKey] = email;
  818|      0|  }
  819|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeEmailAlreadyInUse userInfo:userInfo];
  820|      0|}
  821|       |
  822|      0|+ (NSError *)userDisabledErrorWithMessage:(nullable NSString *)message {
  823|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUserDisabled message:message];
  824|      0|}
  825|       |
  826|      0|+ (NSError *)wrongPasswordErrorWithMessage:(nullable NSString *)message {
  827|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWrongPassword message:message];
  828|      0|}
  829|       |
  830|      0|+ (NSError *)tooManyRequestsErrorWithMessage:(nullable NSString *)message {
  831|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeTooManyRequests message:message];
  832|      0|}
  833|       |
  834|      0|+ (NSError *)invalidCustomTokenErrorWithMessage:(nullable NSString *)message {
  835|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidCustomToken message:message];
  836|      0|}
  837|       |
  838|      0|+ (NSError *)customTokenMistmatchErrorWithMessage:(nullable NSString *)message {
  839|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeCustomTokenMismatch message:message];
  840|      0|}
  841|       |
  842|      0|+ (NSError *)invalidCredentialErrorWithMessage:(nullable NSString *)message {
  843|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidCredential message:message];
  844|      0|}
  845|       |
  846|      0|+ (NSError *)requiresRecentLoginErrorWithMessage:(nullable NSString *)message {
  847|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeRequiresRecentLogin message:message];
  848|      0|}
  849|       |
  850|      0|+ (NSError *)invalidUserTokenErrorWithMessage:(nullable NSString *)message {
  851|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidUserToken message:message];
  852|      0|}
  853|       |
  854|      0|+ (NSError *)invalidEmailErrorWithMessage:(nullable NSString *)message {
  855|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidEmail message:message];
  856|      0|}
  857|       |
  858|      0|+ (NSError *)accountExistsWithDifferentCredentialErrorWithEmail:(nullable NSString *)email {
  859|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeAccountExistsWithDifferentCredential
  860|      0|                    userInfo:@{ FIRAuthErrorUserInfoEmailKey : email }];
  861|      0|}
  862|       |
  863|      0|+ (NSError *)providerAlreadyLinkedError {
  864|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeProviderAlreadyLinked];
  865|      0|}
  866|       |
  867|      0|+ (NSError *)noSuchProviderError {
  868|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeNoSuchProvider];
  869|      0|}
  870|       |
  871|      0|+ (NSError *)userTokenExpiredErrorWithMessage:(nullable NSString *)message {
  872|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUserTokenExpired message:message];
  873|      0|}
  874|       |
  875|      0|+ (NSError *)userNotFoundErrorWithMessage:(nullable NSString *)message {
  876|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUserNotFound message:message];
  877|      0|}
  878|       |
  879|      0|+ (NSError *)invalidAPIKeyError {
  880|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidAPIKey];
  881|      0|}
  882|       |
  883|      0|+ (NSError *)userMismatchError {
  884|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUserMismatch];
  885|      0|}
  886|       |
  887|       |+ (NSError *)credentialAlreadyInUseErrorWithMessage:(nullable NSString *)message
  888|      0|                                         credential:(nullable FIRPhoneAuthCredential *)credential {
  889|      0|  if (credential) {
  890|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeCredentialAlreadyInUse
  891|      0|                    userInfo:@{ FIRAuthUpdatedCredentialKey : credential }];
  892|      0|  }
  893|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeCredentialAlreadyInUse message:message];
  894|      0|}
  895|       |
  896|      0|+ (NSError *)operationNotAllowedErrorWithMessage:(nullable NSString *)message {
  897|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeOperationNotAllowed message:message];
  898|      0|}
  899|       |
  900|      0|+ (NSError *)weakPasswordErrorWithServerResponseReason:(nullable NSString *)reason {
  901|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWeakPassword userInfo:@{
  902|      0|    NSLocalizedFailureReasonErrorKey : reason
  903|      0|  }];
  904|      0|}
  905|       |
  906|      0|+ (NSError *)appNotAuthorizedError {
  907|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeAppNotAuthorized];
  908|      0|}
  909|       |
  910|      0|+ (NSError *)expiredActionCodeErrorWithMessage:(nullable NSString *)message {
  911|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeExpiredActionCode message:message];
  912|      0|}
  913|       |
  914|      0|+ (NSError *)invalidActionCodeErrorWithMessage:(nullable NSString *)message {
  915|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidActionCode message:message];
  916|      0|}
  917|       |
  918|      0|+ (NSError *)invalidMessagePayloadErrorWithMessage:(nullable NSString *)message {
  919|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidMessagePayload message:message];
  920|      0|}
  921|       |
  922|      0|+ (NSError *)invalidSenderErrorWithMessage:(nullable NSString *)message {
  923|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidSender message:message];
  924|      0|}
  925|       |
  926|      0|+ (NSError *)invalidRecipientEmailErrorWithMessage:(nullable NSString *)message {
  927|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidRecipientEmail message:message];
  928|      0|}
  929|       |
  930|      0|+ (NSError *)missingIosBundleIDErrorWithMessage:(nullable NSString *)message {
  931|      0|  return [self errorWithCode:FIRAuthinternalErrorCodeMissingIosBundleID message:message];
  932|      0|}
  933|       |
  934|      0|+ (NSError *)missingAndroidPackageNameErrorWithMessage:(nullable NSString *)message {
  935|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingAndroidPackageName message:message];
  936|      0|}
  937|       |
  938|      0|+ (NSError *)unauthorizedDomainErrorWithMessage:(nullable NSString *)message {
  939|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeUnauthorizedDomain message:message];
  940|      0|}
  941|       |
  942|      0|+ (NSError *)invalidContinueURIErrorWithMessage:(nullable NSString *)message {
  943|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidContinueURI message:message];
  944|      0|}
  945|       |
  946|      0|+ (NSError *)missingContinueURIErrorWithMessage:(nullable NSString *)message {
  947|      0|  return[self errorWithCode:FIRAuthInternalErrorCodeMissingContinueURI message:message];
  948|      0|}
  949|       |
  950|      0|+ (NSError *)missingEmailErrorWithMessage:(nullable NSString *)message {
  951|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingEmail message:message];
  952|      0|}
  953|       |
  954|      0|+ (NSError *)missingPhoneNumberErrorWithMessage:(nullable NSString *)message {
  955|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingPhoneNumber message:message];
  956|      0|}
  957|       |
  958|      0|+ (NSError *)invalidPhoneNumberErrorWithMessage:(nullable NSString *)message {
  959|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidPhoneNumber message:message];
  960|      0|}
  961|       |
  962|      0|+ (NSError *)missingVerificationCodeErrorWithMessage:(nullable NSString *)message {
  963|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingVerificationCode message:message];
  964|      0|}
  965|       |
  966|      0|+ (NSError *)invalidVerificationCodeErrorWithMessage:(nullable NSString *)message {
  967|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidVerificationCode message:message];
  968|      0|}
  969|       |
  970|      0|+ (NSError *)missingVerificationIDErrorWithMessage:(nullable NSString *)message {
  971|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingVerificationID message:message];
  972|      0|}
  973|       |
  974|      0|+ (NSError *)invalidVerificationIDErrorWithMessage:(nullable NSString *)message {
  975|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidVerificationID message:message];
  976|      0|}
  977|       |
  978|      0|+ (NSError *)sessionExpiredErrorWithMessage:(nullable NSString *)message {
  979|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeSessionExpired message:message];
  980|      0|}
  981|       |
  982|      0|+ (NSError *)missingAppCredentialWithMessage:(nullable NSString *)message {
  983|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingAppCredential message:message];
  984|      0|}
  985|       |
  986|      0|+ (NSError *)invalidAppCredentialWithMessage:(nullable NSString *)message {
  987|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidAppCredential message:message];
  988|      0|}
  989|       |
  990|      0|+ (NSError *)quotaExceededErrorWithMessage:(nullable NSString *)message {
  991|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeQuotaExceeded message:message];
  992|      0|}
  993|       |
  994|      0|+ (NSError *)missingAppTokenErrorWithUnderlyingError:(nullable NSError *)underlyingError {
  995|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeMissingAppToken
  996|      0|             underlyingError:underlyingError];
  997|      0|}
  998|       |
  999|      0|+ (NSError *)localPlayerNotAuthenticatedError {
 1000|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeLocalPlayerNotAuthenticated];
 1001|      0|}
 1002|       |
 1003|      0|+ (NSError *)notificationNotForwardedError {
 1004|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeNotificationNotForwarded];
 1005|      0|}
 1006|       |
 1007|      0|+ (NSError *)appNotVerifiedErrorWithMessage:(nullable NSString *)message {
 1008|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeAppNotVerified message:message];
 1009|      0|}
 1010|       |
 1011|      0|+ (NSError *)captchaCheckFailedErrorWithMessage:(nullable NSString *)message {
 1012|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeCaptchaCheckFailed message:message];
 1013|      0|}
 1014|       |
 1015|      0|+ (NSError *)webContextAlreadyPresentedErrorWithMessage:(nullable NSString *)message {
 1016|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWebContextAlreadyPresented message:message];
 1017|      0|}
 1018|       |
 1019|      0|+ (NSError *)webContextCancelledErrorWithMessage:(nullable NSString *)message {
 1020|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeWebContextCancelled message:message];
 1021|      0|}
 1022|       |
 1023|      0|+ (NSError *)appVerificationUserInteractionFailureWithReason:(NSString *)reason {
 1024|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeAppVerificationUserInteractionFailure
 1025|      0|                    userInfo:@{
 1026|      0|    NSLocalizedFailureReasonErrorKey : reason
 1027|      0|  }];
 1028|      0|}
 1029|       |
 1030|      0|+ (nullable NSError *)URLResponseErrorWithCode:(NSString *)code message:(nullable NSString *)message {
 1031|      0|  if ([code isEqualToString:kURLResponseErrorCodeInvalidClientID]) {
 1032|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeInvalidClientID message:message];
 1033|      0|  }
 1034|      0|  if ([code isEqualToString:kURLResponseErrorCodeNetworkRequestFailed]) {
 1035|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeWebNetworkRequestFailed message:message];
 1036|      0|  }
 1037|      0|  if ([code isEqualToString:kURLResponseErrorCodeInternalError]) {
 1038|      0|    return [self errorWithCode:FIRAuthInternalErrorCodeWebInternalError message:message];
 1039|      0|  }
 1040|      0|  return nil;
 1041|      0|}
 1042|       |
 1043|      0|+ (NSError *)nullUserErrorWithMessage:(nullable NSString *)message {
 1044|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeNullUser message:message];
 1045|      0|}
 1046|       |
 1047|      0|+ (NSError *)invalidDynamicLinkDomainErrorWithMessage:(nullable NSString *)message {
 1048|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeInvalidDynamicLinkDomain message:message];
 1049|      0|}
 1050|       |
 1051|      0|+ (NSError *)keychainErrorWithFunction:(NSString *)keychainFunction status:(OSStatus)status {
 1052|      0|  NSString *failureReason = [NSString stringWithFormat:@"%@ (%li)", keychainFunction, (long)status];
 1053|      0|  return [self errorWithCode:FIRAuthInternalErrorCodeKeychainError userInfo:@{
 1054|      0|    NSLocalizedFailureReasonErrorKey : failureReason,
 1055|      0|  }];
 1056|      0|}
 1057|       |
 1058|       |@end
 1059|       |
 1060|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthExceptionUtils.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthExceptionUtils.h"
   18|       |
   19|       |/** @var FIRMethodNotImplementedException
   20|       |    @brief The name of the "Method Not Implemented" exception.
   21|       | */
   22|       |static NSString *const FIRMethodNotImplementedException = @"FIRMethodNotImplementedException";
   23|       |
   24|       |@implementation FIRAuthExceptionUtils
   25|       |
   26|      0|+ (void)raiseInvalidParameterExceptionWithReason:(NSString *)reason {
   27|      0|  [NSException raise:NSInvalidArgumentException format:@"%@", reason];
   28|      0|}
   29|       |
   30|      0|+ (void)raiseMethodNotImplementedExceptionWithReason:(nullable NSString *)reason {
   31|      0|  NSException *exception =
   32|      0|      [NSException exceptionWithName:FIRMethodNotImplementedException reason:reason userInfo:nil];
   33|      0|  [exception raise];
   34|      0|}
   35|       |
   36|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthGlobalWorkQueue.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthGlobalWorkQueue.h"
   18|       |
   19|      1|dispatch_queue_t FIRAuthGlobalWorkQueue() {
   20|      1|  static dispatch_once_t once;
   21|      1|  static dispatch_queue_t queue;
   22|      1|  dispatch_once(&once, ^{
   23|      1|    queue = dispatch_queue_create("com.google.firebase.auth.globalWorkQueue", NULL);
   24|      1|  });
   25|      1|  return queue;
   26|      1|}

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthKeychain.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthKeychain.h"
   18|       |
   19|       |#import <Security/Security.h>
   20|       |
   21|       |#import "FIRAuthErrorUtils.h"
   22|       |#import "FIRAuthUserDefaultsStorage.h"
   23|       |
   24|       |#if FIRAUTH_USER_DEFAULTS_STORAGE_AVAILABLE
   25|       |#import <UIKit/UIKit.h>
   26|       |
   27|       |/** @var kOSVersionMatcherForUsingUserDefaults
   28|       |    @brief The regular expression to match all OS versions that @c FIRAuthUserDefaultsStorage is
   29|       |        used instead if available.
   30|       | */
   31|       |static NSString *const kOSVersionMatcherForUsingUserDefaults = @"^10\\.[01](\\..*)?$";
   32|       |
   33|       |#endif  // FIRAUTH_USER_DEFAULTS_STORAGE_AVAILABLE
   34|       |
   35|       |/** @var kAccountPrefix
   36|       |    @brief The prefix string for keychain item account attribute before the key.
   37|       |    @remarks A number "1" is encoded in the prefix in case we need to upgrade the scheme in future.
   38|       | */
   39|       |static NSString *const kAccountPrefix = @"firebase_auth_1_";
   40|       |
   41|       |@implementation FIRAuthKeychain {
   42|       |  /** @var _service
   43|       |      @brief The name of the keychain service.
   44|       |   */
   45|       |  NSString *_service;
   46|       |
   47|       |  /** @var _legacyItemDeletedForKey
   48|       |      @brief Indicates whether or not this class knows that the legacy item for a particular key has
   49|       |          been deleted.
   50|       |      @remarks This dictionary is to avoid unecessary keychain operations against legacy items.
   51|       |   */
   52|       |  NSMutableDictionary *_legacyEntryDeletedForKey;
   53|       |}
   54|       |
   55|      1|- (id<FIRAuthStorage>)initWithService:(NSString *)service {
   56|      1|
   57|      1|#if FIRAUTH_USER_DEFAULTS_STORAGE_AVAILABLE
   58|      1|
   59|      1|  NSString *OSVersion = [UIDevice currentDevice].systemVersion;
   60|      1|  NSRegularExpression *regex =
   61|      1|      [NSRegularExpression regularExpressionWithPattern:kOSVersionMatcherForUsingUserDefaults
   62|      1|                                                options:0
   63|      1|                                                  error:NULL];
   64|      1|  if ([regex numberOfMatchesInString:OSVersion options:0 range:NSMakeRange(0, OSVersion.length)]) {
   65|      0|    return (id<FIRAuthStorage>)[[FIRAuthUserDefaultsStorage alloc] initWithService:service];
   66|      0|  }
   67|      1|
   68|      1|#endif  // FIRAUTH_USER_DEFAULTS_STORAGE_AVAILABLE
   69|      1|
   70|      1|  self = [super init];
   71|      1|  if (self) {
   72|      1|    _service = [service copy];
   73|      1|    _legacyEntryDeletedForKey = [[NSMutableDictionary alloc] init];
   74|      1|  }
   75|      1|  return self;
   76|      1|}
   77|       |
   78|      2|- (NSData *)dataForKey:(NSString *)key error:(NSError **_Nullable)error {
   79|      2|  if (!key.length) {
   80|      0|    [NSException raise:NSInvalidArgumentException
   81|      0|                format:@"%@", @"The key cannot be nil or empty."];
   82|      0|    return nil;
   83|      0|  }
   84|      2|  NSData *data = [self itemWithQuery:[self genericPasswordQueryWithKey:key] error:error];
   85|      2|  if (error && *error) {
   86|      0|    return nil;
   87|      0|  }
   88|      2|  if (data) {
   89|      0|    return data;
   90|      0|  }
   91|      2|  // Check for legacy form.
   92|      2|  if (_legacyEntryDeletedForKey[key]) {
   93|      0|    return nil;
   94|      0|  }
   95|      2|  data = [self itemWithQuery:[self legacyGenericPasswordQueryWithKey:key] error:error];
   96|      2|  if (error && *error) {
   97|      0|    return nil;
   98|      0|  }
   99|      2|  if (!data) {
  100|      2|    // Mark legacy data as non-existing so we don't have to query it again.
  101|      2|    _legacyEntryDeletedForKey[key] = @YES;
  102|      2|    return nil;
  103|      2|  }
  104|      0|  // Move the data to current form.
  105|      0|  if (![self setData:data forKey:key error:error]) {
  106|      0|    return nil;
  107|      0|  }
  108|      0|  [self deleteLegacyItemWithKey:key];
  109|      0|  return data;
  110|      0|}
  111|       |
  112|      0|- (BOOL)setData:(NSData *)data forKey:(NSString *)key error:(NSError **_Nullable)error {
  113|      0|  if (!key.length) {
  114|      0|    [NSException raise:NSInvalidArgumentException
  115|      0|                format:@"%@", @"The key cannot be nil or empty."];
  116|      0|    return NO;
  117|      0|  }
  118|      0|  NSDictionary *attributes = @{
  119|      0|    (__bridge id)kSecValueData : data,
  120|      0|    (__bridge id)kSecAttrAccessible : (__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly,
  121|      0|  };
  122|      0|  return [self setItemWithQuery:[self genericPasswordQueryWithKey:key]
  123|      0|                     attributes:attributes
  124|      0|                          error:error];
  125|      0|}
  126|       |
  127|      0|- (BOOL)removeDataForKey:(NSString *)key error:(NSError **_Nullable)error {
  128|      0|  if (!key.length) {
  129|      0|    [NSException raise:NSInvalidArgumentException
  130|      0|                format:@"%@", @"The key cannot be nil or empty."];
  131|      0|    return NO;
  132|      0|  }
  133|      0|  if (![self deleteItemWithQuery:[self genericPasswordQueryWithKey:key] error:error]) {
  134|      0|    return NO;
  135|      0|  }
  136|      0|  // Legacy form item, if exists, also needs to be removed, otherwise it will be exposed when
  137|      0|  // current form item is removed, leading to incorrect semantics.
  138|      0|  [self deleteLegacyItemWithKey:key];
  139|      0|  return YES;
  140|      0|}
  141|       |
  142|       |#pragma mark - Private
  143|       |
  144|      4|- (NSData *)itemWithQuery:(NSDictionary *)query error:(NSError **_Nullable)error {
  145|      4|  NSMutableDictionary *returningQuery = [query mutableCopy];
  146|      4|  returningQuery[(__bridge id)kSecReturnData] = @YES;
  147|      4|  returningQuery[(__bridge id)kSecReturnAttributes] = @YES;
  148|      4|  // Using a match limit of 2 means that we can check whether there is more than one item.
  149|      4|  // If we used a match limit of 1 we would never find out.
  150|      4|  returningQuery[(__bridge id)kSecMatchLimit] = @2;
  151|      4|
  152|      4|  CFArrayRef result = NULL;
  153|      4|  OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)returningQuery,
  154|      4|                                        (CFTypeRef *)&result);
  155|      4|
  156|      4|  if (status == noErr && result != NULL) {
  157|      0|   NSArray *items = (__bridge_transfer NSArray *)result;
  158|      0|    if (items.count != 1) {
  159|      0|      if (error) {
  160|      0|        *error = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemCopyMatching"
  161|      0|                                                       status:status];
  162|      0|      }
  163|      0|      return nil;
  164|      0|    }
  165|      0|
  166|      0|    if (error) {
  167|      0|      *error = nil;
  168|      0|    }
  169|      0|    NSDictionary *item = items[0];
  170|      0|    return item[(__bridge id)kSecValueData];
  171|      0|  }
  172|      4|
  173|      4|  if (status == errSecItemNotFound) {
  174|      4|    if (error) {
  175|      4|      *error = nil;
  176|      4|    }
  177|      4|  } else {
  178|      0|    if (error) {
  179|      0|      *error = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemCopyMatching" status:status];
  180|      0|    }
  181|      0|  }
  182|      4|  return nil;
  183|      4|}
  184|       |
  185|       |- (BOOL)setItemWithQuery:(NSDictionary *)query
  186|       |              attributes:(NSDictionary *)attributes
  187|      0|                   error:(NSError **_Nullable)error {
  188|      0|  NSMutableDictionary *combined = [attributes mutableCopy];
  189|      0|  [combined addEntriesFromDictionary:query];
  190|      0|  BOOL hasItem = NO;
  191|      0|  OSStatus status = SecItemAdd((__bridge CFDictionaryRef)combined, NULL);
  192|      0|
  193|      0|  if (status == errSecDuplicateItem) {
  194|      0|    hasItem = YES;
  195|      0|    status = SecItemUpdate((__bridge CFDictionaryRef)query, (__bridge CFDictionaryRef)attributes);
  196|      0|  }
  197|      0|
  198|      0|  if (status == noErr) {
  199|      0|    return YES;
  200|      0|  }
  201|      0|  if (error) {
  202|      0|    NSString *function = hasItem ? @"SecItemUpdate" : @"SecItemAdd";
  203|      0|    *error = [FIRAuthErrorUtils keychainErrorWithFunction:function status:status];
  204|      0|  }
  205|      0|  return NO;
  206|      0|}
  207|       |
  208|      0|- (BOOL)deleteItemWithQuery:(NSDictionary *)query error:(NSError **_Nullable)error {
  209|      0|  OSStatus status = SecItemDelete((__bridge CFDictionaryRef)query);
  210|      0|  if (status == noErr || status == errSecItemNotFound) {
  211|      0|    return YES;
  212|      0|  }
  213|      0|  if (error) {
  214|      0|    *error = [FIRAuthErrorUtils keychainErrorWithFunction:@"SecItemDelete" status:status];
  215|      0|  }
  216|      0|  return NO;
  217|      0|}
  218|       |
  219|       |/** @fn deleteLegacyItemsWithKey:
  220|       |    @brief Deletes legacy item from the keychain if it is not already known to be deleted.
  221|       |    @param key The key for the item.
  222|       | */
  223|      0|- (void)deleteLegacyItemWithKey:(NSString *)key {
  224|      0|  if (_legacyEntryDeletedForKey[key]) {
  225|      0|    return;
  226|      0|  }
  227|      0|  NSDictionary *query = [self legacyGenericPasswordQueryWithKey:key];
  228|      0|  SecItemDelete((__bridge CFDictionaryRef)query);
  229|      0|  _legacyEntryDeletedForKey[key] = @YES;
  230|      0|}
  231|       |
  232|       |/** @fn genericPasswordQueryWithKey:
  233|       |    @brief Returns a keychain query of generic password to be used to manipulate key'ed value.
  234|       |    @param key The key for the value being manipulated, used as the account field in the query.
  235|       | */
  236|      2|- (NSDictionary *)genericPasswordQueryWithKey:(NSString *)key {
  237|      2|  return @{
  238|      2|    (__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword,
  239|      2|    (__bridge id)kSecAttrAccount : [kAccountPrefix stringByAppendingString:key],
  240|      2|    (__bridge id)kSecAttrService : _service,
  241|      2|  };
  242|      2|}
  243|       |
  244|       |/** @fn legacyGenericPasswordQueryWithKey:
  245|       |    @brief Returns a keychain query of generic password without service field, which is used by
  246|       |        previous version of this class.
  247|       |    @param key The key for the value being manipulated, used as the account field in the query.
  248|       | */
  249|      2|- (NSDictionary *)legacyGenericPasswordQueryWithKey:(NSString *)key {
  250|      2|  return @{
  251|      2|    (__bridge id)kSecClass : (__bridge id)kSecClassGenericPassword,
  252|      2|    (__bridge id)kSecAttrAccount : key,
  253|      2|  };
  254|      2|}
  255|       |
  256|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthNotificationManager.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthNotificationManager.h"
   18|       |
   19|       |#import <FirebaseCore/FIRLogger.h>
   20|       |#import "FIRAuthAppCredential.h"
   21|       |#import "FIRAuthAppCredentialManager.h"
   22|       |#import "FIRAuthGlobalWorkQueue.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |/** @var kNotificationKey
   27|       |    @brief The key to locate payload data in the remote notification.
   28|       | */
   29|       |static NSString *const kNotificationDataKey = @"com.google.firebase.auth";
   30|       |
   31|       |/** @var kNotificationReceiptKey
   32|       |    @brief The key for the receipt in the remote notification payload data.
   33|       | */
   34|       |static NSString *const kNotificationReceiptKey = @"receipt";
   35|       |
   36|       |/** @var kNotificationSecretKey
   37|       |    @brief The key for the secret in the remote notification payload data.
   38|       | */
   39|       |static NSString *const kNotificationSecretKey = @"secret";
   40|       |
   41|       |/** @var kNotificationProberKey
   42|       |    @brief The key for marking the prober in the remote notification payload data.
   43|       | */
   44|       |static NSString *const kNotificationProberKey = @"warning";
   45|       |
   46|       |/** @var kProbingTimeout
   47|       |    @brief Timeout for probing whether the app delegate forwards the remote notification to us.
   48|       | */
   49|       |static const NSTimeInterval kProbingTimeout = 1;
   50|       |
   51|       |@implementation FIRAuthNotificationManager {
   52|       |  /** @var _application
   53|       |      @brief The application.
   54|       |   */
   55|       |  UIApplication *_application;
   56|       |
   57|       |  /** @var _appCredentialManager
   58|       |      @brief The object to handle app credentials delivered via notification.
   59|       |   */
   60|       |  FIRAuthAppCredentialManager *_appCredentialManager;
   61|       |
   62|       |  /** @var _hasCheckedNotificationForwarding
   63|       |      @brief Whether notification forwarding has been checked or not.
   64|       |   */
   65|       |  BOOL _hasCheckedNotificationForwarding;
   66|       |
   67|       |  /** @var _isNotificationBeingForwarded
   68|       |      @brief Whether or not notification is being forwarded
   69|       |   */
   70|       |  BOOL _isNotificationBeingForwarded;
   71|       |
   72|       |  /** @var _pendingCallbacks
   73|       |      @brief All pending callbacks while a check is being performed.
   74|       |   */
   75|       |  NSMutableArray<FIRAuthNotificationForwardingCallback> *_pendingCallbacks;
   76|       |}
   77|       |
   78|       |- (instancetype)initWithApplication:(UIApplication *)application
   79|      1|               appCredentialManager:(FIRAuthAppCredentialManager *)appCredentialManager {
   80|      1|  self = [super init];
   81|      1|  if (self) {
   82|      1|    _application = application;
   83|      1|    _appCredentialManager = appCredentialManager;
   84|      1|    _timeout = kProbingTimeout;
   85|      1|  }
   86|      1|  return self;
   87|      1|}
   88|       |
   89|      0|- (void)checkNotificationForwardingWithCallback:(FIRAuthNotificationForwardingCallback)callback {
   90|      0|  if (_pendingCallbacks) {
   91|      0|    [_pendingCallbacks addObject:callback];
   92|      0|    return;
   93|      0|  }
   94|      0|  if (_hasCheckedNotificationForwarding) {
   95|      0|    callback(_isNotificationBeingForwarded);
   96|      0|    return;
   97|      0|  }
   98|      0|  _hasCheckedNotificationForwarding = YES;
   99|      0|  _pendingCallbacks =
  100|      0|      [[NSMutableArray<FIRAuthNotificationForwardingCallback> alloc] initWithObjects:callback, nil];
  101|      0|  dispatch_async(dispatch_get_main_queue(), ^{
  102|      0|    NSDictionary *proberNotification = @{
  103|      0|      kNotificationDataKey : @{
  104|      0|        kNotificationProberKey : @"This fake notification should be forwarded to Firebase Auth."
  105|      0|      }
  106|      0|    };
  107|      0|    if ([self->_application.delegate respondsToSelector:
  108|      0|            @selector(application:didReceiveRemoteNotification:fetchCompletionHandler:)]) {
  109|      0|      [self->_application.delegate application:self->_application
  110|      0|            didReceiveRemoteNotification:proberNotification
  111|      0|                  fetchCompletionHandler:^(UIBackgroundFetchResult result) {}];
  112|      0|#if !TARGET_OS_TV
  113|      0|    } else if ([self->_application.delegate respondsToSelector:
  114|      0|                   @selector(application:didReceiveRemoteNotification:)]) {
  115|      0|      [self->_application.delegate application:self->_application
  116|      0|            didReceiveRemoteNotification:proberNotification];
  117|      0|#endif
  118|      0|    } else {
  119|      0|      FIRLogWarning(kFIRLoggerAuth, @"I-AUT000015",
  120|      0|                    @"The UIApplicationDelegate must handle remote notification for phone number "
  121|      0|                    @"authentication to work.");
  122|      0|    }
  123|      0|  });
  124|      0|  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_timeout * NSEC_PER_SEC)),
  125|      0|                               FIRAuthGlobalWorkQueue(), ^{
  126|      0|    [self callBack];
  127|      0|  });
  128|      0|}
  129|       |
  130|      0|- (BOOL)canHandleNotification:(NSDictionary *)notification {
  131|      0|  NSDictionary *data = notification[kNotificationDataKey];
  132|      0|  if ([data isKindOfClass:[NSString class]]) {
  133|      0|    // Deserialize in case the data is a JSON string.
  134|      0|    NSData *JSONData = [((NSString *)data) dataUsingEncoding:NSUTF8StringEncoding];
  135|      0|    data = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:NULL];
  136|      0|  }
  137|      0|  if (![data isKindOfClass:[NSDictionary class]]) {
  138|      0|    return NO;
  139|      0|  }
  140|      0|  if (data[kNotificationProberKey]) {
  141|      0|    if (!_pendingCallbacks) {
  142|      0|      // The prober notification probably comes from another instance, so pass it along.
  143|      0|      return NO;
  144|      0|    }
  145|      0|    _isNotificationBeingForwarded = YES;
  146|      0|    [self callBack];
  147|      0|    return YES;
  148|      0|  }
  149|      0|  NSString *receipt = data[kNotificationReceiptKey];
  150|      0|  if (![receipt isKindOfClass:[NSString class]]) {
  151|      0|    return NO;
  152|      0|  }
  153|      0|  NSString *secret = data[kNotificationSecretKey];
  154|      0|  if (![receipt isKindOfClass:[NSString class]]) {
  155|      0|    return NO;
  156|      0|  }
  157|      0|  return [_appCredentialManager canFinishVerificationWithReceipt:receipt secret:secret];
  158|      0|}
  159|       |
  160|       |#pragma mark - Internal methods
  161|       |
  162|       |/** @fn callBack
  163|       |    @brief Calls back all pending callbacks with the result of notification forwarding check.
  164|       | */
  165|      0|- (void)callBack {
  166|      0|  if (!_pendingCallbacks) {
  167|      0|    return;
  168|      0|  }
  169|      0|  NSArray<FIRAuthNotificationForwardingCallback> *allCallbacks = _pendingCallbacks;
  170|      0|  _pendingCallbacks = nil;
  171|      0|  for (FIRAuthNotificationForwardingCallback callback in allCallbacks) {
  172|      0|    callback(_isNotificationBeingForwarded);
  173|      0|  }
  174|      0|};
  175|       |
  176|       |@end
  177|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthSerialTaskQueue.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthSerialTaskQueue.h"
   18|       |
   19|       |#import "FIRAuthGlobalWorkQueue.h"
   20|       |
   21|       |@implementation FIRAuthSerialTaskQueue {
   22|       |  /** @var _dispatchQueue
   23|       |      @brief The asyncronous dispatch queue into which tasks are enqueued and processed
   24|       |          serially.
   25|       |   */
   26|       |  dispatch_queue_t _dispatchQueue;
   27|       |}
   28|       |
   29|      0|- (instancetype)init {
   30|      0|  self = [super init];
   31|      0|  if (self) {
   32|      0|    _dispatchQueue = dispatch_queue_create("com.google.firebase.auth.serialTaskQueue", NULL);
   33|      0|    dispatch_set_target_queue(_dispatchQueue, FIRAuthGlobalWorkQueue());
   34|      0|  }
   35|      0|  return self;
   36|      0|}
   37|       |
   38|      0|- (void)enqueueTask:(FIRAuthSerialTask)task {
   39|      0|  // This dispatch queue will run tasks serially in FIFO order, as long as it's not suspended.
   40|      0|  dispatch_async(self->_dispatchQueue, ^{
   41|      0|    // But as soon as a task is started, stop other tasks from running until the task calls it's
   42|      0|    // completion handler, which allows the queue to resume processing of tasks. This allows the
   43|      0|    // task to perform other asyncronous actions on other dispatch queues and "get back to us" when
   44|      0|    // all of their sub-tasks are complete.
   45|      0|    dispatch_suspend(self->_dispatchQueue);
   46|      0|    task(^{
   47|      0|      dispatch_resume(self->_dispatchQueue);
   48|      0|    });
   49|      0|  });
   50|      0|}
   51|       |
   52|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthSettings.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthSettings.h"
   18|       |
   19|       |@implementation FIRAuthSettings
   20|       |
   21|      1|- (instancetype)init {
   22|      1|  self = [super init];
   23|      1|  if (self) {
   24|      1|    _appVerificationDisabledForTesting = NO;
   25|      1|  }
   26|      1|  return self;
   27|      1|}
   28|       |
   29|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthTokenResult.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthTokenResult_Internal.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kExpirationDateKey
   22|       |    @brief The key used to encode the expirationDate property for NSSecureCoding.
   23|       | */
   24|       |static NSString *const kExpirationDateKey = @"expiratinDate";
   25|       |
   26|       |/** @var kTokenKey
   27|       |    @brief The key used to encode the token property for NSSecureCoding.
   28|       | */
   29|       |static NSString *const kTokenKey = @"token";
   30|       |
   31|       |/** @var kAuthDateKey
   32|       |    @brief The key used to encode the authDate property for NSSecureCoding.
   33|       | */
   34|       |static NSString *const kAuthDateKey = @"authDate";
   35|       |
   36|       |/** @var kIssuedDateKey
   37|       |    @brief The key used to encode the issuedDate property for NSSecureCoding.
   38|       | */
   39|       |static NSString *const kIssuedDateKey = @"issuedDate";
   40|       |
   41|       |/** @var kSignInProviderKey
   42|       |    @brief The key used to encode the signInProvider property for NSSecureCoding.
   43|       | */
   44|       |static NSString *const kSignInProviderKey = @"signInProvider";
   45|       |
   46|       |/** @var kClaimsKey
   47|       |    @brief The key used to encode the claims property for NSSecureCoding.
   48|       | */
   49|       |static NSString *const kClaimsKey = @"claims";
   50|       |
   51|       |@implementation FIRAuthTokenResult
   52|       |
   53|       |- (instancetype)initWithToken:(NSString *)token
   54|       |               expirationDate:(NSDate *)expirationDate
   55|       |                     authDate:(NSDate *)authDate
   56|       |                 issuedAtDate:(NSDate *)issuedAtDate
   57|       |               signInProvider:(NSString *)signInProvider
   58|      0|                       claims:(NSDictionary *)claims {
   59|      0|  self = [super init];
   60|      0|  if (self) {
   61|      0|    _token = token;
   62|      0|    _expirationDate = expirationDate;
   63|      0|    _authDate = authDate;
   64|      0|    _issuedAtDate = issuedAtDate;
   65|      0|    _signInProvider = signInProvider;
   66|      0|    _claims = claims;
   67|      0|  }
   68|      0|  return self;
   69|      0|}
   70|       |
   71|       |#pragma mark - NSSecureCoding
   72|       |
   73|      0|+ (BOOL)supportsSecureCoding {
   74|      0|  return YES;
   75|      0|}
   76|       |
   77|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   78|      0|  NSString *token =
   79|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kTokenKey];
   80|      0|  NSDate *expirationDate =
   81|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kExpirationDateKey];
   82|      0|  NSDate *authDate =
   83|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kAuthDateKey];
   84|      0|  NSDate *issuedAtDate =
   85|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kAuthDateKey];
   86|      0|  NSString *signInProvider =
   87|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kSignInProviderKey];
   88|      0|  NSDictionary<NSString *, NSString *> *claims =
   89|      0|      [aDecoder decodeObjectOfClass:[NSDictionary<NSString *, NSString *> class] forKey:kClaimsKey];
   90|      0|
   91|      0|  return [self initWithToken:token
   92|      0|              expirationDate:expirationDate
   93|      0|                    authDate:authDate
   94|      0|                issuedAtDate:issuedAtDate
   95|      0|              signInProvider:signInProvider
   96|      0|                      claims:claims];
   97|      0|}
   98|       |
   99|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  100|      0|  [aCoder encodeObject:_token forKey:kTokenKey];
  101|      0|  [aCoder encodeObject:_expirationDate forKey:kExpirationDateKey];
  102|      0|  [aCoder encodeObject:_authDate forKey:kAuthDateKey];
  103|      0|  [aCoder encodeObject:_issuedAtDate forKey:kIssuedDateKey];
  104|      0|  [aCoder encodeObject:_signInProvider forKey:kSignInProviderKey];
  105|      0|  [aCoder encodeObject:_claims forKey:kClaimsKey];
  106|      0|}
  107|       |
  108|       |@end
  109|       |
  110|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthURLPresenter.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthURLPresenter.h"
   18|       |
   19|       |#import <SafariServices/SafariServices.h>
   20|       |
   21|       |#import "FIRAuthDefaultUIDelegate.h"
   22|       |#import "FIRAuthErrorUtils.h"
   23|       |#import "FIRAuthGlobalWorkQueue.h"
   24|       |#import "FIRAuthUIDelegate.h"
   25|       |#import "FIRAuthWebViewController.h"
   26|       |
   27|       |NS_ASSUME_NONNULL_BEGIN
   28|       |
   29|       |@interface FIRAuthURLPresenter () <SFSafariViewControllerDelegate,
   30|       |                                   FIRAuthWebViewControllerDelegate>
   31|       |@end
   32|       |
   33|       |// Disable unguarded availability warnings because SFSafariViewController is been used throughout
   34|       |// the code, including as an iVar, which cannot be simply excluded by @available check.
   35|       |#pragma clang diagnostic push
   36|       |#pragma clang diagnostic ignored "-Wunguarded-availability"
   37|       |
   38|       |@implementation FIRAuthURLPresenter {
   39|       |  /** @var _isPresenting
   40|       |      @brief Whether or not some web-based content is being presented.
   41|       |   */
   42|       |  BOOL _isPresenting;
   43|       |
   44|       |  /** @var _callbackMatcher
   45|       |      @brief The callback URL matcher for the current presentation, if one is active.
   46|       |   */
   47|       |  FIRAuthURLCallbackMatcher _Nullable _callbackMatcher;
   48|       |
   49|       |  /** @var _safariViewController
   50|       |      @brief The SFSafariViewController used for the current presentation, if any.
   51|       |   */
   52|       |  SFSafariViewController *_Nullable _safariViewController;
   53|       |
   54|       |  /** @var _webViewController
   55|       |      @brief The FIRAuthWebViewController used for the current presentation, if any.
   56|       |   */
   57|       |  FIRAuthWebViewController *_Nullable _webViewController;
   58|       |
   59|       |  /** @var _UIDelegate
   60|       |      @brief The UIDelegate used to present the SFSafariViewController.
   61|       |   */
   62|       |  id<FIRAuthUIDelegate> _UIDelegate;
   63|       |
   64|       |  /** @var _completion
   65|       |      @brief The completion handler for the current presentaion, if one is active.
   66|       |      @remarks This variable is also used as a flag to indicate a presentation is active.
   67|       |   */
   68|       |  FIRAuthURLPresentationCompletion _Nullable _completion;
   69|       |}
   70|       |
   71|       |- (void)presentURL:(NSURL *)URL
   72|       |        UIDelegate:(nullable id<FIRAuthUIDelegate>)UIDelegate
   73|       |   callbackMatcher:(FIRAuthURLCallbackMatcher)callbackMatcher
   74|      0|        completion:(FIRAuthURLPresentationCompletion)completion {
   75|      0|  if (_isPresenting) {
   76|      0|    // Unable to start a new presentation on top of another.
   77|      0|    _completion(nil, [FIRAuthErrorUtils webContextAlreadyPresentedErrorWithMessage:nil]);
   78|      0|    return;
   79|      0|  }
   80|      0|  _isPresenting = YES;
   81|      0|  _callbackMatcher = callbackMatcher;
   82|      0|  _completion = completion;
   83|      0|  dispatch_async(dispatch_get_main_queue(), ^() {
   84|      0|    self->_UIDelegate = UIDelegate ?: [FIRAuthDefaultUIDelegate defaultUIDelegate];
   85|      0|    if ([SFSafariViewController class]) {
   86|      0|      self->_safariViewController = [[SFSafariViewController alloc] initWithURL:URL];
   87|      0|      self->_safariViewController.delegate = self;
   88|      0|      [self->_UIDelegate presentViewController:self->_safariViewController
   89|      0|                                      animated:YES
   90|      0|                                    completion:nil];
   91|      0|      return;
   92|      0|    } else {
   93|      0|      self->_webViewController = [[FIRAuthWebViewController alloc] initWithURL:URL delegate:self];
   94|      0|      UINavigationController *navController =
   95|      0|          [[UINavigationController alloc] initWithRootViewController:self->_webViewController];
   96|      0|      [self->_UIDelegate presentViewController:navController animated:YES completion:nil];
   97|      0|    }
   98|      0|  });
   99|      0|}
  100|       |
  101|      0|- (BOOL)canHandleURL:(NSURL *)URL {
  102|      0|  if (_isPresenting && _callbackMatcher && _callbackMatcher(URL)) {
  103|      0|    [self finishPresentationWithURL:URL error:nil];
  104|      0|    return YES;
  105|      0|  }
  106|      0|  return NO;
  107|      0|}
  108|       |
  109|       |#pragma mark - SFSafariViewControllerDelegate
  110|       |
  111|      0|- (void)safariViewControllerDidFinish:(SFSafariViewController *)controller {
  112|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^() {
  113|      0|    if (controller == self->_safariViewController) {
  114|      0|      self->_safariViewController = nil;
  115|      0|      //TODO:Ensure that the SFSafariViewController is actually removed from the screen before
  116|      0|      //invoking finishPresentationWithURL:error:
  117|      0|      [self finishPresentationWithURL:nil
  118|      0|                                error:[FIRAuthErrorUtils webContextCancelledErrorWithMessage:nil]];
  119|      0|    }
  120|      0|  });
  121|      0|}
  122|       |
  123|       |#pragma mark - FIRAuthwebViewControllerDelegate
  124|       |
  125|      0|- (BOOL)webViewController:(FIRAuthWebViewController *)webViewController canHandleURL:(NSURL *)URL {
  126|      0|  __block BOOL result = NO;
  127|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^() {
  128|      0|    if (webViewController == self->_webViewController) {
  129|      0|      result = [self canHandleURL:URL];
  130|      0|    }
  131|      0|  });
  132|      0|  return result;
  133|      0|}
  134|       |
  135|      0|- (void)webViewControllerDidCancel:(FIRAuthWebViewController *)webViewController {
  136|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^() {
  137|      0|    if (webViewController == self->_webViewController) {
  138|      0|      [self finishPresentationWithURL:nil
  139|      0|                                error:[FIRAuthErrorUtils webContextCancelledErrorWithMessage:nil]];
  140|      0|    }
  141|      0|  });
  142|      0|}
  143|       |
  144|       |- (void)webViewController:(FIRAuthWebViewController *)webViewController
  145|      0|         didFailWithError:(NSError *)error {
  146|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^() {
  147|      0|    if (webViewController == self->_webViewController) {
  148|      0|      [self finishPresentationWithURL:nil error:error];
  149|      0|    }
  150|      0|  });
  151|      0|}
  152|       |
  153|       |#pragma mark - Private methods
  154|       |
  155|       |/** @fn finishPresentationWithURL:error:
  156|       |    @brief Finishes the presentation for a given URL, if any.
  157|       |    @param URL The URL to finish presenting.
  158|       |    @param error The error with which to finish presenting, if any.
  159|       | */
  160|       |- (void)finishPresentationWithURL:(nullable NSURL *)URL
  161|      0|                            error:(nullable NSError *)error {
  162|      0|  _callbackMatcher = nil;
  163|      0|  id<FIRAuthUIDelegate> UIDelegate = _UIDelegate;
  164|      0|  _UIDelegate = nil;
  165|      0|  FIRAuthURLPresentationCompletion completion = _completion;
  166|      0|  _completion = nil;
  167|      0|  void (^finishBlock)(void) = ^() {
  168|      0|    self->_isPresenting = NO;
  169|      0|    completion(URL, error);
  170|      0|  };
  171|      0|  SFSafariViewController *safariViewController = _safariViewController;
  172|      0|  _safariViewController = nil;
  173|      0|  FIRAuthWebViewController *webViewController = _webViewController;
  174|      0|  _webViewController = nil;
  175|      0|  if (safariViewController || webViewController) {
  176|      0|    dispatch_async(dispatch_get_main_queue(), ^() {
  177|      0|      [UIDelegate dismissViewControllerAnimated:YES completion:^() {
  178|      0|        dispatch_async(FIRAuthGlobalWorkQueue(), finishBlock);
  179|      0|      }];
  180|      0|    });
  181|      0|  } else {
  182|      0|    finishBlock();
  183|      0|  }
  184|      0|}
  185|       |
  186|       |#pragma clang diagnostic pop  // ignored "-Wunguarded-availability"
  187|       |
  188|       |@end
  189|       |
  190|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthUserDefaultsStorage.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthUserDefaultsStorage.h"
   18|       |
   19|       |#if FIRAUTH_USER_DEFAULTS_STORAGE_AVAILABLE
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |static NSString *const kPersistentDomainNamePrefix = @"com.google.Firebase.Auth.";
   24|       |
   25|       |@implementation FIRAuthUserDefaultsStorage {
   26|       |  /** @var _persistentDomainName
   27|       |      @brief The name of the persistent domain in user defaults.
   28|       |   */
   29|       |  NSString *_persistentDomainName;
   30|       |
   31|       |  /** @var _storage
   32|       |      @brief The backing NSUserDefaults storage for this instance.
   33|       |   */
   34|       |  NSUserDefaults *_storage;
   35|       |}
   36|       |
   37|      0|- (id<FIRAuthStorage>)initWithService:(NSString *)service {
   38|      0|  self = [super init];
   39|      0|  if (self) {
   40|      0|    _persistentDomainName = [kPersistentDomainNamePrefix stringByAppendingString:service];
   41|      0|    _storage = [[NSUserDefaults alloc] init];
   42|      0|  }
   43|      0|  return self;
   44|      0|}
   45|       |
   46|      0|- (nullable NSData *)dataForKey:(NSString *)key error:(NSError **_Nullable)error {
   47|      0|  if (error) {
   48|      0|    *error = nil;
   49|      0|  }
   50|      0|  NSDictionary<NSString *, id> *allData = [_storage persistentDomainForName:_persistentDomainName];
   51|      0|  return allData[key];
   52|      0|}
   53|       |
   54|      0|- (BOOL)setData:(NSData *)data forKey:(NSString *)key error:(NSError **_Nullable)error {
   55|      0|  NSMutableDictionary<NSString *, id> *allData =
   56|      0|      [([_storage persistentDomainForName:_persistentDomainName] ?: @{}) mutableCopy];
   57|      0|  allData[key] = data;
   58|      0|  [_storage setPersistentDomain:allData forName:_persistentDomainName];
   59|      0|  return YES;
   60|      0|}
   61|       |
   62|      0|- (BOOL)removeDataForKey:(NSString *)key error:(NSError **_Nullable)error {
   63|      0|  NSMutableDictionary<NSString *, id> *allData =
   64|      0|      [[_storage persistentDomainForName:_persistentDomainName] mutableCopy];
   65|      0|  [allData removeObjectForKey:key];
   66|      0|  [_storage setPersistentDomain:allData forName:_persistentDomainName];
   67|      0|  return YES;
   68|      0|}
   69|       |
   70|      0|- (void)clear {
   71|      0|  [_storage setPersistentDomain:@{} forName:_persistentDomainName];
   72|      0|}
   73|       |
   74|       |@end
   75|       |
   76|       |NS_ASSUME_NONNULL_END
   77|       |
   78|       |#endif  // FIRAUTH_USER_DEFAULTS_STORAGE_AVAILABLE

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthWebUtils.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthWebUtils.h"
   18|       |
   19|       |#import "FIRAuthBackend.h"
   20|       |#import "FIRAuthErrorUtils.h"
   21|       |#import "FIRGetProjectConfigRequest.h"
   22|       |#import "FIRGetProjectConfigResponse.h"
   23|       |
   24|       |/** @var kAuthDomainSuffix
   25|       |    @brief The suffix of the auth domain pertiaining to a given Firebase project.
   26|       | */
   27|       |static NSString *const kAuthDomainSuffix = @"firebaseapp.com";
   28|       |
   29|       |@implementation FIRAuthWebUtils
   30|       |
   31|      0|+ (NSString *)randomStringWithLength:(NSUInteger)length {
   32|      0|  NSMutableString *randomString = [[NSMutableString alloc] init];
   33|      0|  for (int i=0; i < length; i++) {
   34|      0|    [randomString appendString:
   35|      0|        [NSString stringWithFormat:@"%c", 'a' + arc4random_uniform('z' - 'a' + 1)]];
   36|      0|  }
   37|      0|  return randomString;
   38|      0|}
   39|       |
   40|      0|+ (BOOL)isCallbackSchemeRegisteredForCustomURLScheme:(NSString *)URLScheme {
   41|      0|  NSString *expectedCustomScheme = [URLScheme lowercaseString];
   42|      0|  NSArray *urlTypes = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"CFBundleURLTypes"];
   43|      0|  for (NSDictionary *urlType in urlTypes) {
   44|      0|    NSArray *urlTypeSchemes = urlType[@"CFBundleURLSchemes"];
   45|      0|    for (NSString *urlTypeScheme in urlTypeSchemes) {
   46|      0|      if ([urlTypeScheme.lowercaseString isEqualToString:expectedCustomScheme]) {
   47|      0|        return YES;
   48|      0|      }
   49|      0|    }
   50|      0|  }
   51|      0|  return NO;
   52|      0|}
   53|       |
   54|       |+ (void)fetchAuthDomainWithRequestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
   55|      0|                                     completion:(FIRFetchAuthDomainCallback)completion {
   56|      0|  FIRGetProjectConfigRequest *request =
   57|      0|      [[FIRGetProjectConfigRequest alloc] initWithRequestConfiguration:requestConfiguration];
   58|      0|
   59|      0|  [FIRAuthBackend getProjectConfig:request
   60|      0|                          callback:^(FIRGetProjectConfigResponse *_Nullable response,
   61|      0|                                     NSError *_Nullable error) {
   62|      0|    if (error) {
   63|      0|      completion(nil, error);
   64|      0|      return;
   65|      0|    }
   66|      0|    NSString *authDomain;
   67|      0|    for (NSString *domain in response.authorizedDomains) {
   68|      0|      NSInteger index = domain.length - kAuthDomainSuffix.length;
   69|      0|      if (index >= 2) {
   70|      0|        if ([domain hasSuffix:kAuthDomainSuffix] && domain.length >= kAuthDomainSuffix.length + 2) {
   71|      0|          authDomain = domain;
   72|      0|          break;
   73|      0|        }
   74|      0|      }
   75|      0|    }
   76|      0|    if (!authDomain.length) {
   77|      0|      completion(nil, [FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:response]);
   78|      0|      return;
   79|      0|    }
   80|      0|    completion(authDomain, nil);
   81|      0|  }];
   82|      0|}
   83|       |
   84|       |/** @fn queryItemValue:from:
   85|       | @brief Utility function to get a value from a NSURLQueryItem array.
   86|       | @param name The key.
   87|       | @param queryList The NSURLQueryItem array.
   88|       | @return The value for the key.
   89|       | */
   90|       |
   91|      0|+ (nullable NSString *)queryItemValue:(NSString *)name from:(NSArray<NSURLQueryItem *> *)queryList {
   92|      0|  for (NSURLQueryItem *item in queryList) {
   93|      0|    if ([item.name isEqualToString:name]) {
   94|      0|      return item.value;
   95|      0|    }
   96|      0|  }
   97|      0|  return nil;
   98|      0|}
   99|       |
  100|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthWebView.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthWebView.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRAuthWebView
   22|       |
   23|      0|- (instancetype)initWithFrame:(CGRect)frame {
   24|      0|  self = [super initWithFrame:frame];
   25|      0|  if (self) {
   26|      0|    self.backgroundColor = [UIColor whiteColor];
   27|      0|    [self initializeSubviews];
   28|      0|  }
   29|      0|  return self;
   30|      0|}
   31|       |
   32|       |/** @fn initializeSubviews
   33|       |    @brief Initializes the subviews of this view.
   34|       | */
   35|      0|- (void)initializeSubviews {
   36|      0|  UIWebView *webView = [self createWebView];
   37|      0|  UIActivityIndicatorView *spinner = [self createSpinner];
   38|      0|
   39|      0|  // The order of the following controls z-order.
   40|      0|  [self addSubview:webView];
   41|      0|  [self addSubview:spinner];
   42|      0|
   43|      0|  [self layoutSubviews];
   44|      0|  _webView = webView;
   45|      0|  _spinner = spinner;
   46|      0|}
   47|       |
   48|      0|- (void)layoutSubviews {
   49|      0|  CGFloat height = self.bounds.size.height;
   50|      0|  CGFloat width = self.bounds.size.width;
   51|      0|  _webView.frame = CGRectMake(0, 0, width, height);
   52|      0|  _spinner.center = _webView.center;
   53|      0|}
   54|       |
   55|       |/** @fn createWebView
   56|       |    @brief Creates a web view to be used by this view.
   57|       |    @return The newly created web view.
   58|       | */
   59|      0|- (UIWebView *)createWebView {
   60|      0|  UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero];
   61|      0|  // Trickery to make the web view not do weird things (like showing a black background when
   62|      0|  // the prompt in the navigation bar animates changes.)
   63|      0|  webView.opaque = NO;
   64|      0|  webView.backgroundColor = [UIColor clearColor];
   65|      0|  webView.scrollView.opaque = NO;
   66|      0|  webView.scrollView.backgroundColor = [UIColor clearColor];
   67|      0|  webView.scrollView.bounces = NO;
   68|      0|  webView.scrollView.alwaysBounceVertical = NO;
   69|      0|  webView.scrollView.alwaysBounceHorizontal = NO;
   70|      0|  return webView;
   71|      0|}
   72|       |
   73|       |/** @fn createSpinner
   74|       |    @brief Creates a spinner to be used by this view.
   75|       |    @return The newly created spinner.
   76|       | */
   77|      0|- (UIActivityIndicatorView *)createSpinner {
   78|      0|  UIActivityIndicatorViewStyle spinnerStyle = UIActivityIndicatorViewStyleGray;
   79|      0|  UIActivityIndicatorView *spinner =
   80|      0|      [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:spinnerStyle];
   81|      0|  return spinner;
   82|      0|}
   83|       |
   84|       |@end
   85|       |
   86|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRAuthWebViewController.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthWebViewController.h"
   18|       |
   19|       |#import "FIRAuthWebView.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |@interface FIRAuthWebViewController () <UIWebViewDelegate>
   24|       |@end
   25|       |
   26|       |@implementation FIRAuthWebViewController {
   27|       |  /** @var _URL
   28|       |      @brief The initial URL to display.
   29|       |   */
   30|       |  NSURL *_URL;
   31|       |
   32|       |  /** @var _delegate
   33|       |      @brief The delegate to call.
   34|       |   */
   35|       |  __weak id<FIRAuthWebViewControllerDelegate> _delegate;
   36|       |
   37|       |  /** @var _webView;
   38|       |      @brief The web view instance for easier access.
   39|       |   */
   40|       |  __weak FIRAuthWebView *_webView;
   41|       |}
   42|       |
   43|       |- (instancetype)initWithURL:(NSURL *)URL
   44|      0|                   delegate:(__weak id<FIRAuthWebViewControllerDelegate>)delegate {
   45|      0|  self = [super initWithNibName:nil bundle:nil];
   46|      0|  if (self) {
   47|      0|    _URL = URL;
   48|      0|    _delegate = delegate;
   49|      0|  }
   50|      0|  return self;
   51|      0|}
   52|       |
   53|       |#pragma mark - Lifecycle
   54|       |
   55|      0|- (void)loadView {
   56|      0|  FIRAuthWebView *webView = [[FIRAuthWebView alloc] initWithFrame:[UIScreen mainScreen].bounds];
   57|      0|  webView.webView.delegate = self;
   58|      0|  self.view = webView;
   59|      0|  _webView = webView;
   60|      0|  self.navigationItem.leftBarButtonItem =
   61|      0|      [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCancel
   62|      0|                                                    target:self
   63|      0|                                                    action:@selector(cancel)];
   64|      0|}
   65|       |
   66|      0|- (void)viewDidAppear:(BOOL)animated {
   67|      0|  [super viewDidAppear:animated];
   68|      0|
   69|      0|  // Loads the requested URL in the web view.
   70|      0|  [_webView.webView loadRequest:[NSURLRequest requestWithURL:_URL]];
   71|      0|}
   72|       |
   73|       |#pragma mark - UI Targets
   74|       |
   75|      0|- (void)cancel {
   76|      0|  [_delegate webViewControllerDidCancel:self];
   77|      0|}
   78|       |
   79|       |#pragma mark - UIWebViewDelegate
   80|       |
   81|       |- (BOOL)webView:(UIWebView *)webView
   82|       |    shouldStartLoadWithRequest:(NSURLRequest *)request
   83|      0|                navigationType:(UIWebViewNavigationType)navigationType {
   84|      0|  return ![_delegate webViewController:self canHandleURL:request.URL];
   85|      0|}
   86|       |
   87|      0|- (void)webViewDidStartLoad:(UIWebView *)webView {
   88|      0|  // Show & animate the activity indicator.
   89|      0|  _webView.spinner.hidden = NO;
   90|      0|  [_webView.spinner startAnimating];
   91|      0|}
   92|       |
   93|      0|- (void)webViewDidFinishLoad:(UIWebView *)webView {
   94|      0|  // Hide & stop the activity indicator.
   95|      0|  _webView.spinner.hidden = YES;
   96|      0|  [_webView.spinner stopAnimating];
   97|      0|}
   98|       |
   99|      0|- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error {
  100|      0|  if ([error.domain isEqualToString:NSURLErrorDomain] && error.code == NSURLErrorCancelled) {
  101|      0|    // It's okay for the page to be redirected before it is completely loaded.  See b/32028062 .
  102|      0|    return;
  103|      0|  }
  104|      0|  // Forward notification to our delegate.
  105|      0|  [self webViewDidFinishLoad:webView];
  106|      0|  [_delegate webViewController:self didFailWithError:error];
  107|      0|}
  108|       |
  109|       |@end
  110|       |
  111|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRSecureTokenService.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSecureTokenService.h"
   18|       |
   19|       |#import "FIRAuth.h"
   20|       |#import "FIRAuthKeychain.h"
   21|       |#import "FIRAuthSerialTaskQueue.h"
   22|       |#import "FIRAuthBackend.h"
   23|       |#import "FIRAuthRequestConfiguration.h"
   24|       |#import "FIRSecureTokenRequest.h"
   25|       |#import "FIRSecureTokenResponse.h"
   26|       |
   27|       |/** @var kAPIKeyCodingKey
   28|       |    @brief The key used to encode the APIKey for NSSecureCoding.
   29|       | */
   30|       |static NSString *const kAPIKeyCodingKey = @"APIKey";
   31|       |
   32|       |/** @var kRefreshTokenKey
   33|       |    @brief The key used to encode the refresh token for NSSecureCoding.
   34|       | */
   35|       |static NSString *const kRefreshTokenKey = @"refreshToken";
   36|       |
   37|       |/** @var kAccessTokenKey
   38|       |    @brief The key used to encode the access token for NSSecureCoding.
   39|       | */
   40|       |static NSString *const kAccessTokenKey = @"accessToken";
   41|       |
   42|       |/** @var kAccessTokenExpirationDateKey
   43|       |    @brief The key used to encode the access token expiration date for NSSecureCoding.
   44|       | */
   45|       |static NSString *const kAccessTokenExpirationDateKey = @"accessTokenExpirationDate";
   46|       |
   47|       |/** @var kFiveMinutes
   48|       |    @brief Five minutes (in seconds.)
   49|       | */
   50|       |static const NSTimeInterval kFiveMinutes = 5 * 60;
   51|       |
   52|       |@interface FIRSecureTokenService ()
   53|       |- (instancetype)init NS_DESIGNATED_INITIALIZER;
   54|       |@end
   55|       |
   56|       |@implementation FIRSecureTokenService {
   57|       |  /** @var _taskQueue
   58|       |      @brief Used to serialize all requests for access tokens.
   59|       |   */
   60|       |  FIRAuthSerialTaskQueue *_taskQueue;
   61|       |
   62|       |  /** @var _authorizationCode
   63|       |      @brief An authorization code which needs to be exchanged for Secure Token Service tokens.
   64|       |   */
   65|       |  NSString *_Nullable _authorizationCode;
   66|       |
   67|       |  /** @var _accessToken
   68|       |      @brief The currently cached access token. Or |nil| if no token is currently cached.
   69|       |   */
   70|       |  NSString *_Nullable _accessToken;
   71|       |}
   72|       |
   73|      0|- (instancetype)init {
   74|      0|  self = [super init];
   75|      0|  if (self) {
   76|      0|    _taskQueue = [[FIRAuthSerialTaskQueue alloc] init];
   77|      0|  }
   78|      0|  return self;
   79|      0|}
   80|       |
   81|       |- (instancetype)initWithRequestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
   82|      0|                           authorizationCode:(NSString *)authorizationCode {
   83|      0|  self = [self init];
   84|      0|  if (self) {
   85|      0|    _requestConfiguration = requestConfiguration;
   86|      0|    _authorizationCode = [authorizationCode copy];
   87|      0|  }
   88|      0|  return self;
   89|      0|}
   90|       |
   91|       |- (instancetype)initWithRequestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
   92|       |                                 accessToken:(nullable NSString *)accessToken
   93|       |                   accessTokenExpirationDate:(nullable NSDate *)accessTokenExpirationDate
   94|      0|                                refreshToken:(NSString *)refreshToken {
   95|      0|  self = [self init];
   96|      0|  if (self) {
   97|      0|    _requestConfiguration = requestConfiguration;
   98|      0|    _accessToken = [accessToken copy];
   99|      0|    _accessTokenExpirationDate = [accessTokenExpirationDate copy];
  100|      0|    _refreshToken = [refreshToken copy];
  101|      0|  }
  102|      0|  return self;
  103|      0|}
  104|       |
  105|       |- (void)fetchAccessTokenForcingRefresh:(BOOL)forceRefresh
  106|      0|                              callback:(FIRFetchAccessTokenCallback)callback {
  107|      0|  [_taskQueue enqueueTask:^(FIRAuthSerialTaskCompletionBlock complete) {
  108|      0|    if (!forceRefresh && [self hasValidAccessToken]) {
  109|      0|      complete();
  110|      0|      callback(self->_accessToken, nil, NO);
  111|      0|    } else {
  112|      0|      [self requestAccessToken:^(NSString *_Nullable token,
  113|      0|                                 NSError *_Nullable error,
  114|      0|                                 BOOL tokenUpdated) {
  115|      0|        complete();
  116|      0|        callback(token, error, tokenUpdated);
  117|      0|      }];
  118|      0|    }
  119|      0|  }];
  120|      0|}
  121|       |
  122|      0|- (NSString *)rawAccessToken {
  123|      0|  return _accessToken;
  124|      0|}
  125|       |
  126|       |#pragma mark - NSSecureCoding
  127|       |
  128|      0|+ (BOOL)supportsSecureCoding {
  129|      0|  return YES;
  130|      0|}
  131|       |
  132|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
  133|      0|  NSString *refreshToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:kRefreshTokenKey];
  134|      0|  NSString *accessToken = [aDecoder decodeObjectOfClass:[NSString class] forKey:kAccessTokenKey];
  135|      0|  NSDate *accessTokenExpirationDate =
  136|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kAccessTokenExpirationDateKey];
  137|      0|  if (!refreshToken) {
  138|      0|    return nil;
  139|      0|  }
  140|      0|  self = [self init];
  141|      0|  if (self) {
  142|      0|    _refreshToken = refreshToken;
  143|      0|    _accessToken = accessToken;
  144|      0|    _accessTokenExpirationDate = accessTokenExpirationDate;
  145|      0|  }
  146|      0|  return self;
  147|      0|}
  148|       |
  149|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  150|      0|  // The API key is encoded even it is not used in decoding to be compatible with previous versions
  151|      0|  // of the library.
  152|      0|  [aCoder encodeObject:_requestConfiguration.APIKey forKey:kAPIKeyCodingKey];
  153|      0|  // Authorization code is not encoded because it is not long-lived.
  154|      0|  [aCoder encodeObject:_refreshToken forKey:kRefreshTokenKey];
  155|      0|  [aCoder encodeObject:_accessToken forKey:kAccessTokenKey];
  156|      0|  [aCoder encodeObject:_accessTokenExpirationDate forKey:kAccessTokenExpirationDateKey];
  157|      0|}
  158|       |
  159|       |#pragma mark - Private methods
  160|       |
  161|       |/** @fn requestAccessToken:
  162|       |    @brief Makes a request to STS for an access token.
  163|       |    @details This handles both the case that the token has not been granted yet and that it just
  164|       |        needs to be refreshed. The caller is responsible for making sure that this is occurring in
  165|       |        a @c _taskQueue task.
  166|       |    @param callback Called when the fetch is complete. Invoked asynchronously on the main thread in
  167|       |        the future.
  168|       |    @remarks Because this method is guaranteed to only be called from tasks enqueued in
  169|       |        @c _taskQueue, we do not need any @synchronized guards around access to _accessToken/etc.
  170|       |        since only one of those tasks is ever running at a time, and those tasks are the only
  171|       |        access to and mutation of these instance variables.
  172|       | */
  173|      0|- (void)requestAccessToken:(FIRFetchAccessTokenCallback)callback {
  174|      0|  FIRSecureTokenRequest *request;
  175|      0|  if (_refreshToken.length) {
  176|      0|    request = [FIRSecureTokenRequest refreshRequestWithRefreshToken:_refreshToken
  177|      0|                                               requestConfiguration:_requestConfiguration];
  178|      0|  } else {
  179|      0|    request = [FIRSecureTokenRequest authCodeRequestWithCode:_authorizationCode
  180|      0|                                        requestConfiguration:_requestConfiguration];
  181|      0|  }
  182|      0|  [FIRAuthBackend secureToken:request
  183|      0|                     callback:^(FIRSecureTokenResponse *_Nullable response,
  184|      0|                                NSError *_Nullable error) {
  185|      0|    BOOL tokenUpdated = NO;
  186|      0|    NSString *newAccessToken = response.accessToken;
  187|      0|                       if (newAccessToken.length && ![newAccessToken isEqualToString:self->_accessToken]) {
  188|      0|                         self->_accessToken = [newAccessToken copy];
  189|      0|                         self->_accessTokenExpirationDate = response.approximateExpirationDate;
  190|      0|      tokenUpdated = YES;
  191|      0|    }
  192|      0|    NSString *newRefreshToken = response.refreshToken;
  193|      0|                       if (newRefreshToken.length &&
  194|      0|                           ![newRefreshToken isEqualToString:self->_refreshToken]) {
  195|      0|                         self->_refreshToken = [newRefreshToken copy];
  196|      0|      tokenUpdated = YES;
  197|      0|    }
  198|      0|    callback(newAccessToken, error, tokenUpdated);
  199|      0|  }];
  200|      0|}
  201|       |
  202|      0|- (BOOL)hasValidAccessToken {
  203|      0|  return _accessToken && [_accessTokenExpirationDate timeIntervalSinceNow] > kFiveMinutes;
  204|      0|}
  205|       |
  206|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRUser.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRUser_Internal.h"
   18|       |
   19|       |#import <FirebaseCore/FIRLogger.h>
   20|       |
   21|       |#import "FIRAdditionalUserInfo_Internal.h"
   22|       |#import "FIRAuth.h"
   23|       |#import "FIRAuthCredential_Internal.h"
   24|       |#import "FIRAuthDataResult_Internal.h"
   25|       |#import "FIRAuthErrorUtils.h"
   26|       |#import "FIRAuthGlobalWorkQueue.h"
   27|       |#import "FIRAuthSerialTaskQueue.h"
   28|       |#import "FIRAuthOperationType.h"
   29|       |#import "FIRAuth_Internal.h"
   30|       |#import "FIRAuthBackend.h"
   31|       |#import "FIRAuthRequestConfiguration.h"
   32|       |#import "FIRAuthTokenResult_Internal.h"
   33|       |#import "FIRDeleteAccountRequest.h"
   34|       |#import "FIRDeleteAccountResponse.h"
   35|       |#import "FIREmailAuthProvider.h"
   36|       |#import "FIREmailPasswordAuthCredential.h"
   37|       |#import "FIRGameCenterAuthCredential.h"
   38|       |#import "FIRGetAccountInfoRequest.h"
   39|       |#import "FIRGetAccountInfoResponse.h"
   40|       |#import "FIRGetOOBConfirmationCodeRequest.h"
   41|       |#import "FIRGetOOBConfirmationCodeResponse.h"
   42|       |#import "FIRSecureTokenService.h"
   43|       |#import "FIRSetAccountInfoRequest.h"
   44|       |#import "FIRSetAccountInfoResponse.h"
   45|       |#import "FIRSignInWithGameCenterRequest.h"
   46|       |#import "FIRSignInWithGameCenterResponse.h"
   47|       |#import "FIRUserInfoImpl.h"
   48|       |#import "FIRUserMetadata_Internal.h"
   49|       |#import "FIRVerifyAssertionRequest.h"
   50|       |#import "FIRVerifyAssertionResponse.h"
   51|       |#import "FIRVerifyCustomTokenRequest.h"
   52|       |#import "FIRVerifyCustomTokenResponse.h"
   53|       |#import "FIRVerifyPasswordRequest.h"
   54|       |#import "FIRVerifyPasswordResponse.h"
   55|       |#import "FIRVerifyPhoneNumberRequest.h"
   56|       |#import "FIRVerifyPhoneNumberResponse.h"
   57|       |
   58|       |#if TARGET_OS_IOS
   59|       |#import "FIRPhoneAuthProvider.h"
   60|       |#import "AuthProviders/Phone/FIRPhoneAuthCredential_Internal.h"
   61|       |#endif
   62|       |
   63|       |NS_ASSUME_NONNULL_BEGIN
   64|       |
   65|       |/** @var kUserIDCodingKey
   66|       |    @brief The key used to encode the user ID for NSSecureCoding.
   67|       | */
   68|       |static NSString *const kUserIDCodingKey = @"userID";
   69|       |
   70|       |/** @var kHasEmailPasswordCredentialCodingKey
   71|       |    @brief The key used to encode the hasEmailPasswordCredential property for NSSecureCoding.
   72|       | */
   73|       |static NSString *const kHasEmailPasswordCredentialCodingKey = @"hasEmailPassword";
   74|       |
   75|       |/** @var kAnonymousCodingKey
   76|       |    @brief The key used to encode the anonymous property for NSSecureCoding.
   77|       | */
   78|       |static NSString *const kAnonymousCodingKey = @"anonymous";
   79|       |
   80|       |/** @var kEmailCodingKey
   81|       |    @brief The key used to encode the email property for NSSecureCoding.
   82|       | */
   83|       |static NSString *const kEmailCodingKey = @"email";
   84|       |
   85|       |/** @var kPhoneNumberCodingKey
   86|       |    @brief The key used to encode the phoneNumber property for NSSecureCoding.
   87|       | */
   88|       |static NSString *const kPhoneNumberCodingKey = @"phoneNumber";
   89|       |
   90|       |/** @var kEmailVerifiedCodingKey
   91|       |    @brief The key used to encode the isEmailVerified property for NSSecureCoding.
   92|       | */
   93|       |static NSString *const kEmailVerifiedCodingKey = @"emailVerified";
   94|       |
   95|       |/** @var kDisplayNameCodingKey
   96|       |    @brief The key used to encode the displayName property for NSSecureCoding.
   97|       | */
   98|       |static NSString *const kDisplayNameCodingKey = @"displayName";
   99|       |
  100|       |/** @var kPhotoURLCodingKey
  101|       |    @brief The key used to encode the photoURL property for NSSecureCoding.
  102|       | */
  103|       |static NSString *const kPhotoURLCodingKey = @"photoURL";
  104|       |
  105|       |/** @var kProviderDataKey
  106|       |    @brief The key used to encode the providerData instance variable for NSSecureCoding.
  107|       | */
  108|       |static NSString *const kProviderDataKey = @"providerData";
  109|       |
  110|       |/** @var kAPIKeyCodingKey
  111|       |    @brief The key used to encode the APIKey instance variable for NSSecureCoding.
  112|       | */
  113|       |static NSString *const kAPIKeyCodingKey = @"APIKey";
  114|       |
  115|       |/** @var kTokenServiceCodingKey
  116|       |    @brief The key used to encode the tokenService instance variable for NSSecureCoding.
  117|       | */
  118|       |static NSString *const kTokenServiceCodingKey = @"tokenService";
  119|       |
  120|       |/** @var kMetadataCodingKey
  121|       |    @brief The key used to encode the metadata instance variable for NSSecureCoding.
  122|       | */
  123|       |static NSString *const kMetadataCodingKey = @"metadata";
  124|       |
  125|       |/** @var kMissingUsersErrorMessage
  126|       |    @brief The error message when there is no users array in the getAccountInfo response.
  127|       | */
  128|       |static NSString *const kMissingUsersErrorMessage = @"users";
  129|       |
  130|       |/** @typedef CallbackWithError
  131|       |    @brief The type for a callback block that only takes an error parameter.
  132|       | */
  133|       |typedef void (^CallbackWithError)(NSError *_Nullable);
  134|       |
  135|       |/** @typedef CallbackWithUserAndError
  136|       |    @brief The type for a callback block that takes a user parameter and an error parameter.
  137|       | */
  138|       |typedef void (^CallbackWithUserAndError)(FIRUser *_Nullable, NSError *_Nullable);
  139|       |
  140|       |/** @typedef CallbackWithUserAndError
  141|       |    @brief The type for a callback block that takes a user parameter and an error parameter.
  142|       | */
  143|       |typedef void (^CallbackWithAuthDataResultAndError)(FIRAuthDataResult *_Nullable,
  144|       |                                                   NSError *_Nullable);
  145|       |
  146|       |/** @var kMissingPasswordReason
  147|       |    @brief The reason why the @c FIRAuthErrorCodeWeakPassword error is thrown.
  148|       |    @remarks This error message will be localized in the future.
  149|       | */
  150|       |static NSString *const kMissingPasswordReason = @"Missing Password";
  151|       |
  152|       |/** @fn callInMainThreadWithError
  153|       |    @brief Calls a callback in main thread with error.
  154|       |    @param callback The callback to be called in main thread.
  155|       |    @param error The error to pass to callback.
  156|       | */
  157|       |static void callInMainThreadWithError(_Nullable CallbackWithError callback,
  158|      0|                                      NSError *_Nullable error) {
  159|      0|  if (callback) {
  160|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  161|      0|      callback(error);
  162|      0|    });
  163|      0|  }
  164|      0|}
  165|       |
  166|       |/** @fn callInMainThreadWithUserAndError
  167|       |    @brief Calls a callback in main thread with user and error.
  168|       |    @param callback The callback to be called in main thread.
  169|       |    @param user The user to pass to callback if there is no error.
  170|       |    @param error The error to pass to callback.
  171|       | */
  172|       |static void callInMainThreadWithUserAndError(_Nullable CallbackWithUserAndError callback,
  173|       |                                             FIRUser *_Nonnull user,
  174|      0|                                             NSError *_Nullable error) {
  175|      0|  if (callback) {
  176|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  177|      0|      callback(error ? nil : user, error);
  178|      0|    });
  179|      0|  }
  180|      0|}
  181|       |
  182|       |/** @fn callInMainThreadWithUserAndError
  183|       |    @brief Calls a callback in main thread with user and error.
  184|       |    @param callback The callback to be called in main thread.
  185|       |    @param result The result to pass to callback if there is no error.
  186|       |    @param error The error to pass to callback.
  187|       | */
  188|       |static void callInMainThreadWithAuthDataResultAndError(
  189|       |    _Nullable CallbackWithAuthDataResultAndError callback,
  190|       |    FIRAuthDataResult *_Nullable result,
  191|      0|    NSError *_Nullable error) {
  192|      0|  if (callback) {
  193|      0|    dispatch_async(dispatch_get_main_queue(), ^{
  194|      0|      callback(result, error);
  195|      0|    });
  196|      0|  }
  197|      0|}
  198|       |
  199|       |@interface FIRUserProfileChangeRequest ()
  200|       |
  201|       |/** @fn initWithUser:
  202|       |    @brief Designated initializer.
  203|       |    @param user The user for which we are updating profile information.
  204|       | */
  205|       |- (nullable instancetype)initWithUser:(FIRUser *)user NS_DESIGNATED_INITIALIZER;
  206|       |
  207|       |@end
  208|       |
  209|       |@interface FIRUser ()
  210|       |
  211|       |/** @property anonymous
  212|       | @brief Whether the current user is anonymous.
  213|       | */
  214|       |@property(nonatomic, readwrite) BOOL anonymous;
  215|       |
  216|       |@end
  217|       |
  218|       |@implementation FIRUser {
  219|       |  /** @var _hasEmailPasswordCredential
  220|       |      @brief Whether or not the user can be authenticated by using Firebase email and password.
  221|       |   */
  222|       |  BOOL _hasEmailPasswordCredential;
  223|       |
  224|       |  /** @var _providerData
  225|       |      @brief Provider specific user data.
  226|       |   */
  227|       |  NSDictionary<NSString *, FIRUserInfoImpl *> *_providerData;
  228|       |
  229|       |  /** @var _taskQueue
  230|       |      @brief Used to serialize the update profile calls.
  231|       |   */
  232|       |  FIRAuthSerialTaskQueue *_taskQueue;
  233|       |
  234|       |  /** @var _tokenService
  235|       |      @brief A secure token service associated with this user. For performing token exchanges and
  236|       |          refreshing access tokens.
  237|       |   */
  238|       |  FIRSecureTokenService *_tokenService;
  239|       |}
  240|       |
  241|       |#pragma mark - Properties
  242|       |
  243|       |// Explicitly @synthesize because these properties are defined in FIRUserInfo protocol.
  244|       |@synthesize uid = _userID;
  245|       |@synthesize displayName = _displayName;
  246|       |@synthesize photoURL = _photoURL;
  247|       |@synthesize email = _email;
  248|       |@synthesize phoneNumber = _phoneNumber;
  249|       |
  250|       |#pragma mark -
  251|       |
  252|       |+ (void)retrieveUserWithAuth:(FIRAuth *)auth
  253|       |                 accessToken:(nullable NSString *)accessToken
  254|       |   accessTokenExpirationDate:(nullable NSDate *)accessTokenExpirationDate
  255|       |                refreshToken:(nullable NSString *)refreshToken
  256|       |                   anonymous:(BOOL)anonymous
  257|      0|                    callback:(FIRRetrieveUserCallback)callback {
  258|      0|  FIRSecureTokenService *tokenService =
  259|      0|      [[FIRSecureTokenService alloc] initWithRequestConfiguration:auth.requestConfiguration
  260|      0|                                                      accessToken:accessToken
  261|      0|                                        accessTokenExpirationDate:accessTokenExpirationDate
  262|      0|                                                     refreshToken:refreshToken];
  263|      0|  FIRUser *user = [[self alloc] initWithTokenService:tokenService];
  264|      0|  user.auth = auth;
  265|      0|  user.requestConfiguration = auth.requestConfiguration;
  266|      0|  [user internalGetTokenWithCallback:^(NSString *_Nullable accessToken, NSError *_Nullable error) {
  267|      0|    if (error) {
  268|      0|      callback(nil, error);
  269|      0|      return;
  270|      0|    }
  271|      0|    FIRGetAccountInfoRequest *getAccountInfoRequest =
  272|      0|        [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
  273|      0|                                         requestConfiguration:auth.requestConfiguration];
  274|      0|    [FIRAuthBackend getAccountInfo:getAccountInfoRequest
  275|      0|                          callback:^(FIRGetAccountInfoResponse *_Nullable response,
  276|      0|                                     NSError *_Nullable error) {
  277|      0|      if (error) {
  278|      0|        // No need to sign out user here for errors because the user hasn't been signed in yet.
  279|      0|        callback(nil, error);
  280|      0|        return;
  281|      0|      }
  282|      0|      user.anonymous = anonymous;
  283|      0|      [user updateWithGetAccountInfoResponse:response];
  284|      0|      callback(user, nil);
  285|      0|    }];
  286|      0|  }];
  287|      0|}
  288|       |
  289|      0|- (instancetype)initWithTokenService:(FIRSecureTokenService *)tokenService {
  290|      0|  self = [super init];
  291|      0|  if (self) {
  292|      0|    _providerData = @{ };
  293|      0|    _taskQueue = [[FIRAuthSerialTaskQueue alloc] init];
  294|      0|    _tokenService = tokenService;
  295|      0|  }
  296|      0|  return self;
  297|      0|}
  298|       |
  299|       |#pragma mark - NSSecureCoding
  300|       |
  301|      0|+ (BOOL)supportsSecureCoding {
  302|      0|  return YES;
  303|      0|}
  304|       |
  305|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
  306|      0|  NSString *userID = [aDecoder decodeObjectOfClass:[NSString class] forKey:kUserIDCodingKey];
  307|      0|  BOOL hasAnonymousKey = [aDecoder containsValueForKey:kAnonymousCodingKey];
  308|      0|  BOOL anonymous = [aDecoder decodeBoolForKey:kAnonymousCodingKey];
  309|      0|  BOOL hasEmailPasswordCredential =
  310|      0|      [aDecoder decodeBoolForKey:kHasEmailPasswordCredentialCodingKey];
  311|      0|  NSString *displayName =
  312|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kDisplayNameCodingKey];
  313|      0|  NSURL *photoURL =
  314|      0|      [aDecoder decodeObjectOfClass:[NSURL class] forKey:kPhotoURLCodingKey];
  315|      0|  NSString *email =
  316|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kEmailCodingKey];
  317|      0|  NSString *phoneNumber =
  318|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kPhoneNumberCodingKey];
  319|      0|  BOOL emailVerified = [aDecoder decodeBoolForKey:kEmailVerifiedCodingKey];
  320|      0|  NSSet *providerDataClasses = [NSSet setWithArray:@[
  321|      0|      [NSDictionary class],
  322|      0|      [NSString class],
  323|      0|      [FIRUserInfoImpl class]
  324|      0|  ]];
  325|      0|  NSDictionary<NSString *, FIRUserInfoImpl *> *providerData =
  326|      0|      [aDecoder decodeObjectOfClasses:providerDataClasses forKey:kProviderDataKey];
  327|      0|  FIRSecureTokenService *tokenService =
  328|      0|      [aDecoder decodeObjectOfClass:[FIRSecureTokenService class] forKey:kTokenServiceCodingKey];
  329|      0|  FIRUserMetadata *metadata =
  330|      0|      [aDecoder decodeObjectOfClass:[FIRUserMetadata class] forKey:kMetadataCodingKey];
  331|      0|  NSString *APIKey =
  332|      0|      [aDecoder decodeObjectOfClass:[FIRUserMetadata class] forKey:kAPIKeyCodingKey];
  333|      0|  if (!userID || !tokenService) {
  334|      0|    return nil;
  335|      0|  }
  336|      0|  self = [self initWithTokenService:tokenService];
  337|      0|  if (self) {
  338|      0|    _userID = userID;
  339|      0|    // Previous version of this code didn't save 'anonymous' bit directly but deduced it from
  340|      0|    // 'hasEmailPasswordCredential' and 'providerData' instead, so here backward compatibility is
  341|      0|    // provided to read old format data.
  342|      0|    _anonymous = hasAnonymousKey ? anonymous : (!hasEmailPasswordCredential && !providerData.count);
  343|      0|    _hasEmailPasswordCredential = hasEmailPasswordCredential;
  344|      0|    _email = email;
  345|      0|    _emailVerified = emailVerified;
  346|      0|    _displayName = displayName;
  347|      0|    _photoURL = photoURL;
  348|      0|    _providerData = providerData;
  349|      0|    _phoneNumber = phoneNumber;
  350|      0|    _metadata = metadata ?: [[FIRUserMetadata alloc] initWithCreationDate:nil lastSignInDate:nil];
  351|      0|    _requestConfiguration = [[FIRAuthRequestConfiguration alloc] initWithAPIKey:APIKey];
  352|      0|  }
  353|      0|  return self;
  354|      0|}
  355|       |
  356|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  357|      0|  [aCoder encodeObject:_userID forKey:kUserIDCodingKey];
  358|      0|  [aCoder encodeBool:self.anonymous forKey:kAnonymousCodingKey];
  359|      0|  [aCoder encodeBool:_hasEmailPasswordCredential forKey:kHasEmailPasswordCredentialCodingKey];
  360|      0|  [aCoder encodeObject:_providerData forKey:kProviderDataKey];
  361|      0|  [aCoder encodeObject:_email forKey:kEmailCodingKey];
  362|      0|  [aCoder encodeObject:_phoneNumber forKey:kPhoneNumberCodingKey];
  363|      0|  [aCoder encodeBool:_emailVerified forKey:kEmailVerifiedCodingKey];
  364|      0|  [aCoder encodeObject:_photoURL forKey:kPhotoURLCodingKey];
  365|      0|  [aCoder encodeObject:_displayName forKey:kDisplayNameCodingKey];
  366|      0|  [aCoder encodeObject:_metadata forKey:kMetadataCodingKey];
  367|      0|  [aCoder encodeObject:_auth.requestConfiguration.APIKey forKey:kAPIKeyCodingKey];
  368|      0|  [aCoder encodeObject:_tokenService forKey:kTokenServiceCodingKey];
  369|      0|}
  370|       |
  371|       |#pragma mark -
  372|       |
  373|      0|- (void)setAuth:(nullable FIRAuth *)auth {
  374|      0|  _auth = auth;
  375|      0|  _tokenService.requestConfiguration = auth.requestConfiguration;
  376|      0|}
  377|       |
  378|      0|- (NSString *)providerID {
  379|      0|  return @"Firebase";
  380|      0|}
  381|       |
  382|      0|- (NSArray<id<FIRUserInfo>> *)providerData {
  383|      0|  return _providerData.allValues;
  384|      0|}
  385|       |
  386|       |/** @fn getAccountInfoRefreshingCache:
  387|       |    @brief Gets the users's account data from the server, updating our local values.
  388|       |    @param callback Invoked when the request to getAccountInfo has completed, or when an error has
  389|       |        been detected. Invoked asynchronously on the auth global work queue in the future.
  390|       | */
  391|       |- (void)getAccountInfoRefreshingCache:(void(^)(FIRGetAccountInfoResponseUser *_Nullable user,
  392|      0|                                               NSError *_Nullable error))callback {
  393|      0|  [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken, NSError *_Nullable error) {
  394|      0|    if (error) {
  395|      0|      callback(nil, error);
  396|      0|      return;
  397|      0|    }
  398|      0|    FIRGetAccountInfoRequest *getAccountInfoRequest =
  399|      0|        [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
  400|      0|                                         requestConfiguration:self->_auth.requestConfiguration];
  401|      0|    [FIRAuthBackend getAccountInfo:getAccountInfoRequest
  402|      0|                          callback:^(FIRGetAccountInfoResponse *_Nullable response,
  403|      0|                                     NSError *_Nullable error) {
  404|      0|      if (error) {
  405|      0|        [self signOutIfTokenIsInvalidWithError:error];
  406|      0|        callback(nil, error);
  407|      0|        return;
  408|      0|      }
  409|      0|      [self updateWithGetAccountInfoResponse:response];
  410|      0|      if (![self updateKeychain:&error]) {
  411|      0|        callback(nil, error);
  412|      0|        return;
  413|      0|      }
  414|      0|      callback(response.users.firstObject, nil);
  415|      0|    }];
  416|      0|  }];
  417|      0|}
  418|       |
  419|      0|- (void)updateWithGetAccountInfoResponse:(FIRGetAccountInfoResponse *)response {
  420|      0|  FIRGetAccountInfoResponseUser *user = response.users.firstObject;
  421|      0|  _userID = user.localID;
  422|      0|  _email = user.email;
  423|      0|  _emailVerified = user.emailVerified;
  424|      0|  _displayName = user.displayName;
  425|      0|  _photoURL = user.photoURL;
  426|      0|  _phoneNumber = user.phoneNumber;
  427|      0|  _hasEmailPasswordCredential = user.passwordHash.length > 0;
  428|      0|  _metadata =
  429|      0|      [[FIRUserMetadata alloc]initWithCreationDate:user.creationDate
  430|      0|                                    lastSignInDate:user.lastLoginDate];
  431|      0|  NSMutableDictionary<NSString *, FIRUserInfoImpl *> *providerData =
  432|      0|      [NSMutableDictionary dictionary];
  433|      0|  for (FIRGetAccountInfoResponseProviderUserInfo *providerUserInfo in user.providerUserInfo) {
  434|      0|    FIRUserInfoImpl *userInfo =
  435|      0|        [FIRUserInfoImpl userInfoWithGetAccountInfoResponseProviderUserInfo:providerUserInfo];
  436|      0|    if (userInfo) {
  437|      0|      providerData[providerUserInfo.providerID] = userInfo;
  438|      0|    }
  439|      0|  }
  440|      0|  _providerData = [providerData copy];
  441|      0|}
  442|       |
  443|       |/** @fn executeUserUpdateWithChanges:callback:
  444|       |    @brief Performs a setAccountInfo request by mutating the results of a getAccountInfo response,
  445|       |        atomically in regards to other calls to this method.
  446|       |    @param changeBlock A block responsible for mutating a template @c FIRSetAccountInfoRequest
  447|       |    @param callback A block to invoke when the change is complete. Invoked asynchronously on the
  448|       |        auth global work queue in the future.
  449|       | */
  450|       |- (void)executeUserUpdateWithChanges:(void(^)(FIRGetAccountInfoResponseUser *,
  451|       |                                              FIRSetAccountInfoRequest *))changeBlock
  452|      0|                            callback:(nonnull FIRUserProfileChangeCallback)callback {
  453|      0|  [_taskQueue enqueueTask:^(FIRAuthSerialTaskCompletionBlock _Nonnull complete) {
  454|      0|    [self getAccountInfoRefreshingCache:^(FIRGetAccountInfoResponseUser *_Nullable user,
  455|      0|                                          NSError *_Nullable error) {
  456|      0|      if (error) {
  457|      0|        complete();
  458|      0|        callback(error);
  459|      0|        return;
  460|      0|      }
  461|      0|      [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
  462|      0|                                           NSError *_Nullable error) {
  463|      0|        if (error) {
  464|      0|          complete();
  465|      0|          callback(error);
  466|      0|          return;
  467|      0|        }
  468|      0|        FIRAuthRequestConfiguration *configuration = self->_auth.requestConfiguration;
  469|      0|        // Mutate setAccountInfoRequest in block:
  470|      0|        FIRSetAccountInfoRequest *setAccountInfoRequest =
  471|      0|            [[FIRSetAccountInfoRequest alloc] initWithRequestConfiguration:configuration];
  472|      0|        setAccountInfoRequest.accessToken = accessToken;
  473|      0|        changeBlock(user, setAccountInfoRequest);
  474|      0|        // Execute request:
  475|      0|        [FIRAuthBackend setAccountInfo:setAccountInfoRequest
  476|      0|                              callback:^(FIRSetAccountInfoResponse *_Nullable response,
  477|      0|                                         NSError *_Nullable error) {
  478|      0|          if (error) {
  479|      0|            [self signOutIfTokenIsInvalidWithError:error];
  480|      0|            complete();
  481|      0|            callback(error);
  482|      0|            return;
  483|      0|          }
  484|      0|          if (response.IDToken && response.refreshToken) {
  485|      0|            FIRSecureTokenService *tokenService = [[FIRSecureTokenService alloc]
  486|      0|                initWithRequestConfiguration:configuration
  487|      0|                                 accessToken:response.IDToken
  488|      0|                   accessTokenExpirationDate:response.approximateExpirationDate
  489|      0|                                refreshToken:response.refreshToken];
  490|      0|            [self setTokenService:tokenService callback:^(NSError *_Nullable error) {
  491|      0|              complete();
  492|      0|              callback(error);
  493|      0|            }];
  494|      0|            return;
  495|      0|          }
  496|      0|          complete();
  497|      0|          callback(nil);
  498|      0|        }];
  499|      0|      }];
  500|      0|    }];
  501|      0|  }];
  502|      0|}
  503|       |
  504|       |/** @fn updateKeychain:
  505|       |    @brief Updates the keychain for user token or info changes.
  506|       |    @param error The error if NO is returned.
  507|       |    @return Whether the operation is successful.
  508|       | */
  509|      0|- (BOOL)updateKeychain:(NSError *_Nullable *_Nullable)error {
  510|      0|  return [_auth updateKeychainWithUser:self error:error];
  511|      0|}
  512|       |
  513|       |/** @fn setTokenService:callback:
  514|       |    @brief Sets a new token service for the @c FIRUser instance.
  515|       |    @param tokenService The new token service object.
  516|       |    @param callback The block to be called in the global auth working queue once finished.
  517|       |    @remarks The method makes sure the token service has access and refresh token and the new tokens
  518|       |        are saved in the keychain before calling back.
  519|       | */
  520|       |- (void)setTokenService:(FIRSecureTokenService *)tokenService
  521|      0|               callback:(nonnull CallbackWithError)callback {
  522|      0|  [tokenService fetchAccessTokenForcingRefresh:NO
  523|      0|                                      callback:^(NSString *_Nullable token,
  524|      0|                                                 NSError *_Nullable error,
  525|      0|                                                 BOOL tokenUpdated) {
  526|      0|    if (error) {
  527|      0|      callback(error);
  528|      0|      return;
  529|      0|    }
  530|      0|    self->_tokenService = tokenService;
  531|      0|    if (![self updateKeychain:&error]) {
  532|      0|      callback(error);
  533|      0|      return;
  534|      0|    }
  535|      0|    callback(nil);
  536|      0|  }];
  537|      0|}
  538|       |
  539|       |#pragma mark -
  540|       |
  541|       |/** @fn updateEmail:password:callback:
  542|       |    @brief Updates email address and/or password for the current user.
  543|       |    @remarks May fail if there is already an email/password-based account for the same email
  544|       |        address.
  545|       |    @param email The email address for the user, if to be updated.
  546|       |    @param password The new password for the user, if to be updated.
  547|       |    @param callback The block called when the user profile change has finished. Invoked
  548|       |        asynchronously on the auth global work queue in the future.
  549|       |    @remarks May fail with a @c FIRAuthErrorCodeRequiresRecentLogin error code.
  550|       |        Call @c reauthentateWithCredential:completion: beforehand to avoid this error case.
  551|       | */
  552|       |- (void)updateEmail:(nullable NSString *)email
  553|       |           password:(nullable NSString *)password
  554|      0|           callback:(nonnull FIRUserProfileChangeCallback)callback {
  555|      0|  if (password && ![password length]) {
  556|      0|    callback([FIRAuthErrorUtils weakPasswordErrorWithServerResponseReason:kMissingPasswordReason]);
  557|      0|    return;
  558|      0|  }
  559|      0|  BOOL hadEmailPasswordCredential = _hasEmailPasswordCredential;
  560|      0|  [self executeUserUpdateWithChanges:^(FIRGetAccountInfoResponseUser *user,
  561|      0|                                       FIRSetAccountInfoRequest *request) {
  562|      0|    if (email) {
  563|      0|      request.email = email;
  564|      0|    }
  565|      0|    if (password) {
  566|      0|      request.password = password;
  567|      0|    }
  568|      0|  }
  569|      0|                            callback:^(NSError *error) {
  570|      0|    if (error) {
  571|      0|      callback(error);
  572|      0|      return;
  573|      0|    }
  574|      0|    if (email) {
  575|      0|      self->_email = [email copy];
  576|      0|    }
  577|      0|    if (self->_email) {
  578|      0|      if (!hadEmailPasswordCredential) {
  579|      0|        // The list of providers need to be updated for the newly added email-password provider.
  580|      0|        [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
  581|      0|                                             NSError *_Nullable error) {
  582|      0|          if (error) {
  583|      0|            callback(error);
  584|      0|            return;
  585|      0|          }
  586|      0|          FIRAuthRequestConfiguration *requestConfiguration = self->_auth.requestConfiguration;
  587|      0|          FIRGetAccountInfoRequest *getAccountInfoRequest =
  588|      0|              [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
  589|      0|                                               requestConfiguration:requestConfiguration];
  590|      0|          [FIRAuthBackend getAccountInfo:getAccountInfoRequest
  591|      0|                                callback:^(FIRGetAccountInfoResponse *_Nullable response,
  592|      0|                                           NSError *_Nullable error) {
  593|      0|            if (error) {
  594|      0|              [self signOutIfTokenIsInvalidWithError:error];
  595|      0|              callback(error);
  596|      0|              return;
  597|      0|            }
  598|      0|            for (FIRGetAccountInfoResponseUser *userAccountInfo in response.users) {
  599|      0|              // Set the account to non-anonymous if there are any providers, even if
  600|      0|              // they're not email/password ones.
  601|      0|              if (userAccountInfo.providerUserInfo.count > 0) {
  602|      0|                self.anonymous = NO;
  603|      0|              }
  604|      0|              for (FIRGetAccountInfoResponseProviderUserInfo *providerUserInfo in
  605|      0|                   userAccountInfo.providerUserInfo) {
  606|      0|                if ([providerUserInfo.providerID isEqualToString:FIREmailAuthProviderID]) {
  607|      0|                  self->_hasEmailPasswordCredential = YES;
  608|      0|                  break;
  609|      0|                }
  610|      0|              }
  611|      0|            }
  612|      0|            [self updateWithGetAccountInfoResponse:response];
  613|      0|            if (![self updateKeychain:&error]) {
  614|      0|              callback(error);
  615|      0|              return;
  616|      0|            }
  617|      0|            callback(nil);
  618|      0|          }];
  619|      0|        }];
  620|      0|        return;
  621|      0|      }
  622|      0|    }
  623|      0|    if (![self updateKeychain:&error]) {
  624|      0|      callback(error);
  625|      0|      return;
  626|      0|    }
  627|      0|    callback(nil);
  628|      0|  }];
  629|      0|}
  630|       |
  631|      0|- (void)updateEmail:(NSString *)email completion:(nullable FIRUserProfileChangeCallback)completion {
  632|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  633|      0|    [self updateEmail:email password:nil callback:^(NSError *_Nullable error) {
  634|      0|      callInMainThreadWithError(completion, error);
  635|      0|    }];
  636|      0|  });
  637|      0|}
  638|       |
  639|       |- (void)updatePassword:(NSString *)password
  640|      0|            completion:(nullable FIRUserProfileChangeCallback)completion {
  641|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  642|      0|    [self updateEmail:nil password:password callback:^(NSError *_Nullable error){
  643|      0|      callInMainThreadWithError(completion, error);
  644|      0|    }];
  645|      0|  });
  646|      0|}
  647|       |
  648|       |#if TARGET_OS_IOS
  649|       |/** @fn internalUpdateOrLinkPhoneNumberCredential:completion:
  650|       |    @brief Updates the phone number for the user. On success, the cached user profile data is
  651|       |        updated.
  652|       |
  653|       |    @param phoneAuthCredential The new phone number credential corresponding to the phone number
  654|       |        to be added to the Firebase account, if a phone number is already linked to the account this
  655|       |        new phone number will replace it.
  656|       |    @param isLinkOperation Boolean value indicating whether or not this is a link operation.
  657|       |    @param completion Optionally; the block invoked when the user profile change has finished.
  658|       |        Invoked asynchronously on the global work queue in the future.
  659|       | */
  660|       |- (void)internalUpdateOrLinkPhoneNumberCredential:(FIRPhoneAuthCredential *)phoneAuthCredential
  661|       |                                  isLinkOperation:(BOOL)isLinkOperation
  662|      0|                                       completion:(FIRUserProfileChangeCallback)completion {
  663|      0|  [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
  664|      0|                                       NSError *_Nullable error) {
  665|      0|    if (error) {
  666|      0|      completion(error);
  667|      0|      return;
  668|      0|    }
  669|      0|    FIRAuthOperationType operation =
  670|      0|        isLinkOperation ? FIRAuthOperationTypeLink : FIRAuthOperationTypeUpdate;
  671|      0|    FIRVerifyPhoneNumberRequest *request = [[FIRVerifyPhoneNumberRequest alloc]
  672|      0|        initWithVerificationID:phoneAuthCredential.verificationID
  673|      0|              verificationCode:phoneAuthCredential.verificationCode
  674|      0|                     operation:operation
  675|      0|          requestConfiguration:self->_auth.requestConfiguration];
  676|      0|    request.accessToken = accessToken;
  677|      0|    [FIRAuthBackend verifyPhoneNumber:request
  678|      0|                             callback:^(FIRVerifyPhoneNumberResponse *_Nullable response,
  679|      0|                                        NSError *_Nullable error) {
  680|      0|      if (error) {
  681|      0|        [self signOutIfTokenIsInvalidWithError:error];
  682|      0|        completion(error);
  683|      0|        return;
  684|      0|      }
  685|      0|      // Get account info to update cached user info.
  686|      0|      [self getAccountInfoRefreshingCache:^(FIRGetAccountInfoResponseUser *_Nullable user,
  687|      0|                                            NSError *_Nullable error) {
  688|      0|        if (error) {
  689|      0|          [self signOutIfTokenIsInvalidWithError:error];
  690|      0|          completion(error);
  691|      0|          return;
  692|      0|        }
  693|      0|        self.anonymous = NO;
  694|      0|        if (![self updateKeychain:&error]) {
  695|      0|          completion(error);
  696|      0|          return;
  697|      0|        }
  698|      0|        completion(nil);
  699|      0|      }];
  700|      0|    }];
  701|      0|  }];
  702|      0|}
  703|       |
  704|       |- (void)updatePhoneNumberCredential:(FIRPhoneAuthCredential *)phoneAuthCredential
  705|      0|                         completion:(nullable FIRUserProfileChangeCallback)completion {
  706|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  707|      0|    [self internalUpdateOrLinkPhoneNumberCredential:phoneAuthCredential
  708|      0|                                    isLinkOperation:NO
  709|      0|                                         completion:^(NSError *_Nullable error) {
  710|      0|       callInMainThreadWithError(completion, error);
  711|      0|    }];
  712|      0|  });
  713|      0|}
  714|       |#endif
  715|       |
  716|      0|- (FIRUserProfileChangeRequest *)profileChangeRequest {
  717|      0|  __block FIRUserProfileChangeRequest *result;
  718|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
  719|      0|    result = [[FIRUserProfileChangeRequest alloc] initWithUser:self];
  720|      0|  });
  721|      0|  return result;
  722|      0|}
  723|       |
  724|      0|- (void)setDisplayName:(NSString *)displayName {
  725|      0|  _displayName = [displayName copy];
  726|      0|}
  727|       |
  728|      0|- (void)setPhotoURL:(NSURL *)photoURL {
  729|      0|  _photoURL = [photoURL copy];
  730|      0|}
  731|       |
  732|      0|- (NSString *)rawAccessToken {
  733|      0|  return _tokenService.rawAccessToken;
  734|      0|}
  735|       |
  736|      0|- (NSDate *)accessTokenExpirationDate {
  737|      0|  return _tokenService.accessTokenExpirationDate;
  738|      0|}
  739|       |
  740|       |#pragma mark -
  741|       |
  742|      0|- (void)reloadWithCompletion:(nullable FIRUserProfileChangeCallback)completion {
  743|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  744|      0|    [self getAccountInfoRefreshingCache:^(FIRGetAccountInfoResponseUser *_Nullable user,
  745|      0|                                          NSError *_Nullable error) {
  746|      0|      callInMainThreadWithError(completion, error);
  747|      0|    }];
  748|      0|  });
  749|      0|}
  750|       |
  751|       |#pragma mark -
  752|       |
  753|       |- (void)reauthenticateWithCredential:(FIRAuthCredential *)credential
  754|      0|                          completion:(nullable FIRUserProfileChangeCallback)completion {
  755|      0|  FIRAuthDataResultCallback callback = ^(FIRAuthDataResult *_Nullable authResult,
  756|      0|                                         NSError *_Nullable error) {
  757|      0|    completion(error);
  758|      0|  };
  759|      0|  [self reauthenticateAndRetrieveDataWithCredential:credential completion:callback];
  760|      0|}
  761|       |
  762|       |- (void)
  763|       |    reauthenticateAndRetrieveDataWithCredential:(FIRAuthCredential *) credential
  764|      0|                                     completion:(nullable FIRAuthDataResultCallback) completion {
  765|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  766|      0|    [self->_auth internalSignInAndRetrieveDataWithCredential:credential
  767|      0|                                          isReauthentication:YES
  768|      0|                                                    callback:^(FIRAuthDataResult *_Nullable
  769|      0|                                                               authResult,
  770|      0|                                                               NSError *_Nullable error) {
  771|      0|      if (error) {
  772|      0|        // If "user not found" error returned by backend, translate to user mismatch error which is
  773|      0|        // more accurate.
  774|      0|        if (error.code == FIRAuthErrorCodeUserNotFound) {
  775|      0|          error = [FIRAuthErrorUtils userMismatchError];
  776|      0|        }
  777|      0|        callInMainThreadWithAuthDataResultAndError(completion, authResult, error);
  778|      0|        return;
  779|      0|      }
  780|      0|      if (![authResult.user.uid isEqual:[self->_auth getUserID]]) {
  781|      0|        callInMainThreadWithAuthDataResultAndError(completion, authResult,
  782|      0|                                                   [FIRAuthErrorUtils userMismatchError]);
  783|      0|        return;
  784|      0|      }
  785|      0|      // Successful reauthenticate
  786|      0|      [self setTokenService:authResult.user->_tokenService callback:^(NSError *_Nullable error) {
  787|      0|        callInMainThreadWithAuthDataResultAndError(completion, authResult, error);
  788|      0|      }];
  789|      0|    }];
  790|      0|  });
  791|      0|}
  792|       |
  793|      0|- (nullable NSString *)refreshToken {
  794|      0|  __block NSString *result;
  795|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
  796|      0|    result = self->_tokenService.refreshToken;
  797|      0|  });
  798|      0|  return result;
  799|      0|}
  800|       |
  801|      0|- (void)getIDTokenWithCompletion:(nullable FIRAuthTokenCallback)completion {
  802|      0|  // |getIDTokenForcingRefresh:completion:| is also a public API so there is no need to dispatch to
  803|      0|  // global work queue here.
  804|      0|  [self getIDTokenForcingRefresh:NO completion:completion];
  805|      0|}
  806|       |
  807|       |- (void)getIDTokenForcingRefresh:(BOOL)forceRefresh
  808|      0|                      completion:(nullable FIRAuthTokenCallback)completion {
  809|      0|  [self getIDTokenResultForcingRefresh:forceRefresh
  810|      0|                            completion:^(FIRAuthTokenResult *_Nullable tokenResult,
  811|      0|                                         NSError *_Nullable error) {
  812|      0|
  813|      0|    if (completion) {
  814|      0|      dispatch_async(dispatch_get_main_queue(), ^{
  815|      0|        completion(tokenResult.token, error);
  816|      0|      });
  817|      0|    }
  818|      0|  }];
  819|      0|}
  820|       |
  821|      0|- (void)getIDTokenResultWithCompletion:(nullable FIRAuthTokenResultCallback)completion {
  822|      0|  [self getIDTokenResultForcingRefresh:NO
  823|      0|                            completion:^(FIRAuthTokenResult *_Nullable tokenResult,
  824|      0|                                         NSError *_Nullable error) {
  825|      0|    if (completion) {
  826|      0|      dispatch_async(dispatch_get_main_queue(), ^{
  827|      0|        completion(tokenResult, error);
  828|      0|      });
  829|      0|    }
  830|      0|  }];
  831|      0|}
  832|       |
  833|       |- (void)getIDTokenResultForcingRefresh:(BOOL)forceRefresh
  834|      0|                            completion:(nullable FIRAuthTokenResultCallback)completion {
  835|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  836|      0|    [self internalGetTokenForcingRefresh:forceRefresh
  837|      0|                                callback:^(NSString *_Nullable token, NSError *_Nullable error) {
  838|      0|      FIRAuthTokenResult *tokenResult;
  839|      0|      if (token) {
  840|      0|        tokenResult = [self parseIDToken:token error:&error];
  841|      0|      }
  842|      0|      if (completion) {
  843|      0|        dispatch_async(dispatch_get_main_queue(), ^{
  844|      0|          completion(tokenResult, error);
  845|      0|        });
  846|      0|      }
  847|      0|    }];
  848|      0|  });
  849|      0|}
  850|       |
  851|       |/** @fn parseIDToken:error:
  852|       |    @brief Parses the provided IDToken and returns an instance of FIRAuthTokenResult containing
  853|       |        claims obtained from the IDToken.
  854|       |
  855|       |    @param token The raw text of the Firebase IDToken encoded in base64.
  856|       |    @param error An out parameter which would contain any error that occurs during parsing.
  857|       |    @return An instance of FIRAuthTokenResult containing claims obtained from the IDToken.
  858|       |
  859|       |    @remarks IDToken returned from the backend in some cases is of a length that is not a multiple
  860|       |        of 4. In these cases this function pads the token with as many "=" characters as needed and
  861|       |        then attempts to parse the token. If the token cannot be parsed an error is returned via the
  862|       |        "error" out parameter.
  863|       | */
  864|      0|- (nullable FIRAuthTokenResult *)parseIDToken:(NSString *)token error:(NSError **)error {
  865|      0|  // Though this is an internal method, errors returned here are surfaced in user-visible
  866|      0|  // callbacks.
  867|      0|  if (error) {
  868|      0|    *error = nil;
  869|      0|  }
  870|      0|  NSArray *tokenStringArray = [token componentsSeparatedByString:@"."];
  871|      0|
  872|      0|  // The JWT should have three parts, though we only use the second in this method.
  873|      0|  if (tokenStringArray.count != 3) {
  874|      0|    if (error) {
  875|      0|      *error = [FIRAuthErrorUtils malformedJWTErrorWithToken:token underlyingError:nil];
  876|      0|    }
  877|      0|    return nil;
  878|      0|  }
  879|      0|
  880|      0|  // The token payload is always the second index of the array.
  881|      0|  NSString *idToken = tokenStringArray[1];
  882|      0|
  883|      0|  // Convert the base64URL encoded string to a base64 encoded string.
  884|      0|  // Replace "_" with "/"
  885|      0|  NSMutableString *tokenPayload =
  886|      0|      [[idToken stringByReplacingOccurrencesOfString:@"_" withString:@"/"] mutableCopy];
  887|      0|
  888|      0|  // Replace "-" with "+"
  889|      0|  [tokenPayload replaceOccurrencesOfString:@"-"
  890|      0|                                withString:@"+"
  891|      0|                                   options:kNilOptions
  892|      0|                                     range:NSMakeRange(0, tokenPayload.length)];
  893|      0|
  894|      0|  // Pad the token payload with "=" signs if the payload's length is not a multiple of 4.
  895|      0|  while ((tokenPayload.length % 4) != 0) {
  896|      0|    [tokenPayload appendFormat:@"="];
  897|      0|  }
  898|      0|  NSData *decodedTokenPayloadData =
  899|      0|      [[NSData alloc] initWithBase64EncodedString:tokenPayload
  900|      0|                                          options:NSDataBase64DecodingIgnoreUnknownCharacters];
  901|      0|  if (!decodedTokenPayloadData) {
  902|      0|    if (error) {
  903|      0|      *error = [FIRAuthErrorUtils malformedJWTErrorWithToken:token underlyingError:nil];
  904|      0|    }
  905|      0|    return nil;
  906|      0|  }
  907|      0|  NSError *jsonError = nil;
  908|      0|  NSJSONReadingOptions options = NSJSONReadingMutableContainers|NSJSONReadingAllowFragments;
  909|      0|  NSDictionary *tokenPayloadDictionary =
  910|      0|      [NSJSONSerialization JSONObjectWithData:decodedTokenPayloadData
  911|      0|                                      options:options
  912|      0|                                        error:&jsonError];
  913|      0|  if (jsonError != nil) {
  914|      0|    if (error) {
  915|      0|      *error = [FIRAuthErrorUtils malformedJWTErrorWithToken:token underlyingError:jsonError];
  916|      0|    }
  917|      0|    return nil;
  918|      0|  }
  919|      0|
  920|      0|  if (!tokenPayloadDictionary) {
  921|      0|    if (error) {
  922|      0|      *error = [FIRAuthErrorUtils malformedJWTErrorWithToken:token underlyingError:nil];
  923|      0|    }
  924|      0|    return nil;
  925|      0|  }
  926|      0|
  927|      0|  // These are dates since 00:00:00 January 1 1970, as described by the Terminology section in
  928|      0|  // the JWT spec. https://tools.ietf.org/html/rfc7519
  929|      0|  NSDate *expDate =
  930|      0|      [NSDate dateWithTimeIntervalSince1970:[tokenPayloadDictionary[@"exp"] doubleValue]];
  931|      0|  NSDate *authDate =
  932|      0|      [NSDate dateWithTimeIntervalSince1970:[tokenPayloadDictionary[@"auth_time"] doubleValue]];
  933|      0|  NSDate *issuedDate =
  934|      0|      [NSDate dateWithTimeIntervalSince1970:[tokenPayloadDictionary[@"iat"] doubleValue]];
  935|      0|  FIRAuthTokenResult *result =
  936|      0|     [[FIRAuthTokenResult alloc] initWithToken:token
  937|      0|                                expirationDate:expDate
  938|      0|                                      authDate:authDate
  939|      0|                                  issuedAtDate:issuedDate
  940|      0|                                signInProvider:tokenPayloadDictionary[@"sign_in_provider"]
  941|      0|                                        claims:tokenPayloadDictionary];
  942|      0|  return result;
  943|      0|}
  944|       |
  945|       |/** @fn internalGetTokenForcingRefresh:callback:
  946|       |    @brief Retrieves the Firebase authentication token, possibly refreshing it if it has expired.
  947|       |    @param callback The block to invoke when the token is available. Invoked asynchronously on the
  948|       |        global work thread in the future.
  949|       | */
  950|      0|- (void)internalGetTokenWithCallback:(nonnull FIRAuthTokenCallback)callback {
  951|      0|  [self internalGetTokenForcingRefresh:NO callback:callback];
  952|      0|}
  953|       |
  954|       |- (void)internalGetTokenForcingRefresh:(BOOL)forceRefresh
  955|      0|                              callback:(nonnull FIRAuthTokenCallback)callback {
  956|      0|  [_tokenService fetchAccessTokenForcingRefresh:forceRefresh
  957|      0|                                       callback:^(NSString *_Nullable token,
  958|      0|                                                  NSError *_Nullable error,
  959|      0|                                                  BOOL tokenUpdated) {
  960|      0|    if (error) {
  961|      0|      [self signOutIfTokenIsInvalidWithError:error];
  962|      0|      callback(nil, error);
  963|      0|      return;
  964|      0|    }
  965|      0|    if (tokenUpdated) {
  966|      0|      if (![self updateKeychain:&error]) {
  967|      0|        callback(nil, error);
  968|      0|        return;
  969|      0|      }
  970|      0|    }
  971|      0|    callback(token, nil);
  972|      0|  }];
  973|      0|}
  974|       |
  975|       |- (void)linkWithCredential:(FIRAuthCredential *)credential
  976|      0|                completion:(nullable FIRAuthResultCallback)completion {
  977|      0|  FIRAuthDataResultCallback callback = ^(FIRAuthDataResult *_Nullable authResult,
  978|      0|                                         NSError *_Nullable error) {
  979|      0|    completion(authResult.user, error);
  980|      0|  };
  981|      0|  [self linkAndRetrieveDataWithCredential:credential completion:callback];
  982|      0|}
  983|       |
  984|       |- (void)linkAndRetrieveDataWithCredential:(FIRAuthCredential *)credential
  985|      0|                               completion:(nullable FIRAuthDataResultCallback)completion {
  986|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
  987|      0|    if (self->_providerData[credential.provider]) {
  988|      0|      callInMainThreadWithAuthDataResultAndError(completion,
  989|      0|                                                 nil,
  990|      0|                                                 [FIRAuthErrorUtils providerAlreadyLinkedError]);
  991|      0|      return;
  992|      0|    }
  993|      0|    FIRAuthDataResult *result =
  994|      0|        [[FIRAuthDataResult alloc] initWithUser:self additionalUserInfo:nil];
  995|      0|    if ([credential isKindOfClass:[FIREmailPasswordAuthCredential class]]) {
  996|      0|      if (self->_hasEmailPasswordCredential) {
  997|      0|        callInMainThreadWithAuthDataResultAndError(completion,
  998|      0|                                                   nil,
  999|      0|                                                   [FIRAuthErrorUtils providerAlreadyLinkedError]);
 1000|      0|        return;
 1001|      0|      }
 1002|      0|      FIREmailPasswordAuthCredential *emailPasswordCredential =
 1003|      0|          (FIREmailPasswordAuthCredential *)credential;
 1004|      0|      [self updateEmail:emailPasswordCredential.email
 1005|      0|               password:emailPasswordCredential.password
 1006|      0|               callback:^(NSError *error) {
 1007|      0|        if (error) {
 1008|      0|          callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1009|      0|        } else {
 1010|      0|          callInMainThreadWithAuthDataResultAndError(completion, result, nil);
 1011|      0|        }
 1012|      0|      }];
 1013|      0|      return;
 1014|      0|    }
 1015|      0|
 1016|      0|    if ([credential isKindOfClass:[FIRGameCenterAuthCredential class]]) {
 1017|      0|      FIRGameCenterAuthCredential *gameCenterCredential = (FIRGameCenterAuthCredential *)credential;
 1018|      0|      [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1019|      0|                                           NSError *_Nullable error) {
 1020|      0|        FIRAuthRequestConfiguration *requestConfiguration = self.auth.requestConfiguration;
 1021|      0|        FIRSignInWithGameCenterRequest *gameCenterRequest =
 1022|      0|        [[FIRSignInWithGameCenterRequest alloc] initWithPlayerID:gameCenterCredential.playerID
 1023|      0|                                                    publicKeyURL:gameCenterCredential.publicKeyURL
 1024|      0|                                                       signature:gameCenterCredential.signature
 1025|      0|                                                            salt:gameCenterCredential.salt
 1026|      0|                                                       timestamp:gameCenterCredential.timestamp
 1027|      0|                                                     displayName:gameCenterCredential.displayName
 1028|      0|                                            requestConfiguration:requestConfiguration];
 1029|      0|        gameCenterRequest.accessToken = accessToken;
 1030|      0|
 1031|      0|        [FIRAuthBackend signInWithGameCenter:gameCenterRequest
 1032|      0|                                    callback:^(FIRSignInWithGameCenterResponse *_Nullable response,
 1033|      0|                                               NSError *_Nullable error) {
 1034|      0|          if (error){
 1035|      0|            callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1036|      0|          } else {
 1037|      0|            [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1038|      0|                                                 NSError *_Nullable error) {
 1039|      0|              if (error) {
 1040|      0|                callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1041|      0|                return;
 1042|      0|              }
 1043|      0|
 1044|      0|              FIRGetAccountInfoRequest *getAccountInfoRequest =
 1045|      0|              [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
 1046|      0|                                               requestConfiguration:requestConfiguration];
 1047|      0|              [FIRAuthBackend getAccountInfo:getAccountInfoRequest
 1048|      0|                                    callback:^(FIRGetAccountInfoResponse *_Nullable response,
 1049|      0|                                               NSError *_Nullable error) {
 1050|      0|                                      if (error) {
 1051|      0|                                        [self signOutIfTokenIsInvalidWithError:error];
 1052|      0|                                        callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1053|      0|                                        return;
 1054|      0|                                      }
 1055|      0|                                      self.anonymous = NO;
 1056|      0|                                      [self updateWithGetAccountInfoResponse:response];
 1057|      0|                                      if (![self updateKeychain:&error]) {
 1058|      0|                                        callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1059|      0|                                        return;
 1060|      0|                                      }
 1061|      0|                                      callInMainThreadWithAuthDataResultAndError(completion, result, nil);
 1062|      0|                                    }];
 1063|      0|            }];
 1064|      0|          }
 1065|      0|        }];
 1066|      0|      }];
 1067|      0|      return;
 1068|      0|    }
 1069|      0|
 1070|      0|    #if TARGET_OS_IOS
 1071|      0|    if ([credential isKindOfClass:[FIRPhoneAuthCredential class]]) {
 1072|      0|      FIRPhoneAuthCredential *phoneAuthCredential = (FIRPhoneAuthCredential *)credential;
 1073|      0|      [self internalUpdateOrLinkPhoneNumberCredential:phoneAuthCredential
 1074|      0|                                      isLinkOperation:YES
 1075|      0|                                           completion:^(NSError *_Nullable error) {
 1076|      0|        if (error){
 1077|      0|          callInMainThreadWithAuthDataResultAndError(completion, nil, error);
 1078|      0|        } else {
 1079|      0|          callInMainThreadWithAuthDataResultAndError(completion, result, nil);
 1080|      0|        }
 1081|      0|      }];
 1082|      0|      return;
 1083|      0|    }
 1084|      0|    #endif
 1085|      0|
 1086|      0|    [self->_taskQueue enqueueTask:^(FIRAuthSerialTaskCompletionBlock _Nonnull complete) {
 1087|      0|      CallbackWithAuthDataResultAndError completeWithError =
 1088|      0|          ^(FIRAuthDataResult *result, NSError *error) {
 1089|      0|        complete();
 1090|      0|        callInMainThreadWithAuthDataResultAndError(completion, result, error);
 1091|      0|      };
 1092|      0|      [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1093|      0|                                           NSError *_Nullable error) {
 1094|      0|        if (error) {
 1095|      0|          completeWithError(nil, error);
 1096|      0|          return;
 1097|      0|        }
 1098|      0|        FIRAuthRequestConfiguration *requestConfiguration = self->_auth.requestConfiguration;
 1099|      0|        FIRVerifyAssertionRequest *request =
 1100|      0|            [[FIRVerifyAssertionRequest alloc] initWithProviderID:credential.provider
 1101|      0|                                             requestConfiguration:requestConfiguration];
 1102|      0|        [credential prepareVerifyAssertionRequest:request];
 1103|      0|        request.accessToken = accessToken;
 1104|      0|        [FIRAuthBackend verifyAssertion:request
 1105|      0|                               callback:^(FIRVerifyAssertionResponse *response, NSError *error) {
 1106|      0|          if (error) {
 1107|      0|            [self signOutIfTokenIsInvalidWithError:error];
 1108|      0|            completeWithError(nil, error);
 1109|      0|            return;
 1110|      0|          }
 1111|      0|          FIRAdditionalUserInfo *additionalUserInfo =
 1112|      0|              [FIRAdditionalUserInfo userInfoWithVerifyAssertionResponse:response];
 1113|      0|          FIRAuthDataResult *result =
 1114|      0|              [[FIRAuthDataResult alloc] initWithUser:self additionalUserInfo:additionalUserInfo];
 1115|      0|          // Update the new token and refresh user info again.
 1116|      0|          self->_tokenService = [[FIRSecureTokenService alloc]
 1117|      0|              initWithRequestConfiguration:requestConfiguration
 1118|      0|                               accessToken:response.IDToken
 1119|      0|                 accessTokenExpirationDate:response.approximateExpirationDate
 1120|      0|                              refreshToken:response.refreshToken];
 1121|      0|          [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1122|      0|                                               NSError *_Nullable error) {
 1123|      0|            if (error) {
 1124|      0|              completeWithError(nil, error);
 1125|      0|              return;
 1126|      0|            }
 1127|      0|            FIRGetAccountInfoRequest *getAccountInfoRequest =
 1128|      0|                [[FIRGetAccountInfoRequest alloc] initWithAccessToken:accessToken
 1129|      0|                                                 requestConfiguration:requestConfiguration];
 1130|      0|            [FIRAuthBackend getAccountInfo:getAccountInfoRequest
 1131|      0|                                  callback:^(FIRGetAccountInfoResponse *_Nullable response,
 1132|      0|                                             NSError *_Nullable error) {
 1133|      0|              if (error) {
 1134|      0|                [self signOutIfTokenIsInvalidWithError:error];
 1135|      0|                completeWithError(nil, error);
 1136|      0|                return;
 1137|      0|              }
 1138|      0|              self.anonymous = NO;
 1139|      0|              [self updateWithGetAccountInfoResponse:response];
 1140|      0|              if (![self updateKeychain:&error]) {
 1141|      0|                completeWithError(nil, error);
 1142|      0|                return;
 1143|      0|              }
 1144|      0|              completeWithError(result, nil);
 1145|      0|            }];
 1146|      0|          }];
 1147|      0|        }];
 1148|      0|      }];
 1149|      0|    }];
 1150|      0|  });
 1151|      0|}
 1152|       |
 1153|       |- (void)unlinkFromProvider:(NSString *)provider
 1154|      0|                completion:(nullable FIRAuthResultCallback)completion {
 1155|      0|  [_taskQueue enqueueTask:^(FIRAuthSerialTaskCompletionBlock _Nonnull complete) {
 1156|      0|    CallbackWithError completeAndCallbackWithError = ^(NSError *error) {
 1157|      0|      complete();
 1158|      0|      callInMainThreadWithUserAndError(completion, self, error);
 1159|      0|    };
 1160|      0|    [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1161|      0|                                         NSError *_Nullable error) {
 1162|      0|      if (error) {
 1163|      0|        completeAndCallbackWithError(error);
 1164|      0|        return;
 1165|      0|      }
 1166|      0|      FIRAuthRequestConfiguration *requestConfiguration = self->_auth.requestConfiguration;
 1167|      0|      FIRSetAccountInfoRequest *setAccountInfoRequest =
 1168|      0|          [[FIRSetAccountInfoRequest alloc] initWithRequestConfiguration:requestConfiguration];
 1169|      0|      setAccountInfoRequest.accessToken = accessToken;
 1170|      0|      BOOL isEmailPasswordProvider = [provider isEqualToString:FIREmailAuthProviderID];
 1171|      0|      if (isEmailPasswordProvider) {
 1172|      0|        if (!self->_hasEmailPasswordCredential) {
 1173|      0|          completeAndCallbackWithError([FIRAuthErrorUtils noSuchProviderError]);
 1174|      0|          return;
 1175|      0|        }
 1176|      0|        setAccountInfoRequest.deleteAttributes = @[ FIRSetAccountInfoUserAttributePassword ];
 1177|      0|      } else {
 1178|      0|        if (!self->_providerData[provider]) {
 1179|      0|          completeAndCallbackWithError([FIRAuthErrorUtils noSuchProviderError]);
 1180|      0|          return;
 1181|      0|        }
 1182|      0|        setAccountInfoRequest.deleteProviders = @[ provider ];
 1183|      0|      }
 1184|      0|      [FIRAuthBackend setAccountInfo:setAccountInfoRequest
 1185|      0|                            callback:^(FIRSetAccountInfoResponse *_Nullable response,
 1186|      0|                                       NSError *_Nullable error) {
 1187|      0|        if (error) {
 1188|      0|          [self signOutIfTokenIsInvalidWithError:error];
 1189|      0|          completeAndCallbackWithError(error);
 1190|      0|          return;
 1191|      0|        }
 1192|      0|        if (isEmailPasswordProvider) {
 1193|      0|          self->_hasEmailPasswordCredential = NO;
 1194|      0|        } else {
 1195|      0|          // We can't just use the provider info objects in FIRSetAcccountInfoResponse because they
 1196|      0|          // don't have localID and email fields. Remove the specific provider manually.
 1197|      0|          NSMutableDictionary *mutableProviderData = [self->_providerData mutableCopy];
 1198|      0|          [mutableProviderData removeObjectForKey:provider];
 1199|      0|          self->_providerData = [mutableProviderData copy];
 1200|      0|
 1201|      0|          #if TARGET_OS_IOS
 1202|      0|          // After successfully unlinking a phone auth provider, remove the phone number from the
 1203|      0|          // cached user info.
 1204|      0|          if ([provider isEqualToString:FIRPhoneAuthProviderID]) {
 1205|      0|            self->_phoneNumber = nil;
 1206|      0|          }
 1207|      0|          #endif
 1208|      0|        }
 1209|      0|        if (response.IDToken && response.refreshToken) {
 1210|      0|          FIRSecureTokenService *tokenService = [[FIRSecureTokenService alloc]
 1211|      0|              initWithRequestConfiguration:requestConfiguration
 1212|      0|                               accessToken:response.IDToken
 1213|      0|                 accessTokenExpirationDate:response.approximateExpirationDate
 1214|      0|                              refreshToken:response.refreshToken];
 1215|      0|          [self setTokenService:tokenService callback:^(NSError *_Nullable error) {
 1216|      0|            completeAndCallbackWithError(error);
 1217|      0|          }];
 1218|      0|          return;
 1219|      0|        }
 1220|      0|        if (![self updateKeychain:&error]) {
 1221|      0|          completeAndCallbackWithError(error);
 1222|      0|          return;
 1223|      0|        }
 1224|      0|        completeAndCallbackWithError(nil);
 1225|      0|      }];
 1226|      0|    }];
 1227|      0|  }];
 1228|      0|}
 1229|       |
 1230|      0|- (void)sendEmailVerificationWithCompletion:(nullable FIRSendEmailVerificationCallback)completion {
 1231|      0|  [self sendEmailVerificationWithNullableActionCodeSettings:nil completion:completion];
 1232|      0|}
 1233|       |
 1234|       |- (void)sendEmailVerificationWithActionCodeSettings:(FIRActionCodeSettings *)actionCodeSettings
 1235|       |                                         completion:(nullable FIRSendEmailVerificationCallback)
 1236|      0|                                                    completion {
 1237|      0|  [self sendEmailVerificationWithNullableActionCodeSettings:actionCodeSettings
 1238|      0|                                                 completion:completion];
 1239|      0|}
 1240|       |
 1241|       |/** @fn sendEmailVerificationWithNullableActionCodeSettings:completion:
 1242|       |    @brief Initiates email verification for the user.
 1243|       |
 1244|       |    @param actionCodeSettings Optionally, a @c FIRActionCodeSettings object containing settings
 1245|       |        related to the handling action codes.
 1246|       | */
 1247|       |- (void)sendEmailVerificationWithNullableActionCodeSettings:(nullable FIRActionCodeSettings *)
 1248|       |                                                            actionCodeSettings
 1249|       |                                                 completion:
 1250|       |                                                         (nullable FIRSendEmailVerificationCallback)
 1251|      0|                                                            completion {
 1252|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1253|      0|    [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1254|      0|                                         NSError *_Nullable error) {
 1255|      0|      if (error) {
 1256|      0|        callInMainThreadWithError(completion, error);
 1257|      0|        return;
 1258|      0|      }
 1259|      0|      FIRAuthRequestConfiguration *configuration = self->_auth.requestConfiguration;
 1260|      0|      FIRGetOOBConfirmationCodeRequest *request =
 1261|      0|          [FIRGetOOBConfirmationCodeRequest verifyEmailRequestWithAccessToken:accessToken
 1262|      0|                                                           actionCodeSettings:actionCodeSettings
 1263|      0|                                                         requestConfiguration:configuration];
 1264|      0|      [FIRAuthBackend getOOBConfirmationCode:request
 1265|      0|                                    callback:^(FIRGetOOBConfirmationCodeResponse *_Nullable
 1266|      0|                                                   response,
 1267|      0|                                               NSError *_Nullable error) {
 1268|      0|        [self signOutIfTokenIsInvalidWithError:error];
 1269|      0|        callInMainThreadWithError(completion, error);
 1270|      0|      }];
 1271|      0|    }];
 1272|      0|  });
 1273|      0|}
 1274|       |
 1275|      0|- (void)deleteWithCompletion:(nullable FIRUserProfileChangeCallback)completion {
 1276|      0|  dispatch_async(FIRAuthGlobalWorkQueue(), ^{
 1277|      0|    [self internalGetTokenWithCallback:^(NSString *_Nullable accessToken,
 1278|      0|                                         NSError *_Nullable error) {
 1279|      0|      if (error) {
 1280|      0|        callInMainThreadWithError(completion, error);
 1281|      0|        return;
 1282|      0|      }
 1283|      0|      FIRDeleteAccountRequest *deleteUserRequest =
 1284|      0|        [[FIRDeleteAccountRequest alloc] initWitLocalID:self->_userID
 1285|      0|                                            accessToken:accessToken
 1286|      0|                                   requestConfiguration:self->_auth.requestConfiguration];
 1287|      0|      [FIRAuthBackend deleteAccount:deleteUserRequest callback:^(NSError *_Nullable error) {
 1288|      0|        if (error) {
 1289|      0|          callInMainThreadWithError(completion, error);
 1290|      0|          return;
 1291|      0|        }
 1292|      0|        if (![self->_auth signOutByForceWithUserID:self->_userID error:&error]) {
 1293|      0|          callInMainThreadWithError(completion, error);
 1294|      0|          return;
 1295|      0|        }
 1296|      0|        callInMainThreadWithError(completion, error);
 1297|      0|      }];
 1298|      0|    }];
 1299|      0|  });
 1300|      0|}
 1301|       |
 1302|       |/** @fn signOutIfTokenIsInvalidWithError:
 1303|       |    @brief Signs out this user if the user or the token is invalid.
 1304|       |    @param error The error from the server.
 1305|       | */
 1306|      0|- (void)signOutIfTokenIsInvalidWithError:(nullable NSError *)error {
 1307|      0|  NSInteger errorCode = error.code;
 1308|      0|  if (errorCode == FIRAuthErrorCodeUserNotFound ||
 1309|      0|      errorCode == FIRAuthErrorCodeUserDisabled ||
 1310|      0|      errorCode == FIRAuthErrorCodeInvalidUserToken ||
 1311|      0|      errorCode == FIRAuthErrorCodeUserTokenExpired) {
 1312|      0|    FIRLogNotice(kFIRLoggerAuth, @"I-AUT000016",
 1313|      0|                 @"Invalid user token detected, user is automatically signed out.");
 1314|      0|    [_auth signOutByForceWithUserID:_userID error:NULL];
 1315|      0|  }
 1316|      0|}
 1317|       |
 1318|       |@end
 1319|       |
 1320|       |@implementation FIRUserProfileChangeRequest {
 1321|       |  /** @var _user
 1322|       |      @brief The user associated with the change request.
 1323|       |   */
 1324|       |  FIRUser *_user;
 1325|       |
 1326|       |  /** @var _displayName
 1327|       |      @brief The display name value to set if @c _displayNameSet is YES.
 1328|       |   */
 1329|       |  NSString *_displayName;
 1330|       |
 1331|       |  /** @var _displayNameSet
 1332|       |      @brief Indicates the display name should be part of the change request.
 1333|       |   */
 1334|       |  BOOL _displayNameSet;
 1335|       |
 1336|       |  /** @var _photoURL
 1337|       |      @brief The photo URL value to set if @c _displayNameSet is YES.
 1338|       |   */
 1339|       |  NSURL *_photoURL;
 1340|       |
 1341|       |  /** @var _photoURLSet
 1342|       |      @brief Indicates the photo URL should be part of the change request.
 1343|       |   */
 1344|       |  BOOL _photoURLSet;
 1345|       |
 1346|       |  /** @var _consumed
 1347|       |      @brief Indicates the @c commitChangesWithCallback: method has already been invoked.
 1348|       |   */
 1349|       |  BOOL _consumed;
 1350|       |}
 1351|       |
 1352|      0|- (nullable instancetype)initWithUser:(FIRUser *)user {
 1353|      0|  self = [super init];
 1354|      0|  if (self) {
 1355|      0|    _user = user;
 1356|      0|  }
 1357|      0|  return self;
 1358|      0|}
 1359|       |
 1360|      0|- (nullable NSString *)displayName {
 1361|      0|  return _displayName;
 1362|      0|}
 1363|       |
 1364|      0|- (void)setDisplayName:(nullable NSString *)displayName {
 1365|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1366|      0|    if (self->_consumed) {
 1367|      0|      [NSException raise:NSInternalInconsistencyException
 1368|      0|                  format:@"%@",
 1369|      0|                         @"Invalid call to setDisplayName: after commitChangesWithCallback:."];
 1370|      0|      return;
 1371|      0|    }
 1372|      0|    self->_displayNameSet = YES;
 1373|      0|    self->_displayName = [displayName copy];
 1374|      0|  });
 1375|      0|}
 1376|       |
 1377|      0|- (nullable NSURL *)photoURL {
 1378|      0|  return _photoURL;
 1379|      0|}
 1380|       |
 1381|      0|- (void)setPhotoURL:(nullable NSURL *)photoURL {
 1382|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1383|      0|    if (self->_consumed) {
 1384|      0|      [NSException raise:NSInternalInconsistencyException
 1385|      0|                  format:@"%@",
 1386|      0|                         @"Invalid call to setPhotoURL: after commitChangesWithCallback:."];
 1387|      0|      return;
 1388|      0|    }
 1389|      0|    self->_photoURLSet = YES;
 1390|      0|    self->_photoURL = [photoURL copy];
 1391|      0|  });
 1392|      0|}
 1393|       |
 1394|       |/** @fn hasUpdates
 1395|       |    @brief Indicates at least one field has a value which needs to be committed.
 1396|       | */
 1397|      0|- (BOOL)hasUpdates {
 1398|      0|  return _displayNameSet || _photoURLSet;
 1399|      0|}
 1400|       |
 1401|      0|- (void)commitChangesWithCompletion:(nullable FIRUserProfileChangeCallback)completion {
 1402|      0|  dispatch_sync(FIRAuthGlobalWorkQueue(), ^{
 1403|      0|    if (self->_consumed) {
 1404|      0|      [NSException raise:NSInternalInconsistencyException
 1405|      0|                  format:@"%@",
 1406|      0|                         @"commitChangesWithCallback: should only be called once."];
 1407|      0|      return;
 1408|      0|    }
 1409|      0|    self->_consumed = YES;
 1410|      0|    // Return fast if there is nothing to update:
 1411|      0|    if (![self hasUpdates]) {
 1412|      0|      callInMainThreadWithError(completion, nil);
 1413|      0|      return;
 1414|      0|    }
 1415|      0|    NSString *displayName = [self->_displayName copy];
 1416|      0|    BOOL displayNameWasSet = self->_displayNameSet;
 1417|      0|    NSURL *photoURL = [self->_photoURL copy];
 1418|      0|    BOOL photoURLWasSet = self->_photoURLSet;
 1419|      0|    [self->_user executeUserUpdateWithChanges:^(FIRGetAccountInfoResponseUser *user,
 1420|      0|                                                FIRSetAccountInfoRequest *request) {
 1421|      0|      if (photoURLWasSet) {
 1422|      0|        request.photoURL = photoURL;
 1423|      0|      }
 1424|      0|      if (displayNameWasSet) {
 1425|      0|        request.displayName = displayName;
 1426|      0|      }
 1427|      0|    }
 1428|      0|                               callback:^(NSError *_Nullable error) {
 1429|      0|      if (error) {
 1430|      0|        callInMainThreadWithError(completion, error);
 1431|      0|        return;
 1432|      0|      }
 1433|      0|      if (displayNameWasSet) {
 1434|      0|        [self->_user setDisplayName:displayName];
 1435|      0|      }
 1436|      0|      if (photoURLWasSet) {
 1437|      0|        [self->_user setPhotoURL:photoURL];
 1438|      0|      }
 1439|      0|      if (![self->_user updateKeychain:&error]) {
 1440|      0|        callInMainThreadWithError(completion, error);
 1441|      0|        return;
 1442|      0|      }
 1443|      0|      callInMainThreadWithError(completion, nil);
 1444|      0|    }];
 1445|      0|  });
 1446|      0|}
 1447|       |
 1448|       |@end
 1449|       |
 1450|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRUserInfoImpl.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRUserInfoImpl.h"
   18|       |
   19|       |#import "FIRGetAccountInfoResponse.h"
   20|       |
   21|       |/** @var kProviderIDCodingKey
   22|       |    @brief The key used to encode the providerID property for NSSecureCoding.
   23|       | */
   24|       |static NSString *const kProviderIDCodingKey = @"providerID";
   25|       |
   26|       |/** @var kUserIDCodingKey
   27|       |    @brief The key used to encode the userID property for NSSecureCoding.
   28|       | */
   29|       |static NSString *const kUserIDCodingKey = @"userID";
   30|       |
   31|       |/** @var kDisplayNameCodingKey
   32|       |    @brief The key used to encode the displayName property for NSSecureCoding.
   33|       | */
   34|       |static NSString *const kDisplayNameCodingKey = @"displayName";
   35|       |
   36|       |/** @var kProfileURLCodingKey
   37|       |    @brief The key used to encode the profileURL property for NSSecureCoding.
   38|       | */
   39|       |static NSString *const kProfileURLCodingKey = @"profileURL";
   40|       |
   41|       |/** @var kPhotoURLCodingKey
   42|       |    @brief The key used to encode the photoURL property for NSSecureCoding.
   43|       | */
   44|       |static NSString *const kPhotoURLCodingKey = @"photoURL";
   45|       |
   46|       |/** @var kEmailCodingKey
   47|       |    @brief The key used to encode the email property for NSSecureCoding.
   48|       | */
   49|       |static NSString *const kEmailCodingKey = @"email";
   50|       |
   51|       |/** @var kPhoneNumberCodingKey
   52|       |    @brief The key used to encode the phoneNumber property for NSSecureCoding.
   53|       | */
   54|       |static NSString *const kPhoneNumberCodingKey = @"phoneNumber";
   55|       |
   56|       |@implementation FIRUserInfoImpl
   57|       |
   58|       |@synthesize providerID = _providerID;
   59|       |@synthesize uid = _userID;
   60|       |@synthesize displayName = _displayName;
   61|       |@synthesize photoURL = _photoURL;
   62|       |@synthesize email = _email;
   63|       |@synthesize phoneNumber = _phoneNumber;
   64|       |
   65|       |+ (nullable instancetype)userInfoWithGetAccountInfoResponseProviderUserInfo:
   66|      0|    (FIRGetAccountInfoResponseProviderUserInfo *)providerUserInfo {
   67|      0|  return [[self alloc] initWithProviderID:providerUserInfo.providerID
   68|      0|                                   userID:providerUserInfo.federatedID
   69|      0|                              displayName:providerUserInfo.displayName
   70|      0|                                 photoURL:providerUserInfo.photoURL
   71|      0|                                    email:providerUserInfo.email
   72|      0|                              phoneNumber:providerUserInfo.phoneNumber];
   73|      0|}
   74|       |
   75|       |- (nullable instancetype)initWithProviderID:(NSString *)providerID
   76|       |                                     userID:(NSString *)userID
   77|       |                                displayName:(nullable NSString *)displayName
   78|       |                                   photoURL:(nullable NSURL *)photoURL
   79|       |                                      email:(nullable NSString *)email
   80|      0|                                phoneNumber:(nullable NSString *)phoneNumber {
   81|      0|  self = [super init];
   82|      0|  if (self) {
   83|      0|    _providerID = [providerID copy];
   84|      0|    _userID = [userID copy];
   85|      0|    _displayName = [displayName copy];
   86|      0|    _photoURL = [photoURL copy];
   87|      0|    _email = [email copy];
   88|      0|    _phoneNumber = [phoneNumber copy];
   89|      0|  }
   90|      0|  return self;
   91|      0|}
   92|       |
   93|       |#pragma mark - NSSecureCoding
   94|       |
   95|      0|+ (BOOL)supportsSecureCoding {
   96|      0|  return YES;
   97|      0|}
   98|       |
   99|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
  100|      0|  NSString *providerID =
  101|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kProviderIDCodingKey];
  102|      0|  NSString *userID = [aDecoder decodeObjectOfClass:[NSString class] forKey:kUserIDCodingKey];
  103|      0|  NSString *displayName =
  104|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kDisplayNameCodingKey];
  105|      0|  NSURL *photoURL = [aDecoder decodeObjectOfClass:[NSURL class] forKey:kPhotoURLCodingKey];
  106|      0|  NSString *email = [aDecoder decodeObjectOfClass:[NSString class] forKey:kEmailCodingKey];
  107|      0|  NSString *phoneNumber =
  108|      0|      [aDecoder decodeObjectOfClass:[NSString class] forKey:kPhoneNumberCodingKey];
  109|      0|
  110|      0|  return [self initWithProviderID:providerID
  111|      0|                           userID:userID
  112|      0|                      displayName:displayName
  113|      0|                         photoURL:photoURL
  114|      0|                            email:email
  115|      0|                      phoneNumber:phoneNumber];
  116|      0|}
  117|       |
  118|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
  119|      0|  [aCoder encodeObject:_providerID forKey:kProviderIDCodingKey];
  120|      0|  [aCoder encodeObject:_userID forKey:kUserIDCodingKey];
  121|      0|  [aCoder encodeObject:_displayName forKey:kDisplayNameCodingKey];
  122|      0|  [aCoder encodeObject:_photoURL forKey:kPhotoURLCodingKey];
  123|      0|  [aCoder encodeObject:_email forKey:kEmailCodingKey];
  124|      0|  [aCoder encodeObject:_phoneNumber forKey:kPhoneNumberCodingKey];
  125|      0|}
  126|       |
  127|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/FIRUserMetadata.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRUserMetadata_Internal.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRUserMetadata
   22|       |
   23|       |/** @var kCreationDateCodingKey
   24|       |    @brief The key used to encode the creationDate property for NSSecureCoding.
   25|       | */
   26|       |static NSString *const kCreationDateCodingKey = @"creationDate";
   27|       |
   28|       |/** @var kLastSignInDateCodingKey
   29|       |    @brief The key used to encode the lastSignInDate property for NSSecureCoding.
   30|       | */
   31|       |static NSString *const kLastSignInDateCodingKey = @"lastSignInDate";
   32|       |
   33|       |- (instancetype)initWithCreationDate:(nullable NSDate *)creationDate
   34|      0|                      lastSignInDate:(nullable NSDate *)lastSignInDate {
   35|      0|  self = [super init];
   36|      0|  if (self) {
   37|      0|    _creationDate = [creationDate copy];
   38|      0|    _lastSignInDate = [lastSignInDate copy];
   39|      0|  }
   40|      0|  return self;
   41|      0|}
   42|       |
   43|       |#pragma mark - NSSecureCoding
   44|       |
   45|      0|+ (BOOL)supportsSecureCoding {
   46|      0|  return YES;
   47|      0|}
   48|       |
   49|      0|- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
   50|      0|  NSDate *creationDate =
   51|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kCreationDateCodingKey];
   52|      0|  NSDate *lastSignInDate =
   53|      0|      [aDecoder decodeObjectOfClass:[NSDate class] forKey:kLastSignInDateCodingKey];
   54|      0|  return [self initWithCreationDate:creationDate lastSignInDate:lastSignInDate];
   55|      0|}
   56|       |
   57|      0|- (void)encodeWithCoder:(NSCoder *)aCoder {
   58|      0|  [aCoder encodeObject:_creationDate forKey:kCreationDateCodingKey];
   59|      0|  [aCoder encodeObject:_lastSignInDate forKey:kLastSignInDateCodingKey];
   60|      0|}
   61|       |
   62|       |@end
   63|       |
   64|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/NSData+FIRBase64.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "NSData+FIRBase64.h"
   18|       |
   19|       |@implementation NSData (FIRBase64)
   20|       |
   21|      0|- (NSString *)fir_base64URLEncodedStringWithOptions:(NSDataBase64EncodingOptions)options {
   22|      0|  NSString *string = [self base64EncodedStringWithOptions:options];
   23|      0|  string = [string stringByReplacingOccurrencesOfString:@"/" withString:@"_"];
   24|      0|  string = [string stringByReplacingOccurrencesOfString:@"+" withString:@"-"];
   25|      0|  string = [string stringByReplacingOccurrencesOfString:@"=" withString:@""];
   26|      0|  return string;
   27|      0|}
   28|       |
   29|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRAuthBackend.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthBackend.h"
   18|       |
   19|       |#import <GTMSessionFetcher/GTMSessionFetcher.h>
   20|       |#import <GTMSessionFetcher/GTMSessionFetcherService.h>
   21|       |
   22|       |#import "FIRAuthErrorUtils.h"
   23|       |#import "FIRAuthGlobalWorkQueue.h"
   24|       |#import "FirebaseAuth.h"
   25|       |#import "FIRAuthRPCRequest.h"
   26|       |#import "FIRAuthRPCResponse.h"
   27|       |#import "FIRCreateAuthURIRequest.h"
   28|       |#import "FIRCreateAuthURIResponse.h"
   29|       |#import "FIRDeleteAccountRequest.h"
   30|       |#import "FIRDeleteAccountResponse.h"
   31|       |#import "FIRGetAccountInfoRequest.h"
   32|       |#import "FIRGetAccountInfoResponse.h"
   33|       |#import "FIRSignInWithGameCenterRequest.h"
   34|       |#import "FIRSignInWithGameCenterResponse.h"
   35|       |#import "FIRGetOOBConfirmationCodeRequest.h"
   36|       |#import "FIRGetOOBConfirmationCodeResponse.h"
   37|       |#import "FIRGetProjectConfigRequest.h"
   38|       |#import "FIRGetProjectConfigResponse.h"
   39|       |#import "FIRResetPasswordRequest.h"
   40|       |#import "FIRResetPasswordResponse.h"
   41|       |#import "FIRSendVerificationCodeRequest.h"
   42|       |#import "FIRSendVerificationCodeResponse.h"
   43|       |#import "FIRSecureTokenRequest.h"
   44|       |#import "FIRSecureTokenResponse.h"
   45|       |#import "FIRSetAccountInfoRequest.h"
   46|       |#import "FIRSetAccountInfoResponse.h"
   47|       |#import "FIRSignUpNewUserRequest.h"
   48|       |#import "FIRSignUpNewUserResponse.h"
   49|       |#import "FIRVerifyAssertionRequest.h"
   50|       |#import "FIRVerifyAssertionResponse.h"
   51|       |#import "FIRVerifyClientRequest.h"
   52|       |#import "FIRVerifyClientResponse.h"
   53|       |#import "FIRVerifyCustomTokenRequest.h"
   54|       |#import "FIRVerifyCustomTokenResponse.h"
   55|       |#import "FIRVerifyPasswordRequest.h"
   56|       |#import "FIRVerifyPasswordResponse.h"
   57|       |#import "FIREmailLinkSignInRequest.h"
   58|       |#import "FIREmailLinkSignInResponse.h"
   59|       |#import "FIRVerifyPhoneNumberRequest.h"
   60|       |#import "FIRVerifyPhoneNumberResponse.h"
   61|       |
   62|       |#if TARGET_OS_IOS
   63|       |#import "../AuthProviders/Phone/FIRPhoneAuthCredential_Internal.h"
   64|       |#import "FIRPhoneAuthProvider.h"
   65|       |#endif
   66|       |
   67|       |/** @var kClientVersionHeader
   68|       |    @brief HTTP header name for the client version.
   69|       | */
   70|       |static NSString *const kClientVersionHeader = @"X-Client-Version";
   71|       |
   72|       |/** @var kIosBundleIdentifierHeader
   73|       |    @brief HTTP header name for iOS bundle ID.
   74|       | */
   75|       |static NSString *const kIosBundleIdentifierHeader = @"X-Ios-Bundle-Identifier";
   76|       |
   77|       |/** @var kFirebaseLocalHeader
   78|       |    @brief HTTP header name for the firebase locale.
   79|       | */
   80|       |static NSString *const kFirebaseLocalHeader = @"X-Firebase-Locale";
   81|       |
   82|       |/** @var kFirebaseAuthCoreFrameworkMarker
   83|       |    @brief The marker in the HTTP header that indicates the request comes from Firebase Auth Core.
   84|       | */
   85|       |static NSString *const kFirebaseAuthCoreFrameworkMarker = @"FirebaseCore-iOS";
   86|       |
   87|       |/** @var kJSONContentType
   88|       |    @brief The value of the HTTP content-type header for JSON payloads.
   89|       | */
   90|       |static NSString *const kJSONContentType = @"application/json";
   91|       |
   92|       |/** @var kErrorDataKey
   93|       |    @brief Key for error data in NSError returned by @c GTMSessionFetcher.
   94|       | */
   95|       |static NSString * const kErrorDataKey = @"data";
   96|       |
   97|       |/** @var kErrorKey
   98|       |    @brief The key for the "error" value in JSON responses from the server.
   99|       | */
  100|       |static NSString *const kErrorKey = @"error";
  101|       |
  102|       |/** @var kErrorsKey
  103|       |    @brief The key for the "errors" value in JSON responses from the server.
  104|       | */
  105|       |static NSString *const kErrorsKey = @"errors";
  106|       |
  107|       |/** @var kReasonKey
  108|       |    @brief The key for the "reason" value in JSON responses from the server.
  109|       | */
  110|       |static NSString *const kReasonKey = @"reason";
  111|       |
  112|       |/** @var kInvalidKeyReasonValue
  113|       |    @brief The value for the "reason" key indicating an invalid API Key was received by the server.
  114|       | */
  115|       |static NSString *const kInvalidKeyReasonValue = @"keyInvalid";
  116|       |
  117|       |/** @var kAppNotAuthorizedReasonValue
  118|       |    @brief The value for the "reason" key indicating the App is not authorized to use Firebase
  119|       |        Authentication.
  120|       | */
  121|       |static NSString *const kAppNotAuthorizedReasonValue = @"ipRefererBlocked";
  122|       |
  123|       |/** @var kErrorMessageKey
  124|       |    @brief The key for an error's "message" value in JSON responses from the server.
  125|       | */
  126|       |static NSString *const kErrorMessageKey = @"message";
  127|       |
  128|       |/** @var kUserNotFoundErrorMessage
  129|       |    @brief This is the error message returned when the user is not found, which means the user
  130|       |        account has been deleted given the token was once valid.
  131|       | */
  132|       |static NSString *const kUserNotFoundErrorMessage = @"USER_NOT_FOUND";
  133|       |
  134|       |/** @var kUserDeletedErrorMessage
  135|       |    @brief This is the error message the server will respond with if the user entered an invalid
  136|       |        email address.
  137|       | */
  138|       |static NSString *const kUserDeletedErrorMessage = @"EMAIL_NOT_FOUND";
  139|       |
  140|       |/** @var kInvalidLocalIDErrorMessage
  141|       |    @brief This is the error message the server responds with if the user local id in the id token
  142|       |        does not exit.
  143|       | */
  144|       |static NSString *const kInvalidLocalIDErrorMessage = @"INVALID_LOCAL_ID";
  145|       |
  146|       |/** @var kUserTokenExpiredErrorMessage
  147|       |    @brief The error returned by the server if the token issue time is older than the account's
  148|       |        valid_since time.
  149|       | */
  150|       |static NSString *const kUserTokenExpiredErrorMessage = @"TOKEN_EXPIRED";
  151|       |
  152|       |/** @var kTooManyRequestsErrorMessage
  153|       |    @brief This is the error message the server will respond with if too many requests were made to
  154|       |        a server method.
  155|       | */
  156|       |static NSString *const kTooManyRequestsErrorMessage = @"TOO_MANY_ATTEMPTS_TRY_LATER";
  157|       |
  158|       |/** @var kInvalidTokenCustomErrorMessage
  159|       |    @brief This is the error message the server will respond with if there is a validation error
  160|       |        with the custom token.
  161|       | */
  162|       |static NSString *const kInvalidCustomTokenErrorMessage = @"INVALID_CUSTOM_TOKEN";
  163|       |
  164|       |/** @var kCustomTokenMismatch
  165|       |    @brief This is the error message the server will respond with if the service account and API key
  166|       |        belong to different projects.
  167|       | */
  168|       |static NSString *const kCustomTokenMismatch = @"CREDENTIAL_MISMATCH";
  169|       |
  170|       |/** @var kInvalidCredentialErrorMessage
  171|       |    @brief This is the error message the server responds with if the IDP token or requestUri is
  172|       |        invalid.
  173|       | */
  174|       |static NSString *const kInvalidCredentialErrorMessage = @"INVALID_IDP_RESPONSE";
  175|       |
  176|       |/** @var kUserDisabledErrorMessage
  177|       |    @brief The error returned by the server if the user account is diabled.
  178|       | */
  179|       |static NSString *const kUserDisabledErrorMessage = @"USER_DISABLED";
  180|       |
  181|       |/** @var kOperationNotAllowedErrorMessage
  182|       |    @brief This is the error message the server will respond with if Admin disables IDP specified by
  183|       |        provider.
  184|       | */
  185|       |static NSString *const kOperationNotAllowedErrorMessage = @"OPERATION_NOT_ALLOWED";
  186|       |
  187|       |/** @var kPasswordLoginDisabledErrorMessage
  188|       |    @brief This is the error message the server responds with if password login is disabled.
  189|       | */
  190|       |static NSString *const kPasswordLoginDisabledErrorMessage = @"PASSWORD_LOGIN_DISABLED";
  191|       |
  192|       |/** @var kEmailAlreadyInUseErrorMessage
  193|       |    @brief This is the error message the server responds with if the email address already exists.
  194|       | */
  195|       |static NSString *const kEmailAlreadyInUseErrorMessage = @"EMAIL_EXISTS";
  196|       |
  197|       |/** @var kInvalidEmailErrorMessage
  198|       |    @brief The error returned by the server if the email is invalid.
  199|       | */
  200|       |static NSString *const kInvalidEmailErrorMessage = @"INVALID_EMAIL";
  201|       |
  202|       |/** @var kInvalidIdentifierErrorMessage
  203|       |    @brief The error returned by the server if the identifier is invalid.
  204|       | */
  205|       |static NSString *const kInvalidIdentifierErrorMessage = @"INVALID_IDENTIFIER";
  206|       |
  207|       |/** @var kWrongPasswordErrorMessage
  208|       |    @brief This is the error message the server will respond with if the user entered a wrong
  209|       |        password.
  210|       | */
  211|       |static NSString *const kWrongPasswordErrorMessage = @"INVALID_PASSWORD";
  212|       |
  213|       |/** @var kCredentialTooOldErrorMessage
  214|       |    @brief This is the error message the server responds with if account change is attempted 5
  215|       |        minutes after signing in.
  216|       | */
  217|       |static NSString *const kCredentialTooOldErrorMessage = @"CREDENTIAL_TOO_OLD_LOGIN_AGAIN";
  218|       |
  219|       |/** @var kFederatedUserIDAlreadyLinkedMessage
  220|       |    @brief This is the error message the server will respond with if the federated user ID has been
  221|       |        already linked with another account.
  222|       | */
  223|       |static NSString *const kFederatedUserIDAlreadyLinkedMessage = @"FEDERATED_USER_ID_ALREADY_LINKED";
  224|       |
  225|       |/** @var kInvalidUserTokenErrorMessage
  226|       |    @brief This is the error message the server responds with if user's saved auth credential is
  227|       |        invalid, and the user needs to sign in again.
  228|       | */
  229|       |static NSString *const kInvalidUserTokenErrorMessage = @"INVALID_ID_TOKEN";
  230|       |
  231|       |/** @var kWeakPasswordErrorMessagePrefix
  232|       |    @brief This is the prefix for the error message the server responds with if user's new password
  233|       |        to be set is too weak.
  234|       | */
  235|       |static NSString *const kWeakPasswordErrorMessagePrefix = @"WEAK_PASSWORD";
  236|       |
  237|       |/** @var kExpiredActionCodeErrorMessage
  238|       |    @brief This is the error message the server will respond with if the action code is expired.
  239|       | */
  240|       |static NSString *const kExpiredActionCodeErrorMessage = @"EXPIRED_OOB_CODE";
  241|       |
  242|       |/** @var kInvalidActionCodeErrorMessage
  243|       |    @brief This is the error message the server will respond with if the action code is invalid.
  244|       | */
  245|       |static NSString *const kInvalidActionCodeErrorMessage = @"INVALID_OOB_CODE";
  246|       |
  247|       |/** @var kMissingEmailErrorMessage
  248|       |    @brief This is the error message the server will respond with if the email address is missing
  249|       |        during a "send password reset email" attempt.
  250|       | */
  251|       |static NSString *const kMissingEmailErrorMessage = @"MISSING_EMAIL";
  252|       |
  253|       |/** @var kInvalidSenderEmailErrorMessage
  254|       |    @brief This is the error message the server will respond with if the sender email is invalid
  255|       |        during a "send password reset email" attempt.
  256|       | */
  257|       |static NSString *const kInvalidSenderEmailErrorMessage = @"INVALID_SENDER";
  258|       |
  259|       |/** @var kInvalidMessagePayloadErrorMessage
  260|       |    @brief This is the error message the server will respond with if there are invalid parameters in
  261|       |        the payload during a "send password reset email" attempt.
  262|       | */
  263|       |static NSString *const kInvalidMessagePayloadErrorMessage = @"INVALID_MESSAGE_PAYLOAD";
  264|       |
  265|       |/** @var kInvalidRecipientEmailErrorMessage
  266|       |    @brief This is the error message the server will respond with if the recipient email is invalid.
  267|       | */
  268|       |static NSString *const kInvalidRecipientEmailErrorMessage = @"INVALID_RECIPIENT_EMAIL";
  269|       |
  270|       |/** @var kMissingIosBundleIDErrorMessage
  271|       |    @brief This is the error message the server will respond with if iOS bundle ID is missing but
  272|       |        the iOS App store ID is provided.
  273|       | */
  274|       |static NSString *const kMissingIosBundleIDErrorMessage = @"MISSING_IOS_BUNDLE_ID";
  275|       |
  276|       |/** @var kMissingAndroidPackageNameErrorMessage
  277|       |    @brief This is the error message the server will respond with if Android Package Name is missing
  278|       |        but the flag indicating the app should be installed is set to true.
  279|       | */
  280|       |static NSString *const kMissingAndroidPackageNameErrorMessage = @"MISSING_ANDROID_PACKAGE_NAME";
  281|       |
  282|       |/** @var kUnauthorizedDomainErrorMessage
  283|       |    @brief This is the error message the server will respond with if the domain of the continue URL
  284|       |        specified is not whitelisted in the firebase console.
  285|       | */
  286|       |static NSString *const kUnauthorizedDomainErrorMessage = @"UNAUTHORIZED_DOMAIN";
  287|       |
  288|       |/** @var kInvalidDynamicLinkDomainErrorMessage
  289|       | @brief This is the error message the server will respond with if the dynamic link domain provided
  290|       | in the request is invalid.
  291|       | */
  292|       |static NSString *const kInvalidDynamicLinkDomainErrorMessage = @"INVALID_DYNAMIC_LINK_DOMAIN";
  293|       |
  294|       |/** @var kInvalidContinueURIErrorMessage
  295|       |    @brief This is the error message the server will respond with if the continue URL provided in
  296|       |        the request is invalid.
  297|       | */
  298|       |static NSString *const kInvalidContinueURIErrorMessage = @"INVALID_CONTINUE_URI";
  299|       |
  300|       |/** @var kMissingContinueURIErrorMessage
  301|       |    @brief This is the error message the server will respond with if there was no continue URI
  302|       |        present in a request that required one.
  303|       | */
  304|       |static NSString *const kMissingContinueURIErrorMessage = @"MISSING_CONTINUE_URI";
  305|       |
  306|       |/** @var kInvalidPhoneNumberErrorMessage
  307|       |    @brief This is the error message the server will respond with if an incorrectly formatted phone
  308|       |        number is provided.
  309|       | */
  310|       |static NSString *const kInvalidPhoneNumberErrorMessage = @"INVALID_PHONE_NUMBER";
  311|       |
  312|       |/** @var kInvalidVerificationCodeErrorMessage
  313|       |    @brief This is the error message the server will respond with if an invalid verification code is
  314|       |        provided.
  315|       | */
  316|       |static NSString *const kInvalidVerificationCodeErrorMessage = @"INVALID_CODE";
  317|       |
  318|       |/** @var kInvalidSessionInfoErrorMessage
  319|       |    @brief This is the error message the server will respond with if an invalid session info
  320|       |        (verification ID) is provided.
  321|       | */
  322|       |static NSString *const kInvalidSessionInfoErrorMessage = @"INVALID_SESSION_INFO";
  323|       |
  324|       |/** @var kSessionExpiredErrorMessage
  325|       |    @brief This is the error message the server will respond with if the SMS code has expired before
  326|       |        it is used.
  327|       | */
  328|       |static NSString *const kSessionExpiredErrorMessage = @"SESSION_EXPIRED";
  329|       |
  330|       |/** @var kMissingAppTokenErrorMessage
  331|       |    @brief This is the error message the server will respond with if the APNS token is missing in a
  332|       |        verifyClient request.
  333|       | */
  334|       |static NSString *const kMissingAppTokenErrorMessage = @"MISSING_IOS_APP_TOKEN";
  335|       |
  336|       |/** @var kMissingAppCredentialErrorMessage
  337|       |    @brief This is the error message the server will respond with if the app token is missing in a
  338|       |        sendVerificationCode request.
  339|       | */
  340|       |static NSString *const kMissingAppCredentialErrorMessage = @"MISSING_APP_CREDENTIAL";
  341|       |
  342|       |/** @var kInvalidAppCredentialErrorMessage
  343|       |    @brief This is the error message the server will respond with if the app credential in a
  344|       |        sendVerificationCode request is invalid.
  345|       | */
  346|       |static NSString *const kInvalidAppCredentialErrorMessage = @"INVALID_APP_CREDENTIAL";
  347|       |
  348|       |/** @var kQuoutaExceededErrorMessage
  349|       |    @brief This is the error message the server will respond with if the quota for SMS text messages
  350|       |        has been exceeded for the project.
  351|       | */
  352|       |static NSString *const kQuoutaExceededErrorMessage = @"QUOTA_EXCEEDED";
  353|       |
  354|       |/** @var kAppNotVerifiedErrorMessage
  355|       |    @brief This is the error message the server will respond with if Firebase could not verify the
  356|       |        app during a phone authentication flow.
  357|       | */
  358|       |static NSString *const kAppNotVerifiedErrorMessage = @"APP_NOT_VERIFIED";
  359|       |
  360|       |/** @var kMissingClientIdentifier
  361|       |    @brief This is the error message the server will respond with if Firebase could not verify the
  362|       |        app during a phone authentication flow when a real phone number is used and app verification
  363|       |        is disabled for testing.
  364|       | */
  365|       |static NSString *const kMissingClientIdentifier = @"MISSING_CLIENT_IDENTIFIER";
  366|       |
  367|       |/** @var kCaptchaCheckFailedErrorMessage
  368|       |    @brief This is the error message the server will respond with if the reCAPTCHA token provided is
  369|       |        invalid.
  370|       | */
  371|       |static NSString *const kCaptchaCheckFailedErrorMessage = @"CAPTCHA_CHECK_FAILED";
  372|       |
  373|       |/** @var gBackendImplementation
  374|       |    @brief The singleton FIRAuthBackendImplementation instance to use.
  375|       | */
  376|       |static id<FIRAuthBackendImplementation> gBackendImplementation;
  377|       |
  378|       |/** @class FIRAuthBackendRPCImplementation
  379|       |    @brief The default RPC-based backend implementation.
  380|       | */
  381|       |@interface FIRAuthBackendRPCImplementation : NSObject <FIRAuthBackendImplementation>
  382|       |
  383|       |/** @property RPCIssuer
  384|       |    @brief An instance of FIRAuthBackendRPCIssuer for making RPC requests. Allows the RPC
  385|       |        requests/responses to be easily faked.
  386|       | */
  387|       |@property(nonatomic, strong) id<FIRAuthBackendRPCIssuer> RPCIssuer;
  388|       |
  389|       |@end
  390|       |
  391|       |@implementation FIRAuthBackend
  392|       |
  393|      0|+ (id<FIRAuthBackendImplementation>)implementation {
  394|      0|  if (!gBackendImplementation) {
  395|      0|    gBackendImplementation = [[FIRAuthBackendRPCImplementation alloc] init];
  396|      0|  }
  397|      0|  return gBackendImplementation;
  398|      0|}
  399|       |
  400|      0|+ (void)setBackendImplementation:(id<FIRAuthBackendImplementation>)backendImplementation {
  401|      0|  gBackendImplementation = backendImplementation;
  402|      0|}
  403|       |
  404|       |+ (void)setDefaultBackendImplementationWithRPCIssuer:
  405|      0|    (nullable id<FIRAuthBackendRPCIssuer>)RPCIssuer {
  406|      0|  FIRAuthBackendRPCImplementation *defaultImplementation =
  407|      0|      [[FIRAuthBackendRPCImplementation alloc] init];
  408|      0|  if (RPCIssuer) {
  409|      0|    defaultImplementation.RPCIssuer = RPCIssuer;
  410|      0|  }
  411|      0|  gBackendImplementation = defaultImplementation;
  412|      0|}
  413|       |
  414|       |+ (void)createAuthURI:(FIRCreateAuthURIRequest *)request
  415|      0|             callback:(FIRCreateAuthURIResponseCallback)callback {
  416|      0|  [[self implementation] createAuthURI:request callback:callback];
  417|      0|}
  418|       |
  419|       |+ (void)getAccountInfo:(FIRGetAccountInfoRequest *)request
  420|      0|              callback:(FIRGetAccountInfoResponseCallback)callback {
  421|      0|  [[self implementation] getAccountInfo:request callback:callback];
  422|      0|}
  423|       |
  424|       |+ (void)getProjectConfig:(FIRGetProjectConfigRequest *)request
  425|      0|                callback:(FIRGetProjectConfigResponseCallback)callback {
  426|      0|  [[self implementation] getProjectConfig:request callback:callback];
  427|      0|}
  428|       |
  429|       |+ (void)setAccountInfo:(FIRSetAccountInfoRequest *)request
  430|      0|              callback:(FIRSetAccountInfoResponseCallback)callback {
  431|      0|  [[self implementation] setAccountInfo:request callback:callback];
  432|      0|}
  433|       |
  434|       |+ (void)verifyAssertion:(FIRVerifyAssertionRequest *)request
  435|      0|               callback:(FIRVerifyAssertionResponseCallback)callback {
  436|      0|  [[self implementation] verifyAssertion:request callback:callback];
  437|      0|}
  438|       |
  439|       |+ (void)verifyCustomToken:(FIRVerifyCustomTokenRequest *)request
  440|      0|                 callback:(FIRVerifyCustomTokenResponseCallback)callback {
  441|      0|  [[self implementation] verifyCustomToken:request callback:callback];
  442|      0|}
  443|       |
  444|       |+ (void)verifyPassword:(FIRVerifyPasswordRequest *)request
  445|      0|              callback:(FIRVerifyPasswordResponseCallback)callback {
  446|      0|  [[self implementation] verifyPassword:request callback:callback];
  447|      0|}
  448|       |
  449|       |+ (void)emailLinkSignin:(FIREmailLinkSignInRequest *)request
  450|      0|               callback:(FIREmailLinkSigninResponseCallback)callback {
  451|      0|  [[self implementation] emailLinkSignin:request callback:callback];
  452|      0|}
  453|       |
  454|       |+ (void)secureToken:(FIRSecureTokenRequest *)request
  455|      0|           callback:(FIRSecureTokenResponseCallback)callback {
  456|      0|  [[self implementation] secureToken:request callback:callback];
  457|      0|}
  458|       |
  459|       |+ (void)getOOBConfirmationCode:(FIRGetOOBConfirmationCodeRequest *)request
  460|      0|                      callback:(FIRGetOOBConfirmationCodeResponseCallback)callback {
  461|      0|  [[self implementation] getOOBConfirmationCode:request callback:callback];
  462|      0|}
  463|       |
  464|       |+ (void)signUpNewUser:(FIRSignUpNewUserRequest *)request
  465|      0|             callback:(FIRSignupNewUserCallback)callback {
  466|      0|  [[self implementation] signUpNewUser:request callback:callback];
  467|      0|}
  468|       |
  469|      0|+ (void)deleteAccount:(FIRDeleteAccountRequest *)request callback:(FIRDeleteCallBack)callback {
  470|      0|  [[self implementation] deleteAccount:request callback:callback];
  471|      0|}
  472|       |
  473|       |+ (void)signInWithGameCenter:(FIRSignInWithGameCenterRequest *)request
  474|      0|                    callback:(FIRSignInWithGameCenterResponseCallback)callback {
  475|      0|  [[self implementation] signInWithGameCenter:request callback:callback];
  476|      0|}
  477|       |
  478|       |#if TARGET_OS_IOS
  479|       |+ (void)sendVerificationCode:(FIRSendVerificationCodeRequest *)request
  480|      0|                    callback:(FIRSendVerificationCodeResponseCallback)callback {
  481|      0|  [[self implementation] sendVerificationCode:request callback:callback];
  482|      0|}
  483|       |
  484|       |+ (void)verifyPhoneNumber:(FIRVerifyPhoneNumberRequest *)request
  485|      0|                 callback:(FIRVerifyPhoneNumberResponseCallback)callback {
  486|      0|  [[self implementation] verifyPhoneNumber:request callback:callback];
  487|      0|}
  488|       |
  489|      0|+ (void)verifyClient:(id)request callback:(FIRVerifyClientResponseCallback)callback {
  490|      0|  [[self implementation] verifyClient:request callback:callback];
  491|      0|}
  492|       |#endif
  493|       |
  494|       |+ (void)resetPassword:(FIRResetPasswordRequest *)request
  495|      0|             callback:(FIRResetPasswordCallback)callback {
  496|      0|  [[self implementation] resetPassword:request callback:callback];
  497|      0|}
  498|       |
  499|      0|+ (NSString *)authUserAgent {
  500|      0|  return [NSString stringWithFormat:@"FirebaseAuth.iOS/%s %@",
  501|      0|      FirebaseAuthVersionStr, GTMFetcherStandardUserAgentString(nil)];
  502|      0|}
  503|       |
  504|       |@end
  505|       |
  506|       |@interface FIRAuthBackendRPCIssuerImplementation : NSObject <FIRAuthBackendRPCIssuer>
  507|       |@end
  508|       |
  509|       |@implementation FIRAuthBackendRPCIssuerImplementation {
  510|       |  /** @var The session fetcher service.
  511|       |   */
  512|       |  GTMSessionFetcherService *_fetcherService;
  513|       |}
  514|       |
  515|      0|- (instancetype)init {
  516|      0|  self = [super init];
  517|      0|  if (self) {
  518|      0|    _fetcherService = [[GTMSessionFetcherService alloc] init];
  519|      0|    _fetcherService.userAgent = [FIRAuthBackend authUserAgent];
  520|      0|    _fetcherService.callbackQueue = FIRAuthGlobalWorkQueue();
  521|      0|
  522|      0|    // Avoid reusing the session to prevent
  523|      0|    // https://github.com/firebase/firebase-ios-sdk/issues/1261
  524|      0|    _fetcherService.reuseSession = NO;
  525|      0|  }
  526|      0|  return self;
  527|      0|}
  528|       |
  529|       |- (void)asyncPostToURLWithRequestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
  530|       |                                           URL:(NSURL *)URL
  531|       |                                          body:(nullable NSData *)body
  532|       |                                   contentType:(NSString *)contentType
  533|       |                             completionHandler:(void (^)(NSData *_Nullable,
  534|      0|                                                         NSError *_Nullable))handler {
  535|      0|  NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL];
  536|      0|  [request setValue:contentType forHTTPHeaderField:@"Content-Type"];
  537|      0|  NSString *additionalFrameworkMarker = requestConfiguration.additionalFrameworkMarker ?:
  538|      0|      kFirebaseAuthCoreFrameworkMarker;
  539|      0|  NSString *clientVersion = [NSString stringWithFormat:@"iOS/FirebaseSDK/%s/%@",
  540|      0|                                                       FirebaseAuthVersionStr,
  541|      0|                                                       additionalFrameworkMarker];
  542|      0|  [request setValue:clientVersion forHTTPHeaderField:kClientVersionHeader];
  543|      0|  NSString *bundleID = [[NSBundle mainBundle] bundleIdentifier];
  544|      0|  [request setValue:bundleID forHTTPHeaderField:kIosBundleIdentifierHeader];
  545|      0|
  546|      0|  NSArray<NSString *> *preferredLocalizations = [NSBundle mainBundle].preferredLocalizations;
  547|      0|  if (preferredLocalizations.count) {
  548|      0|    NSString *acceptLanguage = preferredLocalizations.firstObject;
  549|      0|    [request setValue:acceptLanguage forHTTPHeaderField:@"Accept-Language"];
  550|      0|  }
  551|      0|  NSString *languageCode = requestConfiguration.languageCode;
  552|      0|  if (languageCode.length) {
  553|      0|    [request setValue:languageCode forHTTPHeaderField:kFirebaseLocalHeader];
  554|      0|  }
  555|      0|  GTMSessionFetcher *fetcher = [_fetcherService fetcherWithRequest:request];
  556|      0|  fetcher.bodyData = body;
  557|      0|  [fetcher beginFetchWithCompletionHandler:handler];
  558|      0|}
  559|       |
  560|       |@end
  561|       |
  562|       |@implementation FIRAuthBackendRPCImplementation
  563|       |
  564|      0|- (instancetype)init {
  565|      0|  self = [super init];
  566|      0|  if (self) {
  567|      0|    _RPCIssuer = [[FIRAuthBackendRPCIssuerImplementation alloc] init];
  568|      0|  }
  569|      0|  return self;
  570|      0|}
  571|       |
  572|       |- (void)createAuthURI:(FIRCreateAuthURIRequest *)request
  573|      0|             callback:(FIRCreateAuthURIResponseCallback)callback {
  574|      0|  FIRCreateAuthURIResponse *response = [[FIRCreateAuthURIResponse alloc] init];
  575|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  576|      0|    if (error) {
  577|      0|      callback(nil, error);
  578|      0|    } else {
  579|      0|      callback(response, nil);
  580|      0|    }
  581|      0|  }];
  582|      0|}
  583|       |
  584|       |- (void)getAccountInfo:(FIRGetAccountInfoRequest *)request
  585|      0|              callback:(FIRGetAccountInfoResponseCallback)callback {
  586|      0|  FIRGetAccountInfoResponse *response = [[FIRGetAccountInfoResponse alloc] init];
  587|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  588|      0|    if (error) {
  589|      0|      callback(nil, error);
  590|      0|    } else {
  591|      0|      callback(response, nil);
  592|      0|    }
  593|      0|  }];
  594|      0|}
  595|       |
  596|       |- (void)getProjectConfig:(FIRGetProjectConfigRequest *)request
  597|      0|                callback:(FIRGetProjectConfigResponseCallback)callback {
  598|      0|  FIRGetProjectConfigResponse *response = [[FIRGetProjectConfigResponse alloc] init];
  599|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  600|      0|    if (error) {
  601|      0|      callback(nil, error);
  602|      0|    } else {
  603|      0|      callback(response, nil);
  604|      0|    }
  605|      0|  }];
  606|      0|}
  607|       |
  608|       |- (void)setAccountInfo:(FIRSetAccountInfoRequest *)request
  609|      0|              callback:(FIRSetAccountInfoResponseCallback)callback {
  610|      0|  FIRSetAccountInfoResponse *response = [[FIRSetAccountInfoResponse alloc] init];
  611|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  612|      0|    if (error) {
  613|      0|      callback(nil, error);
  614|      0|    } else {
  615|      0|      callback(response, nil);
  616|      0|    }
  617|      0|  }];
  618|      0|}
  619|       |
  620|       |- (void)verifyAssertion:(FIRVerifyAssertionRequest *)request
  621|      0|               callback:(FIRVerifyAssertionResponseCallback)callback {
  622|      0|  FIRVerifyAssertionResponse *response = [[FIRVerifyAssertionResponse alloc] init];
  623|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  624|      0|    if (error) {
  625|      0|      callback(nil, error);
  626|      0|      return;
  627|      0|    }
  628|      0|    callback(response, nil);
  629|      0|  }];
  630|      0|}
  631|       |
  632|       |- (void)verifyCustomToken:(FIRVerifyCustomTokenRequest *)request
  633|      0|                 callback:(FIRVerifyCustomTokenResponseCallback)callback {
  634|      0|  FIRVerifyCustomTokenResponse *response = [[FIRVerifyCustomTokenResponse alloc] init];
  635|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  636|      0|    if (error) {
  637|      0|      callback(nil, error);
  638|      0|    } else {
  639|      0|      callback(response, nil);
  640|      0|    }
  641|      0|  }];
  642|      0|}
  643|       |
  644|       |- (void)verifyPassword:(FIRVerifyPasswordRequest *)request
  645|      0|              callback:(FIRVerifyPasswordResponseCallback)callback {
  646|      0|  FIRVerifyPasswordResponse *response = [[FIRVerifyPasswordResponse alloc] init];
  647|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  648|      0|    if (error) {
  649|      0|      callback(nil, error);
  650|      0|    } else {
  651|      0|      callback(response, nil);
  652|      0|    }
  653|      0|  }];
  654|      0|}
  655|       |
  656|       |- (void)emailLinkSignin:(FIREmailLinkSignInRequest *)request
  657|      0|               callback:(FIREmailLinkSigninResponseCallback)callback {
  658|      0|  FIREmailLinkSignInResponse *response = [[FIREmailLinkSignInResponse alloc] init];
  659|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  660|      0|    if (error) {
  661|      0|      callback(nil, error);
  662|      0|    } else {
  663|      0|      callback(response, nil);
  664|      0|    }
  665|      0|  }];
  666|      0|}
  667|       |
  668|       |- (void)secureToken:(FIRSecureTokenRequest *)request
  669|      0|           callback:(FIRSecureTokenResponseCallback)callback {
  670|      0|  FIRSecureTokenResponse *response = [[FIRSecureTokenResponse alloc] init];
  671|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  672|      0|    if (error) {
  673|      0|      callback(nil, error);
  674|      0|    } else {
  675|      0|      callback(response, nil);
  676|      0|    }
  677|      0|  }];
  678|      0|}
  679|       |
  680|       |- (void)getOOBConfirmationCode:(FIRGetOOBConfirmationCodeRequest *)request
  681|      0|                      callback:(FIRGetOOBConfirmationCodeResponseCallback)callback {
  682|      0|  FIRGetOOBConfirmationCodeResponse *response = [[FIRGetOOBConfirmationCodeResponse alloc] init];
  683|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  684|      0|    if (error) {
  685|      0|      callback(nil, error);
  686|      0|    } else {
  687|      0|      callback(response, nil);
  688|      0|    }
  689|      0|  }];
  690|      0|}
  691|       |
  692|       |- (void)signUpNewUser:(FIRSignUpNewUserRequest *)request
  693|      0|             callback:(FIRSignupNewUserCallback)callback{
  694|      0|  FIRSignUpNewUserResponse *response  = [[FIRSignUpNewUserResponse alloc] init];
  695|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  696|      0|    if (error) {
  697|      0|      callback(nil, error);
  698|      0|    } else {
  699|      0|      callback(response, nil);
  700|      0|    }
  701|      0|  }];
  702|      0|}
  703|       |
  704|      0|- (void)deleteAccount:(FIRDeleteAccountRequest *)request callback:(FIRDeleteCallBack)callback {
  705|      0|  FIRDeleteAccountResponse *response = [[FIRDeleteAccountResponse alloc] init];
  706|      0|  [self postWithRequest:request response:response callback:callback];
  707|      0|}
  708|       |
  709|       |#if TARGET_OS_IOS
  710|       |- (void)sendVerificationCode:(FIRSendVerificationCodeRequest *)request
  711|      0|                    callback:(FIRSendVerificationCodeResponseCallback)callback {
  712|      0|  FIRSendVerificationCodeResponse *response = [[FIRSendVerificationCodeResponse alloc] init];
  713|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  714|      0|    if (error) {
  715|      0|      callback(nil, error);
  716|      0|    } else {
  717|      0|      callback(response, error);
  718|      0|    }
  719|      0|  }];
  720|      0|}
  721|       |
  722|       |- (void)verifyPhoneNumber:(FIRVerifyPhoneNumberRequest *)request
  723|      0|                 callback:(FIRVerifyPhoneNumberResponseCallback)callback {
  724|      0|  FIRVerifyPhoneNumberResponse *response = [[FIRVerifyPhoneNumberResponse alloc] init];
  725|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  726|      0|    if (error) {
  727|      0|      callback(nil, error);
  728|      0|      return;
  729|      0|    }
  730|      0|    // Check whether or not the successful response is actually the special case phone auth flow
  731|      0|    // that returns a temporary proof and phone number.
  732|      0|    if (response.phoneNumber.length && response.temporaryProof.length) {
  733|      0|      FIRPhoneAuthCredential *credential =
  734|      0|          [[FIRPhoneAuthCredential alloc] initWithTemporaryProof:response.temporaryProof
  735|      0|                                                     phoneNumber:response.phoneNumber
  736|      0|                                                      providerID:FIRPhoneAuthProviderID];
  737|      0|      callback(nil,
  738|      0|               [FIRAuthErrorUtils credentialAlreadyInUseErrorWithMessage:nil
  739|      0|                                                              credential:credential]);
  740|      0|      return;
  741|      0|    }
  742|      0|    callback(response, nil);
  743|      0|  }];
  744|      0|}
  745|       |
  746|      0|- (void)verifyClient:(id)request callback:(FIRVerifyClientResponseCallback)callback {
  747|      0|  FIRVerifyClientResponse *response = [[FIRVerifyClientResponse alloc] init];
  748|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  749|      0|    if (error) {
  750|      0|      callback(nil, error);
  751|      0|      return;
  752|      0|    }
  753|      0|    callback(response, nil);
  754|      0|  }];
  755|      0|}
  756|       |#endif
  757|       |
  758|       |- (void)resetPassword:(FIRResetPasswordRequest *)request
  759|      0|             callback:(FIRResetPasswordCallback)callback {
  760|      0|  FIRResetPasswordResponse *response = [[FIRResetPasswordResponse alloc] init];
  761|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  762|      0|    if (error) {
  763|      0|      callback(nil, error);
  764|      0|      return;
  765|      0|    }
  766|      0|    callback(response, nil);
  767|      0|  }];
  768|      0|}
  769|       |
  770|       |- (void)signInWithGameCenter:(FIRSignInWithGameCenterRequest *)request
  771|      0|                    callback:(FIRSignInWithGameCenterResponseCallback)callback {
  772|      0|  FIRSignInWithGameCenterResponse *response = [[FIRSignInWithGameCenterResponse alloc] init];
  773|      0|  [self postWithRequest:request response:response callback:^(NSError *error) {
  774|      0|    if (error) {
  775|      0|      if (callback) {
  776|      0|        callback(nil, error);
  777|      0|      }
  778|      0|    } else {
  779|      0|      if (callback) {
  780|      0|        callback(response, nil);
  781|      0|      }
  782|      0|    }
  783|      0|  }];
  784|      0|}
  785|       |
  786|       |#pragma mark - Generic RPC handling methods
  787|       |
  788|       |/** @fn postWithRequest:response:callback:
  789|       |    @brief Calls the RPC using HTTP POST.
  790|       |    @remarks Possible error responses:
  791|       |        @see FIRAuthInternalErrorCodeRPCRequestEncodingError
  792|       |        @see FIRAuthInternalErrorCodeJSONSerializationError
  793|       |        @see FIRAuthInternalErrorCodeNetworkError
  794|       |        @see FIRAuthInternalErrorCodeUnexpectedErrorResponse
  795|       |        @see FIRAuthInternalErrorCodeUnexpectedResponse
  796|       |        @see FIRAuthInternalErrorCodeRPCResponseDecodingError
  797|       |    @param request The request.
  798|       |    @param response The empty response to be filled.
  799|       |    @param callback The callback for both success and failure.
  800|       | */
  801|       |- (void)postWithRequest:(id<FIRAuthRPCRequest>)request
  802|       |               response:(id<FIRAuthRPCResponse>)response
  803|      0|               callback:(void (^)(NSError *error))callback {
  804|      0|  NSError *error;
  805|      0|  NSData *bodyData;
  806|      0|  if ([request containsPostBody]) {
  807|      0|    id postBody = [request unencodedHTTPRequestBodyWithError:&error];
  808|      0|    if (!postBody) {
  809|      0|      callback([FIRAuthErrorUtils RPCRequestEncodingErrorWithUnderlyingError:error]);
  810|      0|      return;
  811|      0|    }
  812|      0|
  813|      0|    NSJSONWritingOptions JSONWritingOptions = 0;
  814|      0|    #if DEBUG
  815|      0|      JSONWritingOptions |= NSJSONWritingPrettyPrinted;
  816|      0|    #endif
  817|      0|
  818|      0|    if ([NSJSONSerialization isValidJSONObject:postBody]) {
  819|      0|      bodyData = [NSJSONSerialization dataWithJSONObject:postBody
  820|      0|                                                 options:JSONWritingOptions
  821|      0|                                                   error:&error];
  822|      0|      if (!bodyData) {
  823|      0|        // This is an untested case. This happens exclusively when there is an error in the framework
  824|      0|        // implementation of dataWithJSONObject:options:error:. This shouldn't normally occur as
  825|      0|        // isValidJSONObject: should return NO in any case we should encounter an error.
  826|      0|        error = [FIRAuthErrorUtils JSONSerializationErrorWithUnderlyingError:error];
  827|      0|      }
  828|      0|    } else {
  829|      0|      error = [FIRAuthErrorUtils JSONSerializationErrorForUnencodableType];
  830|      0|    }
  831|      0|    if (!bodyData) {
  832|      0|      callback(error);
  833|      0|      return;
  834|      0|    }
  835|      0|  }
  836|      0|
  837|      0|  [_RPCIssuer asyncPostToURLWithRequestConfiguration:[request requestConfiguration]
  838|      0|                                                 URL:[request requestURL]
  839|      0|                                                body:bodyData
  840|      0|                                         contentType:kJSONContentType
  841|      0|                                   completionHandler:^(NSData *data, NSError *error) {
  842|      0|    // If there is an error with no body data at all, then this must be a network error.
  843|      0|    if (error && !data) {
  844|      0|      callback([FIRAuthErrorUtils networkErrorWithUnderlyingError:error]);
  845|      0|      return;
  846|      0|    }
  847|      0|
  848|      0|    // Try to decode the HTTP response data which may contain either a successful response or error
  849|      0|    // message.
  850|      0|    NSError *jsonError;
  851|      0|    NSDictionary * dictionary =
  852|      0|        [NSJSONSerialization JSONObjectWithData:data
  853|      0|                                        options:NSJSONReadingMutableLeaves
  854|      0|                                          error:&jsonError];
  855|      0|    if (!dictionary) {
  856|      0|      if (error) {
  857|      0|        // We have an error, but we couldn't decode the body, so we have no additional information
  858|      0|        // other than the raw response and the original NSError (the jsonError is infered by the
  859|      0|        // error code (FIRAuthErrorCodeUnexpectedHTTPResponse, and is irrelevant.)
  860|      0|        callback([FIRAuthErrorUtils unexpectedErrorResponseWithData:data underlyingError:error]);
  861|      0|      } else {
  862|      0|        // This is supposed to be a "successful" response, but we couldn't deserialize the body.
  863|      0|        callback([FIRAuthErrorUtils unexpectedResponseWithData:data underlyingError:jsonError]);
  864|      0|      }
  865|      0|      return;
  866|      0|    }
  867|      0|    if (![dictionary isKindOfClass:[NSDictionary class]]) {
  868|      0|      if (error) {
  869|      0|        callback([FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:dictionary]);
  870|      0|      } else {
  871|      0|        callback([FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:dictionary]);
  872|      0|      }
  873|      0|      return;
  874|      0|    }
  875|      0|
  876|      0|    // At this point we either have an error with successfully decoded details in the body, or we
  877|      0|    // have a response which must pass further validation before we know it's truly successful.
  878|      0|    // We deal with the case where we have an error with successfully decoded error details first:
  879|      0|    if (error) {
  880|      0|      NSDictionary *errorDictionary = dictionary[kErrorKey];
  881|      0|      if ([errorDictionary isKindOfClass:[NSDictionary class]]) {
  882|      0|        id<NSObject> errorMessage = errorDictionary[kErrorMessageKey];
  883|      0|        if ([errorMessage isKindOfClass:[NSString class]]) {
  884|      0|          NSString *errorMessageString = (NSString *)errorMessage;
  885|      0|
  886|      0|          // Contruct client error.
  887|      0|          NSError *clientError = [[self class] clientErrorWithServerErrorMessage:errorMessageString
  888|      0|                                                                 errorDictionary:errorDictionary
  889|      0|                                                                        response:response];
  890|      0|          if (clientError) {
  891|      0|            callback(clientError);
  892|      0|            return;
  893|      0|          }
  894|      0|        }
  895|      0|        // Not a message we know, return the message directly.
  896|      0|        if (errorMessage) {
  897|      0|          NSError *unexpecterErrorResponse =
  898|      0|              [FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:errorDictionary];
  899|      0|          callback(unexpecterErrorResponse);
  900|      0|          return;
  901|      0|        }
  902|      0|      }
  903|      0|      // No error message at all, return the decoded response.
  904|      0|      callback([FIRAuthErrorUtils unexpectedErrorResponseWithDeserializedResponse:dictionary]);
  905|      0|      return;
  906|      0|    }
  907|      0|
  908|      0|    // Finally, we try to populate the response object with the JSON values.
  909|      0|    if (![response setWithDictionary:dictionary error:&error]) {
  910|      0|      callback([FIRAuthErrorUtils RPCResponseDecodingErrorWithDeserializedResponse:dictionary
  911|      0|                                                                   underlyingError:error]);
  912|      0|      return;
  913|      0|    }
  914|      0|
  915|      0|    // Success! The response object originally passed in can be used by the caller.
  916|      0|    callback(nil);
  917|      0|  }];
  918|      0|}
  919|       |
  920|       |/** @fn clientErrorWithServerErrorMessage:errorDictionary:
  921|       |    @brief Translates known server errors to client errors.
  922|       |    @param serverErrorMessage The error message from the server.
  923|       |    @param errorDictionary The error part of the response from the server.
  924|       |    @param response The response from the server RPC.
  925|       |    @return A client error, if any.
  926|       | */
  927|       |+ (nullable NSError *)clientErrorWithServerErrorMessage:(NSString *)serverErrorMessage
  928|       |                                        errorDictionary:(NSDictionary *)errorDictionary
  929|      0|                                               response:(id<FIRAuthRPCResponse>)response {
  930|      0|  NSString *shortErrorMessage = serverErrorMessage;
  931|      0|  NSString *serverDetailErrorMessage;
  932|      0|  NSRange colonRange = [serverErrorMessage rangeOfString:@":"];
  933|      0|  if (colonRange.location != NSNotFound) {
  934|      0|    shortErrorMessage = [serverErrorMessage substringToIndex:colonRange.location];
  935|      0|    shortErrorMessage =
  936|      0|        [shortErrorMessage stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
  937|      0|    serverDetailErrorMessage = [serverErrorMessage substringFromIndex:colonRange.location + 1];
  938|      0|    serverDetailErrorMessage = [serverDetailErrorMessage stringByTrimmingCharactersInSet:
  939|      0|        [NSCharacterSet whitespaceCharacterSet]];
  940|      0|  }
  941|      0|
  942|      0|  // Delegate the responsibility for constructing the client error to the response object,
  943|      0|  // if possible.
  944|      0|  SEL clientErrorWithServerErrorMessageSelector =
  945|      0|      @selector(clientErrorWithShortErrorMessage:detailErrorMessage:);
  946|      0|  if ([response respondsToSelector:clientErrorWithServerErrorMessageSelector]) {
  947|      0|    NSError *error = [response clientErrorWithShortErrorMessage:shortErrorMessage
  948|      0|                                             detailErrorMessage:serverDetailErrorMessage];
  949|      0|    if (error) {
  950|      0|      return error;
  951|      0|    }
  952|      0|  }
  953|      0|
  954|      0|  if ([shortErrorMessage isEqualToString:kUserNotFoundErrorMessage]) {
  955|      0|    return [FIRAuthErrorUtils userNotFoundErrorWithMessage:serverDetailErrorMessage];
  956|      0|  }
  957|      0|
  958|      0|  if ([shortErrorMessage isEqualToString:kUserDeletedErrorMessage]) {
  959|      0|    return [FIRAuthErrorUtils userNotFoundErrorWithMessage:serverDetailErrorMessage];
  960|      0|  }
  961|      0|
  962|      0|  if ([shortErrorMessage isEqualToString:kInvalidLocalIDErrorMessage]) {
  963|      0|    // This case shouldn't be necessary but it is for now: b/27908364 .
  964|      0|    return [FIRAuthErrorUtils userNotFoundErrorWithMessage:serverDetailErrorMessage];
  965|      0|  }
  966|      0|
  967|      0|  if ([shortErrorMessage isEqualToString:kUserTokenExpiredErrorMessage]) {
  968|      0|    return [FIRAuthErrorUtils userTokenExpiredErrorWithMessage:serverDetailErrorMessage];
  969|      0|  }
  970|      0|
  971|      0|  if ([shortErrorMessage isEqualToString:kTooManyRequestsErrorMessage]) {
  972|      0|    return [FIRAuthErrorUtils tooManyRequestsErrorWithMessage:serverDetailErrorMessage];
  973|      0|  }
  974|      0|
  975|      0|  if ([shortErrorMessage isEqualToString:kInvalidCustomTokenErrorMessage]) {
  976|      0|    return [FIRAuthErrorUtils invalidCustomTokenErrorWithMessage:serverDetailErrorMessage];
  977|      0|  }
  978|      0|
  979|      0|  if ([shortErrorMessage isEqualToString:kCustomTokenMismatch]) {
  980|      0|    return [FIRAuthErrorUtils customTokenMistmatchErrorWithMessage:serverDetailErrorMessage];
  981|      0|  }
  982|      0|
  983|      0|  if ([shortErrorMessage isEqualToString:kInvalidCredentialErrorMessage]) {
  984|      0|    return [FIRAuthErrorUtils invalidCredentialErrorWithMessage:serverDetailErrorMessage];
  985|      0|  }
  986|      0|
  987|      0|  if ([shortErrorMessage isEqualToString:kUserDisabledErrorMessage]) {
  988|      0|    return [FIRAuthErrorUtils userDisabledErrorWithMessage:serverDetailErrorMessage];
  989|      0|  }
  990|      0|
  991|      0|  if ([shortErrorMessage isEqualToString:kOperationNotAllowedErrorMessage]) {
  992|      0|    return [FIRAuthErrorUtils operationNotAllowedErrorWithMessage:serverDetailErrorMessage];
  993|      0|  }
  994|      0|
  995|      0|  if ([shortErrorMessage isEqualToString:kPasswordLoginDisabledErrorMessage]) {
  996|      0|    return [FIRAuthErrorUtils operationNotAllowedErrorWithMessage:serverDetailErrorMessage];
  997|      0|  }
  998|      0|
  999|      0|  if ([shortErrorMessage isEqualToString:kEmailAlreadyInUseErrorMessage]) {
 1000|      0|    return [FIRAuthErrorUtils emailAlreadyInUseErrorWithEmail:nil];
 1001|      0|  }
 1002|      0|
 1003|      0|  if ([shortErrorMessage isEqualToString:kInvalidEmailErrorMessage]) {
 1004|      0|    return [FIRAuthErrorUtils invalidEmailErrorWithMessage:serverDetailErrorMessage];
 1005|      0|  }
 1006|      0|
 1007|      0|  // "INVALID_IDENTIFIER" can be returned by createAuthURI RPC. Considering email addresses are
 1008|      0|  //  currently the only identifiers, we surface the FIRAuthErrorCodeInvalidEmail error code in this
 1009|      0|  //  case.
 1010|      0|  if ([shortErrorMessage isEqualToString:kInvalidIdentifierErrorMessage]) {
 1011|      0|    return [FIRAuthErrorUtils invalidEmailErrorWithMessage:serverDetailErrorMessage];
 1012|      0|  }
 1013|      0|
 1014|      0|  if ([shortErrorMessage isEqualToString:kWrongPasswordErrorMessage]) {
 1015|      0|    return [FIRAuthErrorUtils wrongPasswordErrorWithMessage:serverDetailErrorMessage];
 1016|      0|  }
 1017|      0|
 1018|      0|  if ([shortErrorMessage isEqualToString:kCredentialTooOldErrorMessage]) {
 1019|      0|    return [FIRAuthErrorUtils requiresRecentLoginErrorWithMessage:serverDetailErrorMessage];
 1020|      0|  }
 1021|      0|
 1022|      0|  if ([shortErrorMessage isEqualToString:kInvalidUserTokenErrorMessage]) {
 1023|      0|    return [FIRAuthErrorUtils invalidUserTokenErrorWithMessage:serverDetailErrorMessage];
 1024|      0|  }
 1025|      0|
 1026|      0|  if ([shortErrorMessage isEqualToString:kFederatedUserIDAlreadyLinkedMessage]) {
 1027|      0|    return [FIRAuthErrorUtils credentialAlreadyInUseErrorWithMessage:serverDetailErrorMessage
 1028|      0|                                                          credential:nil];
 1029|      0|  }
 1030|      0|
 1031|      0|  if ([shortErrorMessage isEqualToString:kWeakPasswordErrorMessagePrefix]) {
 1032|      0|    return [FIRAuthErrorUtils weakPasswordErrorWithServerResponseReason:serverDetailErrorMessage];
 1033|      0|  }
 1034|      0|
 1035|      0|  if ([shortErrorMessage isEqualToString:kExpiredActionCodeErrorMessage]) {
 1036|      0|    return [FIRAuthErrorUtils expiredActionCodeErrorWithMessage:serverDetailErrorMessage];
 1037|      0|  }
 1038|      0|
 1039|      0|  if ([shortErrorMessage isEqualToString:kInvalidActionCodeErrorMessage]) {
 1040|      0|    return [FIRAuthErrorUtils invalidActionCodeErrorWithMessage:serverDetailErrorMessage];
 1041|      0|  }
 1042|      0|
 1043|      0|  if ([shortErrorMessage isEqualToString:kMissingEmailErrorMessage]) {
 1044|      0|    return [FIRAuthErrorUtils missingEmailErrorWithMessage:serverDetailErrorMessage];
 1045|      0|  }
 1046|      0|
 1047|      0|  if ([shortErrorMessage isEqualToString:kInvalidSenderEmailErrorMessage]) {
 1048|      0|    return [FIRAuthErrorUtils invalidSenderErrorWithMessage:serverDetailErrorMessage];
 1049|      0|  }
 1050|      0|
 1051|      0|  if ([shortErrorMessage isEqualToString:kInvalidMessagePayloadErrorMessage]) {
 1052|      0|    return [FIRAuthErrorUtils invalidMessagePayloadErrorWithMessage:serverDetailErrorMessage];
 1053|      0|  }
 1054|      0|
 1055|      0|  if ([shortErrorMessage isEqualToString:kInvalidRecipientEmailErrorMessage]) {
 1056|      0|    return [FIRAuthErrorUtils invalidRecipientEmailErrorWithMessage:serverDetailErrorMessage];
 1057|      0|  }
 1058|      0|
 1059|      0|  if ([shortErrorMessage isEqualToString:kMissingIosBundleIDErrorMessage]) {
 1060|      0|    return [FIRAuthErrorUtils missingIosBundleIDErrorWithMessage:serverDetailErrorMessage];
 1061|      0|  }
 1062|      0|
 1063|      0|  if ([shortErrorMessage isEqualToString:kMissingAndroidPackageNameErrorMessage]) {
 1064|      0|    return [FIRAuthErrorUtils missingAndroidPackageNameErrorWithMessage:serverDetailErrorMessage];
 1065|      0|  }
 1066|      0|
 1067|      0|  if ([shortErrorMessage isEqualToString:kUnauthorizedDomainErrorMessage]) {
 1068|      0|    return [FIRAuthErrorUtils unauthorizedDomainErrorWithMessage:serverDetailErrorMessage];
 1069|      0|  }
 1070|      0|
 1071|      0|  if ([shortErrorMessage isEqualToString:kInvalidContinueURIErrorMessage]) {
 1072|      0|    return [FIRAuthErrorUtils invalidContinueURIErrorWithMessage:serverDetailErrorMessage];
 1073|      0|  }
 1074|      0|
 1075|      0|  if ([shortErrorMessage isEqualToString:kInvalidDynamicLinkDomainErrorMessage]) {
 1076|      0|    return [FIRAuthErrorUtils invalidDynamicLinkDomainErrorWithMessage:serverDetailErrorMessage];
 1077|      0|  }
 1078|      0|
 1079|      0|  if ([shortErrorMessage isEqualToString:kMissingContinueURIErrorMessage]) {
 1080|      0|    return [FIRAuthErrorUtils missingContinueURIErrorWithMessage:serverDetailErrorMessage];
 1081|      0|  }
 1082|      0|
 1083|      0|  if ([shortErrorMessage isEqualToString:kInvalidPhoneNumberErrorMessage]) {
 1084|      0|    return [FIRAuthErrorUtils invalidPhoneNumberErrorWithMessage:serverDetailErrorMessage];
 1085|      0|  }
 1086|      0|
 1087|      0|  if ([shortErrorMessage isEqualToString:kInvalidSessionInfoErrorMessage]) {
 1088|      0|    return [FIRAuthErrorUtils invalidVerificationIDErrorWithMessage:serverDetailErrorMessage];
 1089|      0|  }
 1090|      0|
 1091|      0|  if ([shortErrorMessage isEqualToString:kInvalidVerificationCodeErrorMessage]) {
 1092|      0|    return [FIRAuthErrorUtils invalidVerificationCodeErrorWithMessage:serverDetailErrorMessage];
 1093|      0|  }
 1094|      0|
 1095|      0|  if ([shortErrorMessage isEqualToString:kSessionExpiredErrorMessage]) {
 1096|      0|    return [FIRAuthErrorUtils sessionExpiredErrorWithMessage:serverDetailErrorMessage];
 1097|      0|  }
 1098|      0|
 1099|      0|  if ([shortErrorMessage isEqualToString:kMissingAppTokenErrorMessage]) {
 1100|      0|    return [FIRAuthErrorUtils missingAppTokenErrorWithUnderlyingError:nil];
 1101|      0|  }
 1102|      0|
 1103|      0|  if ([shortErrorMessage isEqualToString:kMissingAppCredentialErrorMessage]) {
 1104|      0|    return [FIRAuthErrorUtils missingAppCredentialWithMessage:serverDetailErrorMessage];
 1105|      0|  }
 1106|      0|
 1107|      0|  if ([shortErrorMessage isEqualToString:kInvalidAppCredentialErrorMessage]) {
 1108|      0|    return [FIRAuthErrorUtils invalidAppCredentialWithMessage:serverDetailErrorMessage];
 1109|      0|  }
 1110|      0|
 1111|      0|  if ([shortErrorMessage isEqualToString:kQuoutaExceededErrorMessage]) {
 1112|      0|    return [FIRAuthErrorUtils quotaExceededErrorWithMessage:serverErrorMessage];
 1113|      0|  }
 1114|      0|
 1115|      0|  if ([shortErrorMessage isEqualToString:kAppNotVerifiedErrorMessage]) {
 1116|      0|    return [FIRAuthErrorUtils appNotVerifiedErrorWithMessage:serverErrorMessage];
 1117|      0|  }
 1118|      0|
 1119|      0|  if ([shortErrorMessage isEqualToString:kMissingClientIdentifier]) {
 1120|      0|    return [FIRAuthErrorUtils appNotVerifiedErrorWithMessage:@"Missing app verification via"
 1121|      0|        " reCAPTCHA or APNS token. Please verify that appVerificationDisabledForTesting is not"
 1122|      0|        " enabled when testing with a phone number that is not marked as a test Phone number in the"
 1123|      0|        " app console."];
 1124|      0|  }
 1125|      0|
 1126|      0|  if ([shortErrorMessage isEqualToString:kCaptchaCheckFailedErrorMessage]) {
 1127|      0|    return [FIRAuthErrorUtils captchaCheckFailedErrorWithMessage:serverErrorMessage];
 1128|      0|  }
 1129|      0|
 1130|      0|  // In this case we handle an error that might be specified in the underlying errors dictionary,
 1131|      0|  // the error message in determined based on the @c reason key in the dictionary.
 1132|      0|  if (errorDictionary[kErrorsKey]) {
 1133|      0|    // Check for underlying error with reason = keyInvalid;
 1134|      0|    id underlyingErrors = errorDictionary[kErrorsKey];
 1135|      0|    if ([underlyingErrors isKindOfClass:[NSArray class]]) {
 1136|      0|      NSArray *underlyingErrorsArray = (NSArray *)underlyingErrors;
 1137|      0|      for (id underlyingError in underlyingErrorsArray) {
 1138|      0|        if ([underlyingError isKindOfClass:[NSDictionary class]]) {
 1139|      0|          NSDictionary *underlyingErrorDictionary = (NSDictionary *)underlyingError;
 1140|      0|          NSString *reason = underlyingErrorDictionary[kReasonKey];
 1141|      0|          if ([reason hasPrefix:kInvalidKeyReasonValue]) {
 1142|      0|            return [FIRAuthErrorUtils invalidAPIKeyError];
 1143|      0|          }
 1144|      0|          if ([reason isEqualToString:kAppNotAuthorizedReasonValue]) {
 1145|      0|            return [FIRAuthErrorUtils appNotAuthorizedError];
 1146|      0|          }
 1147|      0|        }
 1148|      0|      }
 1149|      0|    }
 1150|      0|  }
 1151|      0|  return nil;
 1152|      0|}
 1153|       |
 1154|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRAuthRequestConfiguration.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRAuthRequestConfiguration.h"
   18|       |#import "FIRAuthExceptionUtils.h"
   19|       |
   20|       |NS_ASSUME_NONNULL_BEGIN
   21|       |
   22|       |@implementation FIRAuthRequestConfiguration
   23|       |
   24|      1|- (nullable instancetype)initWithAPIKey:(NSString *)APIKey {
   25|      1|  self = [super init];
   26|      1|  if (self) {
   27|      1|    _APIKey = [APIKey copy];
   28|      1|  }
   29|      1|  return self;
   30|      1|}
   31|       |
   32|       |@end
   33|       |
   34|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRCreateAuthURIRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRCreateAuthURIRequest.h"
   18|       |
   19|       |/** @var kCreateAuthURIEndpoint
   20|       |    @brief The "createAuthUri" endpoint.
   21|       | */
   22|       |static NSString *const kCreateAuthURIEndpoint = @"createAuthUri";
   23|       |
   24|       |/** @var kProviderIDKey
   25|       |    @brief The key for the "providerId" value in the request.
   26|       | */
   27|       |static NSString *const kProviderIDKey = @"providerId";
   28|       |
   29|       |/** @var kIdentifierKey
   30|       |    @brief The key for the "identifier" value in the request.
   31|       | */
   32|       |static NSString *const kIdentifierKey = @"identifier";
   33|       |
   34|       |/** @var kContinueURIKey
   35|       |    @brief The key for the "continueUri" value in the request.
   36|       | */
   37|       |static NSString *const kContinueURIKey = @"continueUri";
   38|       |
   39|       |/** @var kOpenIDRealmKey
   40|       |    @brief The key for the "openidRealm" value in the request.
   41|       | */
   42|       |static NSString *const kOpenIDRealmKey = @"openidRealm";
   43|       |
   44|       |/** @var kClientIDKey
   45|       |    @brief The key for the "clientId" value in the request.
   46|       | */
   47|       |static NSString *const kClientIDKey = @"clientId";
   48|       |
   49|       |/** @var kContextKey
   50|       |    @brief The key for the "context" value in the request.
   51|       | */
   52|       |static NSString *const kContextKey = @"context";
   53|       |
   54|       |/** @var kAppIDKey
   55|       |    @brief The key for the "appId" value in the request.
   56|       | */
   57|       |static NSString *const kAppIDKey = @"appId";
   58|       |
   59|       |@implementation FIRCreateAuthURIRequest
   60|       |
   61|       |- (nullable instancetype)initWithIdentifier:(NSString *)identifier
   62|       |                                continueURI:(NSString *)continueURI
   63|      0|                       requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   64|      0|  self = [super initWithEndpoint:kCreateAuthURIEndpoint requestConfiguration:requestConfiguration];
   65|      0|  if (self) {
   66|      0|    _identifier = [identifier copy];
   67|      0|    _continueURI = [continueURI copy];
   68|      0|  }
   69|      0|  return self;
   70|      0|}
   71|       |
   72|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   73|      0|  NSMutableDictionary *postBody = [@{
   74|      0|    kIdentifierKey : _identifier,
   75|      0|    kContinueURIKey : _continueURI
   76|      0|  } mutableCopy];
   77|      0|  if (_providerID) {
   78|      0|    postBody[kProviderIDKey] = _providerID;
   79|      0|  }
   80|      0|  if (_openIDRealm) {
   81|      0|    postBody[kOpenIDRealmKey] = _openIDRealm;
   82|      0|  }
   83|      0|  if (_clientID) {
   84|      0|    postBody[kClientIDKey] = _clientID;
   85|      0|  }
   86|      0|  if (_context) {
   87|      0|    postBody[kContextKey] = _context;
   88|      0|  }
   89|      0|  if (_appID) {
   90|      0|    postBody[kAppIDKey] = _appID;
   91|      0|  }
   92|      0|  return postBody;
   93|      0|}
   94|       |
   95|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRCreateAuthURIResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRCreateAuthURIResponse.h"
   18|       |
   19|       |@implementation FIRCreateAuthURIResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                    error:(NSError *_Nullable *_Nullable)error {
   23|      0|  _providerID = [dictionary[@"providerId"] copy];
   24|      0|  _authURI = [dictionary[@"authUri"] copy];
   25|      0|  _registered = [dictionary[@"registered"] boolValue];
   26|      0|  _forExistingProvider = [dictionary[@"forExistingProvider"] boolValue];
   27|      0|  _allProviders = [dictionary[@"allProviders"] copy];
   28|      0|  _signinMethods = [dictionary[@"signinMethods"] copy];
   29|      0|  return YES;
   30|      0|}
   31|       |
   32|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRDeleteAccountRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDeleteAccountRequest.h"
   18|       |
   19|       |/** @var kCreateAuthURIEndpoint
   20|       |    @brief The "deleteAccount" endpoint.
   21|       | */
   22|       |static NSString *const kDeleteAccountEndpoint = @"deleteAccount";
   23|       |
   24|       |/** @var kIDTokenKey
   25|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   26|       |        despite it's confusing (backwards compatiable) parameter name.
   27|       | */
   28|       |static NSString *const kIDTokenKey = @"idToken";
   29|       |
   30|       |/** @var kLocalIDKey
   31|       |    @brief The key for the "localID" value in the request.
   32|       | */
   33|       |static NSString *const kLocalIDKey = @"localId";
   34|       |
   35|       |@implementation FIRDeleteAccountRequest {
   36|       |  /** @var _accessToken
   37|       |      @brief The STS Access Token of the authenticated user.
   38|       |   */
   39|       |  NSString *_accessToken;
   40|       |
   41|       |  /** @var _localID
   42|       |      @brief The localID of the user.
   43|       |   */
   44|       |  NSString *_localID;
   45|       |}
   46|       |
   47|       |- (nullable instancetype)initWitLocalID:(NSString *)localID
   48|       |                            accessToken:(NSString *)accessToken
   49|      0|                   requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   50|      0|  self = [super initWithEndpoint:kDeleteAccountEndpoint requestConfiguration:requestConfiguration];
   51|      0|  if (self) {
   52|      0|    _localID = [localID copy];
   53|      0|    _accessToken = [accessToken copy];
   54|      0|  }
   55|      0|  return self;
   56|      0|}
   57|       |
   58|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   59|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   60|      0|  postBody[kIDTokenKey] = _accessToken;
   61|      0|  postBody[kLocalIDKey] = _localID;
   62|      0|  return postBody;
   63|      0|}
   64|       |
   65|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRDeleteAccountResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRDeleteAccountResponse.h"
   18|       |
   19|       |@implementation FIRDeleteAccountResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                   error:(NSError *_Nullable *_Nullable)error {
   23|      0|  return YES;
   24|      0|}
   25|       |
   26|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIREmailLinkSignInRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIREmailLinkSignInRequest.h"
   18|       |
   19|       |/** @var kEmailLinkSigninEndpoint
   20|       |    @brief The "EmailLinkSignin" endpoint.
   21|       | */
   22|       |static NSString *const kEmailLinkSigninEndpoint = @"emailLinkSignin";
   23|       |
   24|       |/** @var kEmailKey
   25|       |    @brief The key for the "identifier" value in the request.
   26|       | */
   27|       |static NSString *const kEmailKey = @"email";
   28|       |
   29|       |/** @var kEmailLinkKey
   30|       |    @brief The key for the "emailLink" value in the request.
   31|       | */
   32|       |static NSString *const kOOBCodeKey = @"oobCode";
   33|       |
   34|       |/** @var kIDTokenKey
   35|       |    @brief The key for the "IDToken" value in the request.
   36|       | */
   37|       |static NSString *const kIDTokenKey = @"idToken";
   38|       |
   39|       |/** @var kPostBodyKey
   40|       |    @brief The key for the "postBody" value in the request.
   41|       | */
   42|       |static NSString *const kPostBodyKey = @"postBody";
   43|       |
   44|       |@implementation FIREmailLinkSignInRequest
   45|       |
   46|       |- (instancetype)initWithEmail:(NSString *)email
   47|       |                      oobCode:(NSString *)oobCode
   48|      0|         requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   49|      0|  self = [super initWithEndpoint:kEmailLinkSigninEndpoint
   50|      0|            requestConfiguration:requestConfiguration];
   51|      0|  if (self) {
   52|      0|    _email = email;
   53|      0|    _oobCode = oobCode;
   54|      0|  }
   55|      0|  return self;
   56|      0|}
   57|       |
   58|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   59|      0|  NSMutableDictionary *postBody = [@{
   60|      0|    kEmailKey : _email,
   61|      0|    kOOBCodeKey : _oobCode,
   62|      0|  } mutableCopy];
   63|      0|
   64|      0|  if (_IDToken) {
   65|      0|    postBody[kIDTokenKey] = _IDToken;
   66|      0|  }
   67|      0|  return postBody;
   68|      0|}
   69|       |
   70|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIREmailLinkSignInResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIREmailLinkSignInResponse.h"
   18|       |
   19|       |@implementation FIREmailLinkSignInResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                    error:(NSError *_Nullable  *_Nullable)error {
   23|      0|  _email = [dictionary[@"email"] copy];
   24|      0|  _IDToken = [dictionary[@"idToken"] copy];
   25|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   26|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   27|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   28|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   29|      0|  return YES;
   30|      0|}
   31|       |
   32|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRGetAccountInfoRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetAccountInfoRequest.h"
   18|       |
   19|       |/** @var kGetAccountInfoEndpoint
   20|       |    @brief The "getAccountInfo" endpoint.
   21|       | */
   22|       |static NSString *const kGetAccountInfoEndpoint = @"getAccountInfo";
   23|       |
   24|       |/** @var kIDTokenKey
   25|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   26|       |        despite it's confusing (backwards compatiable) parameter name.
   27|       | */
   28|       |static NSString *const kIDTokenKey = @"idToken";
   29|       |
   30|       |@implementation FIRGetAccountInfoRequest
   31|       |
   32|       |- (nullable instancetype)initWithAccessToken:(NSString *)accessToken
   33|      0|                        requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   34|      0|  self = [super initWithEndpoint:kGetAccountInfoEndpoint
   35|      0|            requestConfiguration:requestConfiguration];
   36|      0|  if (self) {
   37|      0|    _accessToken = [accessToken copy];
   38|      0|  }
   39|      0|  return self;
   40|      0|}
   41|       |
   42|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   43|      0|  return @{
   44|      0|    kIDTokenKey : _accessToken
   45|      0|  };
   46|      0|}
   47|       |
   48|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRGetAccountInfoResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetAccountInfoResponse.h"
   18|       |
   19|       |#import "FIRAuthErrorUtils.h"
   20|       |
   21|       |/** @var kErrorKey
   22|       |    @brief The key for the "error" value in JSON responses from the server.
   23|       | */
   24|       |static NSString *const kErrorKey = @"error";
   25|       |
   26|       |@implementation FIRGetAccountInfoResponseProviderUserInfo
   27|       |
   28|      0|- (instancetype)initWithDictionary:(NSDictionary *)dictionary {
   29|      0|  self = [super init];
   30|      0|  if (self) {
   31|      0|    _providerID = [dictionary[@"providerId"] copy];
   32|      0|    _displayName = [dictionary[@"displayName"] copy];
   33|      0|    NSString *photoURL = dictionary[@"photoUrl"];
   34|      0|    if (photoURL) {
   35|      0|      _photoURL = [NSURL URLWithString:photoURL];
   36|      0|    }
   37|      0|    _federatedID = [dictionary[@"federatedId"] copy];
   38|      0|    _email = [dictionary[@"email"] copy];
   39|      0|    _phoneNumber = [dictionary[@"phoneNumber"] copy];
   40|      0|  }
   41|      0|  return self;
   42|      0|}
   43|       |
   44|       |@end
   45|       |
   46|       |@implementation FIRGetAccountInfoResponseUser
   47|       |
   48|      0|- (instancetype)initWithDictionary:(NSDictionary *)dictionary {
   49|      0|  self = [super init];
   50|      0|  if (self) {
   51|      0|    NSArray<NSDictionary *> *providerUserInfoData = dictionary[@"providerUserInfo"];
   52|      0|    if (providerUserInfoData) {
   53|      0|      NSMutableArray<FIRGetAccountInfoResponseProviderUserInfo *> *providerUserInfoArray =
   54|      0|          [NSMutableArray arrayWithCapacity:providerUserInfoData.count];
   55|      0|      for (NSDictionary *dictionary in providerUserInfoData) {
   56|      0|        [providerUserInfoArray addObject:
   57|      0|            [[FIRGetAccountInfoResponseProviderUserInfo alloc] initWithDictionary:dictionary]];
   58|      0|      }
   59|      0|      _providerUserInfo = [providerUserInfoArray copy];
   60|      0|    }
   61|      0|    _localID = [dictionary[@"localId"] copy];
   62|      0|    _displayName = [dictionary[@"displayName"] copy];
   63|      0|    _email = [dictionary[@"email"] copy];
   64|      0|    NSString *photoURL = dictionary[@"photoUrl"];
   65|      0|    if (photoURL) {
   66|      0|      _photoURL = [NSURL URLWithString:photoURL];
   67|      0|    }
   68|      0|    if ([dictionary[@"createdAt"] isKindOfClass:[NSString class]]) {
   69|      0|      // Divide by 1000 in order to convert miliseconds to seconds.
   70|      0|      NSTimeInterval creationDateTimeInterval = [dictionary[@"createdAt"] doubleValue] / 1000;
   71|      0|      _creationDate = [NSDate dateWithTimeIntervalSince1970:creationDateTimeInterval];
   72|      0|    }
   73|      0|    if ([dictionary[@"lastLoginAt"] isKindOfClass:[NSString class]]) {
   74|      0|      // Divide by 1000 in order to convert miliseconds to seconds
   75|      0|      NSTimeInterval creationDateTimeInterval = [dictionary[@"lastLoginAt"] doubleValue] / 1000;
   76|      0|      _lastLoginDate = [NSDate dateWithTimeIntervalSince1970:creationDateTimeInterval];
   77|      0|    }
   78|      0|    _emailVerified = [dictionary[@"emailVerified"] boolValue];
   79|      0|    _passwordHash = [dictionary[@"passwordHash"] copy];
   80|      0|    _phoneNumber = [dictionary[@"phoneNumber"] copy];
   81|      0|  }
   82|      0|  return self;
   83|      0|}
   84|       |
   85|       |@end
   86|       |
   87|       |@implementation FIRGetAccountInfoResponse
   88|       |
   89|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   90|      0|                    error:(NSError *_Nullable *_Nullable)error {
   91|      0|  NSArray<NSDictionary *> *usersData = dictionary[@"users"];
   92|      0|  // The client side never sends a getAccountInfo request with multiple localID, so only one user
   93|      0|  // data is expected in the response.
   94|      0|  if (![usersData isKindOfClass:[NSArray class]] || usersData.count != 1) {
   95|      0|    if (error) {
   96|      0|      *error = [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:dictionary];
   97|      0|    }
   98|      0|    return NO;
   99|      0|  }
  100|      0|  _users = @[ [[FIRGetAccountInfoResponseUser alloc] initWithDictionary:usersData.firstObject] ];
  101|      0|  return YES;
  102|      0|}
  103|       |
  104|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRGetOOBConfirmationCodeRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetOOBConfirmationCodeRequest.h"
   18|       |
   19|       |#import "FIRActionCodeSettings.h"
   20|       |
   21|       |#import "FIRAuthErrorUtils.h"
   22|       |#import "FIRAuth_Internal.h"
   23|       |
   24|       |/** @var kEndpoint
   25|       |    @brief The getOobConfirmationCode endpoint name.
   26|       | */
   27|       |static NSString *const kGetOobConfirmationCodeEndpoint = @"getOobConfirmationCode";
   28|       |
   29|       |/** @var kRequestTypeKey
   30|       |    @brief The name of the required "requestType" property in the request.
   31|       | */
   32|       |static NSString *const kRequestTypeKey = @"requestType";
   33|       |
   34|       |/** @var kEmailKey
   35|       |    @brief The name of the "email" property in the request.
   36|       | */
   37|       |static NSString *const kEmailKey = @"email";
   38|       |
   39|       |/** @var kIDTokenKey
   40|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   41|       |        despite it's confusing (backwards compatiable) parameter name.
   42|       | */
   43|       |static NSString *const kIDTokenKey = @"idToken";
   44|       |
   45|       |/** @var kContinueURLKey
   46|       |    @brief The key for the "continue URL" value in the request.
   47|       | */
   48|       |static NSString *const kContinueURLKey = @"continueUrl";
   49|       |
   50|       |/** @var kIosBundeIDKey
   51|       |    @brief The key for the "iOS Bundle Identifier" value in the request.
   52|       | */
   53|       |static NSString *const kIosBundleIDKey = @"iOSBundleId";
   54|       |
   55|       |/** @var kAndroidPackageNameKey
   56|       |    @brief The key for the "Android Package Name" value in the request.
   57|       | */
   58|       |static NSString *const kAndroidPackageNameKey = @"androidPackageName";
   59|       |
   60|       |/** @var kAndroidInstallAppKey
   61|       |    @brief The key for the request parameter indicating whether the android app should be installed
   62|       |        or not.
   63|       | */
   64|       |static NSString *const kAndroidInstallAppKey = @"androidInstallApp";
   65|       |
   66|       |/** @var kAndroidMinimumVersionKey
   67|       |    @brief The key for the "minimum Android version supported" value in the request.
   68|       | */
   69|       |static NSString *const kAndroidMinimumVersionKey = @"androidMinimumVersion";
   70|       |
   71|       |/** @var kCanHandleCodeInAppKey
   72|       |    @brief The key for the request parameter indicating whether the action code can be handled in
   73|       |        the app or not.
   74|       | */
   75|       |static NSString *const kCanHandleCodeInAppKey = @"canHandleCodeInApp";
   76|       |
   77|       |/** @var kDynamicLinkDomainKey
   78|       |    @brief The key for the "dynamic link domain" value in the request.
   79|       | */
   80|       |static NSString *const kDynamicLinkDomainKey = @"dynamicLinkDomain";
   81|       |
   82|       |/** @var kPasswordResetRequestTypeValue
   83|       |    @brief The value for the "PASSWORD_RESET" request type.
   84|       | */
   85|       |static NSString *const kPasswordResetRequestTypeValue = @"PASSWORD_RESET";
   86|       |
   87|       |/** @var kEmailLinkSignInTypeValue
   88|       |    @brief The value for the "EMAIL_SIGNIN" request type.
   89|       | */
   90|       |static NSString *const kEmailLinkSignInTypeValue= @"EMAIL_SIGNIN";
   91|       |
   92|       |/** @var kVerifyEmailRequestTypeValue
   93|       |    @brief The value for the "VERIFY_EMAIL" request type.
   94|       | */
   95|       |static NSString *const kVerifyEmailRequestTypeValue = @"VERIFY_EMAIL";
   96|       |
   97|       |@interface FIRGetOOBConfirmationCodeRequest ()
   98|       |
   99|       |/** @fn initWithRequestType:email:APIKey:
  100|       |    @brief Designated initializer.
  101|       |    @param requestType The types of OOB Confirmation Code to request.
  102|       |    @param email The email of the user.
  103|       |    @param accessToken The STS Access Token of the currently signed in user.
  104|       |    @param actionCodeSettings An object of FIRActionCodeSettings which specifies action code
  105|       |        settings to be applied to the OOB code request.
  106|       |    @param requestConfiguration An object containing configurations to be added to the request.
  107|       | */
  108|       |- (nullable instancetype)initWithRequestType:(FIRGetOOBConfirmationCodeRequestType)requestType
  109|       |                                       email:(nullable NSString *)email
  110|       |                                 accessToken:(nullable NSString *)accessToken
  111|       |                          actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  112|       |                        requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration
  113|       |                              NS_DESIGNATED_INITIALIZER;
  114|       |
  115|       |@end
  116|       |
  117|       |@implementation FIRGetOOBConfirmationCodeRequest
  118|       |
  119|       |/** @var requestTypeStringValueForRequestType:
  120|       |    @brief Returns the string equivilent for an @c FIRGetOOBConfirmationCodeRequestType value.
  121|       | */
  122|       |+ (NSString *)requestTypeStringValueForRequestType:
  123|      0|    (FIRGetOOBConfirmationCodeRequestType)requestType {
  124|      0|  switch (requestType) {
  125|      0|    case FIRGetOOBConfirmationCodeRequestTypePasswordReset:
  126|      0|      return kPasswordResetRequestTypeValue;
  127|      0|    case FIRGetOOBConfirmationCodeRequestTypeVerifyEmail:
  128|      0|      return kVerifyEmailRequestTypeValue;
  129|      0|    case FIRGetOOBConfirmationCodeRequestTypeEmailLink:
  130|      0|      return kEmailLinkSignInTypeValue;
  131|      0|    // No default case so that we get a compiler warning if a new value was added to the enum.
  132|      0|  }
  133|      0|}
  134|       |
  135|       |+ (FIRGetOOBConfirmationCodeRequest *)
  136|       |    passwordResetRequestWithEmail:(NSString *)email
  137|       |               actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  138|      0|             requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  139|      0|  return [[self alloc] initWithRequestType:FIRGetOOBConfirmationCodeRequestTypePasswordReset
  140|      0|                                     email:email
  141|      0|                               accessToken:nil
  142|      0|                        actionCodeSettings:actionCodeSettings
  143|      0|                      requestConfiguration:requestConfiguration];
  144|      0|}
  145|       |
  146|       |+ (FIRGetOOBConfirmationCodeRequest *)
  147|       |    verifyEmailRequestWithAccessToken:(NSString *)accessToken
  148|       |                   actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  149|      0|                 requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  150|      0|  return [[self alloc] initWithRequestType:FIRGetOOBConfirmationCodeRequestTypeVerifyEmail
  151|      0|                                     email:nil
  152|      0|                               accessToken:accessToken
  153|      0|                        actionCodeSettings:actionCodeSettings
  154|      0|                      requestConfiguration:requestConfiguration];
  155|      0|}
  156|       |
  157|       |+ (FIRGetOOBConfirmationCodeRequest *)
  158|       |    signInWithEmailLinkRequest:(NSString *)email
  159|       |            actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  160|      0|          requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  161|      0|  return [[self alloc] initWithRequestType:FIRGetOOBConfirmationCodeRequestTypeEmailLink
  162|      0|                                     email:email
  163|      0|                               accessToken:nil
  164|      0|                        actionCodeSettings:actionCodeSettings
  165|      0|                      requestConfiguration:requestConfiguration];
  166|      0|}
  167|       |
  168|       |- (nullable instancetype)initWithRequestType:(FIRGetOOBConfirmationCodeRequestType)requestType
  169|       |                                       email:(nullable NSString *)email
  170|       |                                 accessToken:(nullable NSString *)accessToken
  171|       |                          actionCodeSettings:(nullable FIRActionCodeSettings *)actionCodeSettings
  172|      0|                        requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  173|      0|  self = [super initWithEndpoint:kGetOobConfirmationCodeEndpoint
  174|      0|            requestConfiguration:requestConfiguration];
  175|      0|  if (self) {
  176|      0|    _requestType = requestType;
  177|      0|    _email = email;
  178|      0|    _accessToken = accessToken;
  179|      0|    _continueURL = actionCodeSettings.URL.absoluteString;
  180|      0|    _iOSBundleID = actionCodeSettings.iOSBundleID;
  181|      0|    _androidPackageName = actionCodeSettings.androidPackageName;
  182|      0|    _androidMinimumVersion = actionCodeSettings.androidMinimumVersion;
  183|      0|    _androidInstallApp = actionCodeSettings.androidInstallIfNotAvailable;
  184|      0|    _handleCodeInApp = actionCodeSettings.handleCodeInApp;
  185|      0|    _dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
  186|      0|  }
  187|      0|  return self;
  188|      0|}
  189|       |
  190|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
  191|      0|  NSMutableDictionary *body = [@{
  192|      0|    kRequestTypeKey : [[self class] requestTypeStringValueForRequestType:_requestType]
  193|      0|  } mutableCopy];
  194|      0|
  195|      0|  // For password reset requests, we only need an email address in addition to the already required
  196|      0|  // fields.
  197|      0|  if (_requestType == FIRGetOOBConfirmationCodeRequestTypePasswordReset) {
  198|      0|    body[kEmailKey] = _email;
  199|      0|  }
  200|      0|
  201|      0|  // For verify email requests, we only need an STS Access Token in addition to the already required
  202|      0|  // fields.
  203|      0|  if (_requestType == FIRGetOOBConfirmationCodeRequestTypeVerifyEmail) {
  204|      0|    body[kIDTokenKey] = _accessToken;
  205|      0|  }
  206|      0|
  207|      0|  // For email sign-in link requests, we only need an email address in addition to the already
  208|      0|  // required fields.
  209|      0|  if (_requestType == FIRGetOOBConfirmationCodeRequestTypeEmailLink) {
  210|      0|    body[kEmailKey] = _email;
  211|      0|  }
  212|      0|
  213|      0|  if (_continueURL) {
  214|      0|    body[kContinueURLKey] = _continueURL;
  215|      0|  }
  216|      0|
  217|      0|  if (_iOSBundleID) {
  218|      0|    body[kIosBundleIDKey] = _iOSBundleID;
  219|      0|  }
  220|      0|
  221|      0|  if (_androidPackageName) {
  222|      0|    body[kAndroidPackageNameKey] = _androidPackageName;
  223|      0|  }
  224|      0|
  225|      0|  if (_androidMinimumVersion) {
  226|      0|    body[kAndroidMinimumVersionKey] = _androidMinimumVersion;
  227|      0|  }
  228|      0|
  229|      0|  if (_androidInstallApp) {
  230|      0|    body[kAndroidInstallAppKey] = @YES;
  231|      0|  }
  232|      0|
  233|      0|  if (_handleCodeInApp) {
  234|      0|    body[kCanHandleCodeInAppKey] = @YES;
  235|      0|  }
  236|      0|
  237|      0|  if (_dynamicLinkDomain) {
  238|      0|    body[kDynamicLinkDomainKey] = _dynamicLinkDomain;
  239|      0|  }
  240|      0|
  241|      0|  return body;
  242|      0|}
  243|       |
  244|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRGetOOBConfirmationCodeResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetOOBConfirmationCodeResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kOOBCodeKey
   22|       |    @brief The name of the field in the response JSON for the OOB code.
   23|       | */
   24|       |static NSString *const kOOBCodeKey = @"oobCode";
   25|       |
   26|       |@implementation FIRGetOOBConfirmationCodeResponse
   27|       |
   28|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   29|      0|                    error:(NSError *_Nullable *_Nullable)error {
   30|      0|  _OOBCode = [dictionary[kOOBCodeKey] copy];
   31|      0|  return YES;
   32|      0|}
   33|       |
   34|       |@end
   35|       |
   36|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRGetProjectConfigRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetProjectConfigRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kGetProjectConfigEndPoint
   22|       |    @brief The "getProjectConfig" endpoint.
   23|       | */
   24|       |static NSString *const kGetProjectConfigEndPoint = @"getProjectConfig";
   25|       |
   26|       |@implementation FIRGetProjectConfigRequest
   27|       |
   28|       |- (nullable instancetype)initWithRequestConfiguration:
   29|      0|    (FIRAuthRequestConfiguration *)requestConfiguration {
   30|      0|  return [super initWithEndpoint:kGetProjectConfigEndPoint
   31|      0|            requestConfiguration:requestConfiguration];
   32|      0|}
   33|       |
   34|      0|- (BOOL)containsPostBody {
   35|      0|  return NO;
   36|      0|}
   37|       |
   38|       |@end
   39|       |
   40|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRGetProjectConfigResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRGetProjectConfigResponse.h"
   18|       |
   19|       |@implementation FIRGetProjectConfigResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                    error:(NSError *_Nullable *_Nullable)error {
   23|      0|  _projectID = [dictionary[@"projectId"] copy];
   24|      0|  id authorizedDomains = dictionary[@"authorizedDomains"];
   25|      0|  if ([authorizedDomains isKindOfClass:[NSString class]]) {
   26|      0|    NSData *data = [authorizedDomains dataUsingEncoding:NSUTF8StringEncoding];
   27|      0|    authorizedDomains = [NSJSONSerialization JSONObjectWithData:data
   28|      0|                                                       options:NSJSONReadingMutableLeaves
   29|      0|                                                         error:nil];
   30|      0|  }
   31|      0|  if ([authorizedDomains isKindOfClass:[NSArray class]]) {
   32|      0|    _authorizedDomains = [[NSArray alloc] initWithArray:authorizedDomains
   33|      0|                                              copyItems:YES];
   34|      0|  }
   35|      0|  return YES;
   36|      0|}
   37|       |
   38|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRIdentityToolkitRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRIdentityToolkitRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kAPIURLFormat
   22|       |    @brief URL format for server API calls.
   23|       | */
   24|       |static NSString *const kAPIURLFormat = @"https://%@/identitytoolkit/v3/relyingparty/%@?key=%@";
   25|       |
   26|       |/** @var gAPIHost
   27|       |    @brief Host for server API calls.
   28|       | */
   29|       |static NSString *gAPIHost = @"www.googleapis.com";
   30|       |
   31|       |@implementation FIRIdentityToolkitRequest {
   32|       |  FIRAuthRequestConfiguration *_requestConfiguration;
   33|       |}
   34|       |
   35|       |- (nullable instancetype)initWithEndpoint:(NSString *)endpoint
   36|      0|                     requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   37|      0|  self = [super init];
   38|      0|  if (self) {
   39|      0|    _endpoint = [endpoint copy];
   40|      0|    _APIKey = [requestConfiguration.APIKey copy];
   41|      0|    _requestConfiguration = requestConfiguration;
   42|      0|  }
   43|      0|  return self;
   44|      0|}
   45|       |
   46|      0|- (BOOL)containsPostBody {
   47|      0|  return YES;
   48|      0|}
   49|       |
   50|      0|- (NSURL *)requestURL {
   51|      0|  NSString *URLString = [NSString stringWithFormat:kAPIURLFormat, gAPIHost, _endpoint, _APIKey];
   52|      0|  NSURL *URL = [NSURL URLWithString:URLString];
   53|      0|  return URL;
   54|      0|}
   55|       |
   56|      0|- (FIRAuthRequestConfiguration *)requestConfiguration {
   57|      0|  return _requestConfiguration;
   58|      0|}
   59|       |
   60|       |#pragma mark - Internal API for development
   61|       |
   62|      0|+ (NSString *)host {
   63|      0|  return gAPIHost;
   64|      0|}
   65|       |
   66|      0|+ (void)setHost:(NSString *)host {
   67|      0|  gAPIHost = host;
   68|      0|}
   69|       |
   70|       |NS_ASSUME_NONNULL_END
   71|       |
   72|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRResetPasswordRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRResetPasswordRequest.h"
   18|       |
   19|       |/** @var kResetPasswordEndpoint
   20|       |    @brief The "resetPassword" endpoint.
   21|       | */
   22|       |static NSString *const kResetPasswordEndpoint = @"resetPassword";
   23|       |
   24|       |/** @var kOOBCodeKey
   25|       |    @brief The "resetPassword" key.
   26|       | */
   27|       |static NSString *const kOOBCodeKey = @"oobCode";
   28|       |
   29|       |/** @var kCurrentPasswordKey
   30|       |    @brief The "newPassword" key.
   31|       | */
   32|       |static NSString *const kCurrentPasswordKey = @"newPassword";
   33|       |
   34|       |@implementation FIRResetPasswordRequest
   35|       |
   36|       |- (instancetype)initWithOobCode:(NSString *)oobCode
   37|       |                   newPassword:(NSString *)newPassword
   38|      0|          requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   39|      0|  self = [super initWithEndpoint:kResetPasswordEndpoint requestConfiguration:requestConfiguration];
   40|      0|  if (self) {
   41|      0|    _oobCode = oobCode;
   42|      0|    _updatedPassword = newPassword;
   43|      0|  }
   44|      0|  return self;
   45|      0|}
   46|       |
   47|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   48|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   49|      0|  postBody[kOOBCodeKey] = _oobCode;
   50|      0|  if (_updatedPassword) {
   51|      0|    postBody[kCurrentPasswordKey] = _updatedPassword;
   52|      0|  }
   53|      0|  return postBody;
   54|      0|}
   55|       |
   56|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRResetPasswordResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRResetPasswordResponse.h"
   18|       |
   19|       |@implementation FIRResetPasswordResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                    error:(NSError *_Nullable *_Nullable)error {
   23|      0|  _email = [dictionary[@"email"] copy];
   24|      0|  _requestType = [dictionary[@"requestType"] copy];
   25|      0|  _verifiedEmail = [dictionary[@"newEmail"] copy];
   26|      0|  return YES;
   27|      0|}
   28|       |
   29|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSecureTokenRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSecureTokenRequest.h"
   18|       |#import "FIRAuthRequestConfiguration.h"
   19|       |
   20|       |/** @var kFIRSecureTokenServiceGetTokenURLFormat
   21|       |    @brief The format of the secure token service URLs. Requires string format substitution with
   22|       |        the client's API Key.
   23|       | */
   24|       |static NSString *const kFIRSecureTokenServiceGetTokenURLFormat = @"https://%@/v1/token?key=%@";
   25|       |
   26|       |/** @var kFIRSecureTokenServiceGrantTypeRefreshToken
   27|       |    @brief The string value of the @c FIRSecureTokenRequestGrantTypeRefreshToken request type.
   28|       | */
   29|       |static NSString *const kFIRSecureTokenServiceGrantTypeRefreshToken = @"refresh_token";
   30|       |
   31|       |/** @var kFIRSecureTokenServiceGrantTypeAuthorizationCode
   32|       |    @brief The string value of the @c FIRSecureTokenRequestGrantTypeAuthorizationCode request type.
   33|       | */
   34|       |static NSString *const kFIRSecureTokenServiceGrantTypeAuthorizationCode = @"authorization_code";
   35|       |
   36|       |/** @var kGrantTypeKey
   37|       |    @brief The key for the "grantType" parameter in the request.
   38|       | */
   39|       |static NSString *const kGrantTypeKey = @"grantType";
   40|       |
   41|       |/** @var kScopeKey
   42|       |    @brief The key for the "scope" parameter in the request.
   43|       | */
   44|       |static NSString *const kScopeKey = @"scope";
   45|       |
   46|       |/** @var kRefreshTokenKey
   47|       |    @brief The key for the "refreshToken" parameter in the request.
   48|       | */
   49|       |static NSString *const kRefreshTokenKey = @"refreshToken";
   50|       |
   51|       |/** @var kCodeKey
   52|       |    @brief The key for the "code" parameter in the request.
   53|       | */
   54|       |static NSString *const kCodeKey = @"code";
   55|       |
   56|       |/** @var gAPIHost
   57|       | @brief Host for server API calls.
   58|       | */
   59|       |static NSString *gAPIHost = @"securetoken.googleapis.com";
   60|       |
   61|       |@implementation FIRSecureTokenRequest {
   62|       |  /** @var _requestConfiguration
   63|       |      @brief Contains configuration relevant to the request.
   64|       |   */
   65|       |  FIRAuthRequestConfiguration *_requestConfiguration;
   66|       |}
   67|       |
   68|       |+ (FIRSecureTokenRequest *)authCodeRequestWithCode:(NSString *)code
   69|       |                                     requestConfiguration:(FIRAuthRequestConfiguration *)
   70|      0|                                         requestConfiguration {
   71|      0|  return [[self alloc] initWithGrantType:FIRSecureTokenRequestGrantTypeAuthorizationCode
   72|      0|                                   scope:nil
   73|      0|                            refreshToken:nil
   74|      0|                                    code:code
   75|      0|                    requestConfiguration:requestConfiguration];
   76|      0|}
   77|       |
   78|       |+ (FIRSecureTokenRequest *)refreshRequestWithRefreshToken:(NSString *)refreshToken
   79|       |                                     requestConfiguration:(FIRAuthRequestConfiguration *)
   80|      0|                                         requestConfiguration {
   81|      0|  return [[self alloc] initWithGrantType:FIRSecureTokenRequestGrantTypeRefreshToken
   82|      0|                                   scope:nil
   83|      0|                            refreshToken:refreshToken
   84|      0|                                    code:nil
   85|      0|                    requestConfiguration:requestConfiguration];
   86|      0|}
   87|       |
   88|       |/** @fn grantTypeStringWithGrantType:
   89|       |    @brief Converts a @c FIRSecureTokenRequestGrantType to it's @c NSString equivilent.
   90|       | */
   91|      0|+ (NSString *)grantTypeStringWithGrantType:(FIRSecureTokenRequestGrantType)grantType {
   92|      0|  switch (grantType) {
   93|      0|    case FIRSecureTokenRequestGrantTypeAuthorizationCode:
   94|      0|      return kFIRSecureTokenServiceGrantTypeAuthorizationCode;
   95|      0|    case FIRSecureTokenRequestGrantTypeRefreshToken:
   96|      0|      return kFIRSecureTokenServiceGrantTypeRefreshToken;
   97|      0|    // No Default case so we will notice if new grant types are added to the enum.
   98|      0|  }
   99|      0|}
  100|       |
  101|       |- (nullable instancetype)initWithGrantType:(FIRSecureTokenRequestGrantType)grantType
  102|       |                                     scope:(nullable NSString *)scope
  103|       |                              refreshToken:(nullable NSString *)refreshToken
  104|       |                                      code:(nullable NSString *)code
  105|      0|                      requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
  106|      0|  self = [super init];
  107|      0|  if (self) {
  108|      0|    _grantType = grantType;
  109|      0|    _scope = [scope copy];
  110|      0|    _refreshToken = [refreshToken copy];
  111|      0|    _code = [code copy];
  112|      0|    _APIKey = [requestConfiguration.APIKey copy];
  113|      0|    _requestConfiguration = requestConfiguration;
  114|      0|  }
  115|      0|  return self;
  116|      0|}
  117|       |
  118|      0|- (FIRAuthRequestConfiguration *)requestConfiguration {
  119|      0|  return _requestConfiguration;
  120|      0|}
  121|       |
  122|      0|- (NSURL *)requestURL {
  123|      0|  NSString *URLString =
  124|      0|      [NSString stringWithFormat:kFIRSecureTokenServiceGetTokenURLFormat, gAPIHost, _APIKey];
  125|      0|  NSURL *URL = [NSURL URLWithString:URLString];
  126|      0|  return URL;
  127|      0|}
  128|       |
  129|      0|- (BOOL)containsPostBody {
  130|      0|  return YES;
  131|      0|}
  132|       |
  133|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
  134|      0|  NSMutableDictionary *postBody = [@{
  135|      0|    kGrantTypeKey : [[self class] grantTypeStringWithGrantType:_grantType]
  136|      0|  } mutableCopy];
  137|      0|  if (_scope) {
  138|      0|    postBody[kScopeKey] = _scope;
  139|      0|  }
  140|      0|  if (_refreshToken) {
  141|      0|    postBody[kRefreshTokenKey] = _refreshToken;
  142|      0|  }
  143|      0|  if (_code) {
  144|      0|    postBody[kCodeKey] = _code;
  145|      0|  }
  146|      0|  return postBody;
  147|      0|}
  148|       |
  149|       |#pragma mark - Internal API for development
  150|       |
  151|      0|+ (NSString *)host {
  152|      0|  return gAPIHost;
  153|      0|}
  154|       |
  155|      0|+ (void)setHost:(NSString *)host {
  156|      0|  gAPIHost = host;
  157|      0|}
  158|       |
  159|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSecureTokenResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSecureTokenResponse.h"
   18|       |
   19|       |#import "FIRAuthErrorUtils.h"
   20|       |
   21|       |/** @var kExpiresInKey
   22|       |    @brief The key for the number of seconds till the access token expires.
   23|       | */
   24|       |static NSString *const kExpiresInKey = @"expires_in";
   25|       |
   26|       |/** @var kRefreshTokenKey
   27|       |    @brief The key for the refresh token.
   28|       | */
   29|       |static NSString *const kRefreshTokenKey = @"refresh_token";
   30|       |
   31|       |/** @var kAccessTokenKey
   32|       |    @brief The key for the access token.
   33|       | */
   34|       |static NSString *const kAccessTokenKey = @"access_token";
   35|       |
   36|       |/** @var kIDTokenKey
   37|       |    @brief The key for the "id_token" value in the response.
   38|       | */
   39|       |static NSString *const kIDTokenKey = @"id_token";
   40|       |
   41|       |@implementation FIRSecureTokenResponse
   42|       |
   43|      0|- (nullable NSString *)expectedKind {
   44|      0|  return nil;
   45|      0|}
   46|       |
   47|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   48|      0|                    error:(NSError *_Nullable *_Nullable)error {
   49|      0|  _refreshToken = dictionary[kRefreshTokenKey];
   50|      0|  _accessToken = dictionary[kAccessTokenKey];
   51|      0|  _IDToken = dictionary[kIDTokenKey];
   52|      0|  if (!_accessToken.length) {
   53|      0|    if (error) {
   54|      0|      *error = [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:dictionary];
   55|      0|    }
   56|      0|    return NO;
   57|      0|  }
   58|      0|  id expiresIn = dictionary[kExpiresInKey];
   59|      0|  if (![expiresIn isKindOfClass:[NSString class]]) {
   60|      0|    if (error) {
   61|      0|      *error = [FIRAuthErrorUtils unexpectedResponseWithDeserializedResponse:dictionary];
   62|      0|    }
   63|      0|    return NO;
   64|      0|  }
   65|      0|
   66|      0|  _approximateExpirationDate = [NSDate dateWithTimeIntervalSinceNow:[expiresIn doubleValue]];
   67|      0|  return YES;
   68|      0|}
   69|       |
   70|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSendVerificationCodeRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSendVerificationCodeRequest.h"
   18|       |
   19|       |#import "FIRAuthAppCredential.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/** @var kSendVerificationCodeEndPoint
   24|       |    @brief The "sendVerificationCodeEnd" endpoint.
   25|       | */
   26|       |static NSString *const kSendVerificationCodeEndPoint = @"sendVerificationCode";
   27|       |
   28|       |/** @var kPhoneNumberKey
   29|       |    @brief The key for the Phone Number parameter in the request.
   30|       | */
   31|       |static NSString *const kPhoneNumberKey = @"phoneNumber";
   32|       |
   33|       |/** @var kReceiptKey
   34|       |    @brief The key for the receipt parameter in the request.
   35|       | */
   36|       |static NSString *const kReceiptKey = @"iosReceipt";
   37|       |
   38|       |/** @var kSecretKey
   39|       |    @brief The key for the Secret parameter in the request.
   40|       | */
   41|       |static NSString *const kSecretKey = @"iosSecret";
   42|       |
   43|       |/** @var kreCAPTCHATokenKey
   44|       |    @brief The key for the reCAPTCHAToken parameter in the request.
   45|       | */
   46|       |static NSString *const kreCAPTCHATokenKey = @"recaptchaToken";
   47|       |
   48|       |@implementation FIRSendVerificationCodeRequest {
   49|       |}
   50|       |
   51|       |- (nullable instancetype)initWithPhoneNumber:(NSString *)phoneNumber
   52|       |                               appCredential:(nullable FIRAuthAppCredential *)appCredential
   53|       |                              reCAPTCHAToken:(nullable NSString *)reCAPTCHAToken
   54|      0|                        requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   55|      0|  self = [super initWithEndpoint:kSendVerificationCodeEndPoint
   56|      0|            requestConfiguration:requestConfiguration];
   57|      0|  if (self) {
   58|      0|    _phoneNumber = [phoneNumber copy];
   59|      0|    _appCredential = appCredential;
   60|      0|    _reCAPTCHAToken = [reCAPTCHAToken copy];
   61|      0|  }
   62|      0|  return self;
   63|      0|}
   64|       |
   65|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   66|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   67|      0|  if (_phoneNumber) {
   68|      0|    postBody[kPhoneNumberKey] = _phoneNumber;
   69|      0|  }
   70|      0|  if (_appCredential.receipt) {
   71|      0|    postBody[kReceiptKey] = _appCredential.receipt;
   72|      0|  }
   73|      0|  if (_appCredential.secret) {
   74|      0|    postBody[kSecretKey] = _appCredential.secret;
   75|      0|  }
   76|      0|  if (_reCAPTCHAToken) {
   77|      0|    postBody[kreCAPTCHATokenKey] = _reCAPTCHAToken;
   78|      0|  }
   79|      0|  return postBody;
   80|      0|}
   81|       |
   82|       |@end
   83|       |
   84|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSendVerificationCodeResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSendVerificationCodeResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRSendVerificationCodeResponse
   22|       |
   23|       |// TODO: remove when resolving b/37169084 .
   24|      0|- (nullable NSString *)expectedKind {
   25|      0|  return nil;
   26|      0|}
   27|       |
   28|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   29|      0|                    error:(NSError *_Nullable  *_Nullable)error {
   30|      0|  _verificationID = [dictionary[@"sessionInfo"] copy];
   31|      0|  return YES;
   32|      0|}
   33|       |
   34|       |@end
   35|       |
   36|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSetAccountInfoRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSetAccountInfoRequest.h"
   18|       |
   19|       |#import "FIRAuthErrorUtils.h"
   20|       |#import "FIRAuth_Internal.h"
   21|       |#import "FIRGetAccountInfoResponse.h"
   22|       |
   23|       |NSString *const FIRSetAccountInfoUserAttributeEmail = @"EMAIL";
   24|       |
   25|       |NSString *const FIRSetAccountInfoUserAttributeDisplayName = @"DISPLAY_NAME";
   26|       |
   27|       |NSString *const FIRSetAccountInfoUserAttributeProvider = @"PROVIDER";
   28|       |
   29|       |NSString *const FIRSetAccountInfoUserAttributePhotoURL = @"PHOTO_URL";
   30|       |
   31|       |NSString *const FIRSetAccountInfoUserAttributePassword = @"PASSWORD";
   32|       |
   33|       |/** @var kCreateAuthURIEndpoint
   34|       |    @brief The "setAccountInfo" endpoint.
   35|       | */
   36|       |static NSString *const kSetAccountInfoEndpoint = @"setAccountInfo";
   37|       |
   38|       |/** @var kIDTokenKey
   39|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   40|       |        despite it's confusing (backwards compatiable) parameter name.
   41|       | */
   42|       |static NSString *const kIDTokenKey = @"idToken";
   43|       |
   44|       |/** @var kDisplayNameKey
   45|       |    @brief The key for the "displayName" value in the request.
   46|       | */
   47|       |static NSString *const kDisplayNameKey = @"displayName";
   48|       |
   49|       |/** @var kLocalIDKey
   50|       |    @brief The key for the "localID" value in the request.
   51|       | */
   52|       |static NSString *const kLocalIDKey = @"localId";
   53|       |
   54|       |/** @var kEmailKey
   55|       |    @brief The key for the "email" value in the request.
   56|       | */
   57|       |static NSString *const kEmailKey = @"email";
   58|       |
   59|       |/** @var kPasswordKey
   60|       |    @brief The key for the "password" value in the request.
   61|       | */
   62|       |static NSString *const kPasswordKey = @"password";
   63|       |
   64|       |/** @var kPhotoURLKey
   65|       |    @brief The key for the "photoURL" value in the request.
   66|       | */
   67|       |static NSString *const kPhotoURLKey = @"photoUrl";
   68|       |
   69|       |/** @var kProvidersKey
   70|       |    @brief The key for the "providers" value in the request.
   71|       | */
   72|       |static NSString *const kProvidersKey = @"provider";
   73|       |
   74|       |/** @var kOOBCodeKey
   75|       |    @brief The key for the "OOBCode" value in the request.
   76|       | */
   77|       |static NSString *const kOOBCodeKey = @"oobCode";
   78|       |
   79|       |/** @var kEmailVerifiedKey
   80|       |    @brief The key for the "emailVerified" value in the request.
   81|       | */
   82|       |static NSString *const kEmailVerifiedKey = @"emailVerified";
   83|       |
   84|       |/** @var kUpgradeToFederatedLoginKey
   85|       |    @brief The key for the "upgradeToFederatedLogin" value in the request.
   86|       | */
   87|       |static NSString *const kUpgradeToFederatedLoginKey = @"upgradeToFederatedLogin";
   88|       |
   89|       |/** @var kCaptchaChallengeKey
   90|       |    @brief The key for the "captchaChallenge" value in the request.
   91|       | */
   92|       |static NSString *const kCaptchaChallengeKey = @"captchaChallenge";
   93|       |
   94|       |/** @var kCaptchaResponseKey
   95|       |    @brief The key for the "captchaResponse" value in the request.
   96|       | */
   97|       |static NSString *const kCaptchaResponseKey = @"captchaResponse";
   98|       |
   99|       |/** @var kDeleteAttributesKey
  100|       |    @brief The key for the "deleteAttribute" value in the request.
  101|       | */
  102|       |static NSString *const kDeleteAttributesKey = @"deleteAttribute";
  103|       |
  104|       |/** @var kDeleteProvidersKey
  105|       |    @brief The key for the "deleteProvider" value in the request.
  106|       | */
  107|       |static NSString *const kDeleteProvidersKey = @"deleteProvider";
  108|       |
  109|       |/** @var kReturnSecureTokenKey
  110|       |    @brief The key for the "returnSecureToken" value in the request.
  111|       | */
  112|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
  113|       |
  114|       |@implementation FIRSetAccountInfoRequest
  115|       |
  116|       |- (nullable instancetype)initWithRequestConfiguration:
  117|      0|    (FIRAuthRequestConfiguration *)requestConfiguration {
  118|      0|  self = [super initWithEndpoint:kSetAccountInfoEndpoint requestConfiguration:requestConfiguration];
  119|      0|  if (self) {
  120|      0|    _returnSecureToken = YES;
  121|      0|  }
  122|      0|  return self;
  123|      0|}
  124|       |
  125|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
  126|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
  127|      0|  if (_accessToken) {
  128|      0|    postBody[kIDTokenKey] = _accessToken;
  129|      0|  }
  130|      0|  if (_displayName) {
  131|      0|    postBody[kDisplayNameKey] = _displayName;
  132|      0|  }
  133|      0|  if (_localID) {
  134|      0|    postBody[kLocalIDKey] = _localID;
  135|      0|  }
  136|      0|  if (_email) {
  137|      0|    postBody[kEmailKey] = _email;
  138|      0|  }
  139|      0|  if (_password) {
  140|      0|    postBody[kPasswordKey] = _password;
  141|      0|  }
  142|      0|  if (_photoURL) {
  143|      0|    postBody[kPhotoURLKey] = _photoURL.absoluteString;
  144|      0|  }
  145|      0|  if (_providers) {
  146|      0|    postBody[kProvidersKey] = _providers;
  147|      0|  }
  148|      0|  if (_OOBCode) {
  149|      0|    postBody[kOOBCodeKey] = _OOBCode;
  150|      0|  }
  151|      0|  if (_emailVerified) {
  152|      0|    postBody[kEmailVerifiedKey] = @YES;
  153|      0|  }
  154|      0|  if (_upgradeToFederatedLogin) {
  155|      0|    postBody[kUpgradeToFederatedLoginKey] = @YES;
  156|      0|  }
  157|      0|  if (_captchaChallenge) {
  158|      0|    postBody[kCaptchaChallengeKey] = _captchaChallenge;
  159|      0|  }
  160|      0|  if (_captchaResponse) {
  161|      0|    postBody[kCaptchaResponseKey] = _captchaResponse;
  162|      0|  }
  163|      0|  if (_deleteAttributes) {
  164|      0|    postBody[kDeleteAttributesKey] = _deleteAttributes;
  165|      0|  }
  166|      0|  if (_deleteProviders) {
  167|      0|    postBody[kDeleteProvidersKey] = _deleteProviders;
  168|      0|  }
  169|      0|  if (_returnSecureToken) {
  170|      0|    postBody[kReturnSecureTokenKey] = @YES;
  171|      0|  }
  172|      0|  return postBody;
  173|      0|}
  174|       |
  175|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSetAccountInfoResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSetAccountInfoResponse.h"
   18|       |
   19|       |@implementation FIRSetAccountInfoResponseProviderUserInfo
   20|       |
   21|      0|- (instancetype)initWithDictionary:(NSDictionary *)dictionary {
   22|      0|  self = [super init];
   23|      0|  if (self) {
   24|      0|    _providerID = [dictionary[@"providerId"] copy];
   25|      0|    _displayName = [dictionary[@"displayName"] copy];
   26|      0|    NSString *photoURL = dictionary[@"photoUrl"];
   27|      0|    if (photoURL) {
   28|      0|      _photoURL = [NSURL URLWithString:photoURL];
   29|      0|    }
   30|      0|  }
   31|      0|  return self;
   32|      0|}
   33|       |
   34|       |@end
   35|       |
   36|       |@implementation FIRSetAccountInfoResponse
   37|       |
   38|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   39|      0|                    error:(NSError *_Nullable *_Nullable)error {
   40|      0|  _email = [dictionary[@"email"] copy];
   41|      0|  _displayName = [dictionary[@"displayName"] copy];
   42|      0|  _IDToken = [dictionary[@"idToken"] copy];
   43|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   44|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   45|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   46|      0|  NSArray<NSDictionary *> *providerUserInfoData = dictionary[@"providerUserInfo"];
   47|      0|  if (providerUserInfoData) {
   48|      0|    NSMutableArray<FIRSetAccountInfoResponseProviderUserInfo *> *providerUserInfoArray =
   49|      0|        [NSMutableArray arrayWithCapacity:providerUserInfoData.count];
   50|      0|    for (NSDictionary *dictionary in providerUserInfoData) {
   51|      0|      [providerUserInfoArray addObject:
   52|      0|          [[FIRSetAccountInfoResponseProviderUserInfo alloc] initWithDictionary:dictionary]];
   53|      0|    }
   54|      0|    _providerUserInfo = [providerUserInfoArray copy];
   55|      0|  }
   56|      0|  return YES;
   57|      0|}
   58|       |
   59|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSignInWithGameCenterRequest.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSignInWithGameCenterRequest.h"
   18|       |
   19|       |#import "NSData+FIRBase64.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/** @var kSignInWithGameCenterEndPoint
   24|       |    @brief The "SignInWithGameCenter" endpoint.
   25|       | */
   26|       |static NSString *const kSignInWithGameCenterEndPoint = @"signInWithGameCenter";
   27|       |
   28|       |@implementation FIRSignInWithGameCenterRequest
   29|       |
   30|       |- (nullable instancetype)initWithPlayerID:(NSString *)playerID
   31|       |                             publicKeyURL:(NSURL *)publicKeyURL
   32|       |                                signature:(NSData *)signature
   33|       |                                     salt:(NSData *)salt
   34|       |                                timestamp:(uint64_t)timestamp
   35|       |                              displayName:(NSString *)displayName
   36|      0|                     requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   37|      0|  self = [super initWithEndpoint:kSignInWithGameCenterEndPoint
   38|      0|            requestConfiguration:requestConfiguration];
   39|      0|  if (self) {
   40|      0|    _playerID = playerID;
   41|      0|    _publicKeyURL = [publicKeyURL copy];
   42|      0|    _signature = [signature copy];
   43|      0|    _salt = [salt copy];
   44|      0|    _timestamp = timestamp;
   45|      0|    _displayName = displayName;
   46|      0|  }
   47|      0|  return self;
   48|      0|}
   49|       |
   50|       |#pragma mark - FIRAuthRPCRequest
   51|       |
   52|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *__autoreleasing  _Nullable *)error {
   53|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   54|      0|  if (_playerID) {
   55|      0|    postBody[@"playerId"] = _playerID;
   56|      0|  }
   57|      0|  if (_publicKeyURL) {
   58|      0|    postBody[@"publicKeyUrl"] = _publicKeyURL.absoluteString;
   59|      0|  }
   60|      0|  if (_signature) {
   61|      0|    postBody[@"signature"] = [_signature fir_base64URLEncodedStringWithOptions:0];
   62|      0|  }
   63|      0|  if (_salt) {
   64|      0|    postBody[@"salt"] = [_salt fir_base64URLEncodedStringWithOptions:0];
   65|      0|  }
   66|      0|  if (_timestamp != 0) {
   67|      0|    postBody[@"timestamp"] = [NSNumber numberWithUnsignedLongLong:_timestamp];
   68|      0|  }
   69|      0|  if (_accessToken) {
   70|      0|    postBody[@"idToken"] = _accessToken;
   71|      0|  }
   72|      0|  if (_displayName) {
   73|      0|    postBody[@"displayName"] = _displayName;
   74|      0|  }
   75|      0|  return postBody;
   76|      0|}
   77|       |
   78|       |@end
   79|       |
   80|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSignInWithGameCenterResponse.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSignInWithGameCenterResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRSignInWithGameCenterResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _IDToken = [dictionary[@"idToken"] copy];
   26|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   27|      0|  _localID = [dictionary[@"localId"] copy];
   28|      0|  _approximateExpirationDate = nil;
   29|      0|  if ([dictionary[@"expiresIn"] isKindOfClass:[NSString class]]) {
   30|      0|    _approximateExpirationDate = [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] integerValue]];
   31|      0|  }
   32|      0|  _playerID = [dictionary[@"playerId"] copy];
   33|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   34|      0|  _displayName = [dictionary[@"displayName"] copy];
   35|      0|  return YES;
   36|      0|}
   37|       |
   38|       |@end
   39|       |
   40|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSignUpNewUserRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSignUpNewUserRequest.h"
   18|       |
   19|       |/** @var kSignupNewUserEndpoint
   20|       |    @brief The "SingupNewUserEndpoint" endpoint.
   21|       | */
   22|       |static NSString *const kSignupNewUserEndpoint = @"signupNewUser";
   23|       |
   24|       |/** @var kEmailKey
   25|       |    @brief The key for the "email" value in the request.
   26|       | */
   27|       |static NSString *const kEmailKey = @"email";
   28|       |
   29|       |/** @var kPasswordKey
   30|       |    @brief The key for the "password" value in the request.
   31|       | */
   32|       |static NSString *const kPasswordKey = @"password";
   33|       |
   34|       |/** @var kDisplayNameKey
   35|       |    @brief The key for the "kDisplayName" value in the request.
   36|       | */
   37|       |static NSString *const kDisplayNameKey = @"displayName";
   38|       |
   39|       |/** @var kReturnSecureTokenKey
   40|       |    @brief The key for the "returnSecureToken" value in the request.
   41|       | */
   42|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
   43|       |
   44|       |@implementation FIRSignUpNewUserRequest
   45|       |
   46|       |- (nullable instancetype)initWithEmail:(nullable NSString *)email
   47|       |                              password:(nullable NSString *)password
   48|       |                           displayName:(nullable NSString *)displayName
   49|      0|                  requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   50|      0|  self = [super initWithEndpoint:kSignupNewUserEndpoint requestConfiguration:requestConfiguration];
   51|      0|  if (self) {
   52|      0|    _email = [email copy];
   53|      0|    _password = [password copy];
   54|      0|    _displayName = [displayName copy];
   55|      0|    _returnSecureToken = YES;
   56|      0|  }
   57|      0|  return self;
   58|      0|}
   59|       |
   60|       |- (nullable instancetype)initWithRequestConfiguration:
   61|      0|    (FIRAuthRequestConfiguration *)requestConfiguration {
   62|      0|    self = [self initWithEmail:nil
   63|      0|                      password:nil
   64|      0|                   displayName:nil
   65|      0|          requestConfiguration:requestConfiguration];
   66|      0|    return self;
   67|      0|}
   68|       |
   69|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   70|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   71|      0|  if (_email) {
   72|      0|    postBody[kEmailKey] = _email;
   73|      0|  }
   74|      0|  if (_password) {
   75|      0|    postBody[kPasswordKey] = _password;
   76|      0|  }
   77|      0|  if (_displayName) {
   78|      0|    postBody[kDisplayNameKey] = _displayName;
   79|      0|  }
   80|      0|  if (_returnSecureToken) {
   81|      0|    postBody[kReturnSecureTokenKey] = @YES;
   82|      0|  }
   83|      0|  return postBody;
   84|      0|}
   85|       |
   86|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRSignUpNewUserResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRSignUpNewUserResponse.h"
   18|       |
   19|       |@implementation FIRSignUpNewUserResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                    error:(NSError *_Nullable *_Nullable)error {
   23|      0|  _IDToken = [dictionary[@"idToken"] copy];
   24|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   25|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   26|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   27|      0|  return YES;
   28|      0|}
   29|       |
   30|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyAssertionRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyAssertionRequest.h"
   18|       |
   19|       |/** @var kVerifyAssertionEndpoint
   20|       |    @brief The "verifyAssertion" endpoint.
   21|       | */
   22|       |static NSString *const kVerifyAssertionEndpoint = @"verifyAssertion";
   23|       |
   24|       |/** @var kProviderIDKey
   25|       |    @brief The key for the "providerId" value in the request.
   26|       | */
   27|       |static NSString *const kProviderIDKey = @"providerId";
   28|       |
   29|       |/** @var kProviderIDTokenKey
   30|       |    @brief The key for the "id_token" value in the request.
   31|       | */
   32|       |static NSString *const kProviderIDTokenKey = @"id_token";
   33|       |
   34|       |/** @var kProviderAccessTokenKey
   35|       |    @brief The key for the "access_token" value in the request.
   36|       | */
   37|       |static NSString *const kProviderAccessTokenKey = @"access_token";
   38|       |
   39|       |/** @var kProviderOAuthTokenSecretKey
   40|       |    @brief The key for the "oauth_token_secret" value in the request.
   41|       | */
   42|       |static NSString *const kProviderOAuthTokenSecretKey = @"oauth_token_secret";
   43|       |
   44|       |/** @var kIdentifierKey
   45|       |    @brief The key for the "identifier" value in the request.
   46|       | */
   47|       |static NSString *const kIdentifierKey = @"identifier";
   48|       |
   49|       |/** @var kRequestURIKey
   50|       |    @brief The key for the "requestUri" value in the request.
   51|       | */
   52|       |static NSString *const kRequestURIKey = @"requestUri";
   53|       |
   54|       |/** @var kPostBodyKey
   55|       |    @brief The key for the "postBody" value in the request.
   56|       | */
   57|       |static NSString *const kPostBodyKey = @"postBody";
   58|       |
   59|       |/** @var kPendingIDTokenKey
   60|       |    @brief The key for the "pendingIdToken" value in the request.
   61|       | */
   62|       |static NSString *const kPendingIDTokenKey = @"pendingIdToken";
   63|       |
   64|       |/** @var kAutoCreateKey
   65|       |    @brief The key for the "autoCreate" value in the request.
   66|       | */
   67|       |static NSString *const kAutoCreateKey = @"autoCreate";
   68|       |
   69|       |/** @var kIDTokenKey
   70|       |    @brief The key for the "idToken" value in the request. This is actually the STS Access Token,
   71|       |        despite it's confusing (backwards compatiable) parameter name.
   72|       | */
   73|       |static NSString *const kIDTokenKey = @"idToken";
   74|       |
   75|       |/** @var kReturnSecureTokenKey
   76|       |    @brief The key for the "returnSecureToken" value in the request.
   77|       | */
   78|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
   79|       |
   80|       |@implementation FIRVerifyAssertionRequest
   81|       |
   82|       |- (nullable instancetype)initWithProviderID:(NSString *)providerID
   83|      0|                       requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   84|      0|  self = [super initWithEndpoint:kVerifyAssertionEndpoint
   85|      0|            requestConfiguration:requestConfiguration];
   86|      0|  if (self) {
   87|      0|    _providerID = providerID;
   88|      0|    _returnSecureToken = YES;
   89|      0|    _autoCreate = YES;
   90|      0|  }
   91|      0|  return self;
   92|      0|}
   93|       |
   94|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   95|      0|  NSURLComponents *components = [[NSURLComponents alloc] init];
   96|      0|  NSMutableArray<NSURLQueryItem *> *queryItems = [@[[NSURLQueryItem queryItemWithName:kProviderIDKey
   97|      0|                                                                                value:_providerID]]
   98|      0|                                                  mutableCopy];
   99|      0|
  100|      0|  if (_providerIDToken) {
  101|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kProviderIDTokenKey
  102|      0|                                                      value:_providerIDToken]];
  103|      0|  }
  104|      0|
  105|      0|  if (_providerAccessToken) {
  106|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kProviderAccessTokenKey
  107|      0|                                                      value:_providerAccessToken]];
  108|      0|  }
  109|      0|
  110|      0|  if (!_providerIDToken && !_providerAccessToken) {
  111|      0|    [NSException raise:NSInvalidArgumentException
  112|      0|                format:@"Either IDToken or accessToken must be supplied."];
  113|      0|  }
  114|      0|
  115|      0|  if (_providerOAuthTokenSecret) {
  116|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kProviderOAuthTokenSecretKey
  117|      0|                                                      value:_providerOAuthTokenSecret]];
  118|      0|  }
  119|      0|
  120|      0|  if (_inputEmail) {
  121|      0|    [queryItems addObject:[NSURLQueryItem queryItemWithName:kIdentifierKey
  122|      0|                                                      value:_inputEmail]];
  123|      0|  }
  124|      0|  [components setQueryItems:queryItems];
  125|      0|  NSMutableDictionary *body = [@{
  126|      0|      kRequestURIKey : @"http://localhost", // Unused by server, but required
  127|      0|      kPostBodyKey : [components query]
  128|      0|      } mutableCopy];
  129|      0|
  130|      0|  if (_pendingIDToken) {
  131|      0|    body[kPendingIDTokenKey] = _pendingIDToken;
  132|      0|  }
  133|      0|  if (_accessToken) {
  134|      0|    body[kIDTokenKey] = _accessToken;
  135|      0|  }
  136|      0|  if (_returnSecureToken) {
  137|      0|    body[kReturnSecureTokenKey] = @YES;
  138|      0|  }
  139|      0|
  140|      0|  body[kAutoCreateKey] = @(_autoCreate);
  141|      0|
  142|      0|  return body;
  143|      0|}
  144|       |
  145|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyAssertionResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyAssertionResponse.h"
   18|       |
   19|       |@implementation FIRVerifyAssertionResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                    error:(NSError *_Nullable *_Nullable)error {
   23|      0|  _federatedID = [dictionary[@"federatedId"] copy];
   24|      0|  _providerID = [dictionary[@"providerId"] copy];
   25|      0|  _localID = [dictionary[@"localId"] copy];
   26|      0|  _emailRecycled = [dictionary[@"emailRecycled"] boolValue];
   27|      0|  _emailVerified = [dictionary[@"emailVerified"] boolValue];
   28|      0|  _email = [dictionary[@"email"] copy];
   29|      0|  _inputEmail = [dictionary[@"inputEmail"] copy];
   30|      0|  _originalEmail = [dictionary[@"originalEmail"] copy];
   31|      0|  _oauthRequestToken = [dictionary[@"oauthRequestToken"] copy];
   32|      0|  _oauthScope = [dictionary[@"oauthScope"] copy];
   33|      0|  _firstName = [dictionary[@"firstName"] copy];
   34|      0|  _lastName = [dictionary[@"lastName"] copy];
   35|      0|  _fullName = [dictionary[@"fullName"] copy];
   36|      0|  _nickName = [dictionary[@"nickName"] copy];
   37|      0|  _displayName = [dictionary[@"displayName"] copy];
   38|      0|  _IDToken = [dictionary[@"idToken"] copy];
   39|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   40|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   41|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   42|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   43|      0|  id rawUserInfo = dictionary[@"rawUserInfo"];
   44|      0|  if ([rawUserInfo isKindOfClass:[NSString class]]) {
   45|      0|    NSData *data = [rawUserInfo dataUsingEncoding:NSUTF8StringEncoding];
   46|      0|    rawUserInfo = [NSJSONSerialization JSONObjectWithData:data
   47|      0|                                                  options:NSJSONReadingMutableLeaves
   48|      0|                                                    error:nil];
   49|      0|  }
   50|      0|  if ([rawUserInfo isKindOfClass:[NSDictionary class]]) {
   51|      0|    _profile = [[NSDictionary alloc] initWithDictionary:rawUserInfo
   52|      0|                                              copyItems:YES];
   53|      0|  }
   54|      0|  _username = [dictionary[@"username"] copy];
   55|      0|  _action = [dictionary[@"action"] copy];
   56|      0|  _language = [dictionary[@"language"] copy];
   57|      0|  _timeZone = [dictionary[@"timeZone"] copy];
   58|      0|  _photoURL = dictionary[@"photoUrl"] ? [NSURL URLWithString:dictionary[@"photoUrl"]] : nil;
   59|      0|  _dateOfBirth = [dictionary[@"dateOfBirth"] copy];
   60|      0|  _context = [dictionary[@"context"] copy];
   61|      0|  _needConfirmation = [dictionary[@"needConfirmation"] boolValue];
   62|      0|  id verifiedProvider = dictionary[@"verifiedProvider"];
   63|      0|  if ([verifiedProvider isKindOfClass:[NSString class]]) {
   64|      0|    NSData *data = [verifiedProvider dataUsingEncoding:NSUTF8StringEncoding];
   65|      0|    verifiedProvider = [NSJSONSerialization JSONObjectWithData:data
   66|      0|                                                       options:NSJSONReadingMutableLeaves
   67|      0|                                                         error:nil];
   68|      0|  }
   69|      0|  if ([verifiedProvider isKindOfClass:[NSArray class]]) {
   70|      0|    _verifiedProvider = [[NSArray alloc] initWithArray:verifiedProvider
   71|      0|                                             copyItems:YES];
   72|      0|  }
   73|      0|  return YES;
   74|      0|}
   75|       |
   76|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyClientRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyClientRequest.h"
   18|       |
   19|       |
   20|       |NS_ASSUME_NONNULL_BEGIN
   21|       |
   22|       |/** @var kVerifyClientEndpoint
   23|       |    @brief The endpoint for the verifyClient request.
   24|       | */
   25|       |static NSString *const kVerifyClientEndpoint = @"verifyClient";
   26|       |
   27|       |/** @var kAppTokenKey
   28|       |    @brief The key for the appToken request paramenter.
   29|       | */
   30|       |static NSString *const kAPPTokenKey = @"appToken";
   31|       |
   32|       |/** @var kIsSandboxKey
   33|       |    @brief The key for the isSandbox request parameter
   34|       | */
   35|       |static NSString *const kIsSandboxKey = @"isSandbox";
   36|       |
   37|       |@implementation FIRVerifyClientRequest
   38|       |
   39|       |- (nullable instancetype)initWithAppToken:(nullable NSString *)appToken
   40|       |                                isSandbox:(BOOL)isSandbox
   41|      0|                     requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   42|      0|  self = [super initWithEndpoint:kVerifyClientEndpoint requestConfiguration:requestConfiguration];
   43|      0|  if (self) {
   44|      0|    _appToken = appToken;
   45|      0|    _isSandbox = isSandbox;
   46|      0|  }
   47|      0|  return self;
   48|      0|}
   49|       |
   50|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *__autoreleasing _Nullable *)error {
   51|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   52|      0|  if (_appToken) {
   53|      0|    postBody[kAPPTokenKey] = _appToken;
   54|      0|  }
   55|      0|  if (_isSandbox) {
   56|      0|    postBody[kIsSandboxKey] = @YES;
   57|      0|  }
   58|      0|  return postBody;
   59|      0|}
   60|       |
   61|       |@end
   62|       |
   63|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyClientResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyClientResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRVerifyClientResponse
   22|       |
   23|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   24|      0|                    error:(NSError *_Nullable *_Nullable)error {
   25|      0|  _receipt = dictionary[@"receipt"];
   26|      0|  _suggestedTimeOutDate = [dictionary[@"suggestedTimeout"] isKindOfClass:[NSString class]] ?
   27|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"suggestedTimeout"] doubleValue]] : nil;
   28|      0|  return YES;
   29|      0|}
   30|       |
   31|       |@end
   32|       |
   33|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyCustomTokenRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyCustomTokenRequest.h"
   18|       |
   19|       |/** @var kVerifyCustomTokenEndpoint
   20|       |    @brief The "verifyPassword" endpoint.
   21|       | */
   22|       |static NSString *const kVerifyCustomTokenEndpoint = @"verifyCustomToken";
   23|       |
   24|       |/** @var kTokenKey
   25|       |    @brief The key for the "token" value in the request.
   26|       | */
   27|       |static NSString *const kTokenKey = @"token";
   28|       |
   29|       |/** @var kReturnSecureTokenKey
   30|       |    @brief The key for the "returnSecureToken" value in the request.
   31|       | */
   32|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
   33|       |
   34|       |@implementation FIRVerifyCustomTokenRequest
   35|       |
   36|       |- (nullable instancetype)initWithToken:(NSString *)token
   37|      0|                  requestConfiguration:(FIRAuthRequestConfiguration *)requestConfiguration {
   38|      0|  self = [super initWithEndpoint:kVerifyCustomTokenEndpoint
   39|      0|            requestConfiguration:requestConfiguration];
   40|      0|  if (self) {
   41|      0|    _token = [token copy];
   42|      0|    _returnSecureToken = YES;
   43|      0|  }
   44|      0|  return self;
   45|      0|}
   46|       |
   47|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   48|      0|  NSMutableDictionary *body = [@{
   49|      0|    kTokenKey : _token
   50|      0|  } mutableCopy];
   51|      0|  if (_returnSecureToken) {
   52|      0|    body[kReturnSecureTokenKey] = @YES;
   53|      0|  }
   54|      0|  return body;
   55|      0|}
   56|       |
   57|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyCustomTokenResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyCustomTokenResponse.h"
   18|       |
   19|       |@implementation FIRVerifyCustomTokenResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                    error:(NSError *_Nullable *_Nullable)error {
   23|      0|  _IDToken = [dictionary[@"idToken"] copy];
   24|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   25|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   26|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   27|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   28|      0|  return YES;
   29|      0|}
   30|       |
   31|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyPasswordRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyPasswordRequest.h"
   18|       |
   19|       |/** @var kVerifyPasswordEndpoint
   20|       |    @brief The "verifyPassword" endpoint.
   21|       | */
   22|       |static NSString *const kVerifyPasswordEndpoint = @"verifyPassword";
   23|       |
   24|       |/** @var kEmailKey
   25|       |    @brief The key for the "email" value in the request.
   26|       | */
   27|       |static NSString *const kEmailKey = @"email";
   28|       |
   29|       |/** @var kPasswordKey
   30|       |    @brief The key for the "password" value in the request.
   31|       | */
   32|       |static NSString *const kPasswordKey = @"password";
   33|       |
   34|       |/** @var kPendingIDTokenKey
   35|       |    @brief The key for the "pendingIdToken" value in the request.
   36|       | */
   37|       |static NSString *const kPendingIDTokenKey = @"pendingIdToken";
   38|       |
   39|       |/** @var kCaptchaChallengeKey
   40|       |    @brief The key for the "captchaChallenge" value in the request.
   41|       | */
   42|       |static NSString *const kCaptchaChallengeKey = @"captchaChallenge";
   43|       |
   44|       |/** @var kCaptchaResponseKey
   45|       |    @brief The key for the "captchaResponse" value in the request.
   46|       | */
   47|       |static NSString *const kCaptchaResponseKey = @"captchaResponse";
   48|       |
   49|       |/** @var kReturnSecureTokenKey
   50|       |    @brief The key for the "returnSecureToken" value in the request.
   51|       | */
   52|       |static NSString *const kReturnSecureTokenKey = @"returnSecureToken";
   53|       |
   54|       |@implementation FIRVerifyPasswordRequest
   55|       |
   56|       |- (nullable instancetype)initWithEmail:(NSString *)email
   57|       |                              password:(NSString *)password
   58|      0|                  requestConfiguration:(nonnull FIRAuthRequestConfiguration *)requestConfiguration {
   59|      0|  self = [super initWithEndpoint:kVerifyPasswordEndpoint
   60|      0|            requestConfiguration:requestConfiguration];
   61|      0|  if (self) {
   62|      0|    _email = [email copy];
   63|      0|    _password = [password copy];
   64|      0|    _returnSecureToken = YES;
   65|      0|  }
   66|      0|  return self;
   67|      0|}
   68|       |
   69|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *_Nullable *_Nullable)error {
   70|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
   71|      0|  if (_email) {
   72|      0|    postBody[kEmailKey] = _email;
   73|      0|  }
   74|      0|  if (_password) {
   75|      0|    postBody[kPasswordKey] = _password;
   76|      0|  }
   77|      0|  if (_pendingIDToken) {
   78|      0|    postBody[kPendingIDTokenKey] = _pendingIDToken;
   79|      0|  }
   80|      0|  if (_captchaChallenge) {
   81|      0|    postBody[kCaptchaChallengeKey] = _captchaChallenge;
   82|      0|  }
   83|      0|  if (_captchaResponse) {
   84|      0|    postBody[kCaptchaResponseKey] = _captchaResponse;
   85|      0|  }
   86|      0|  if (_returnSecureToken) {
   87|      0|    postBody[kReturnSecureTokenKey] = @YES;
   88|      0|  }
   89|      0|  return postBody;
   90|      0|}
   91|       |
   92|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyPasswordResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyPasswordResponse.h"
   18|       |
   19|       |@implementation FIRVerifyPasswordResponse
   20|       |
   21|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   22|      0|                    error:(NSError *_Nullable *_Nullable)error {
   23|      0|  _localID = [dictionary[@"localId"] copy];
   24|      0|  _email = [dictionary[@"email"] copy];
   25|      0|  _displayName = [dictionary[@"displayName"] copy];
   26|      0|  _IDToken = [dictionary[@"idToken"] copy];
   27|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   28|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   29|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   30|      0|  _photoURL = dictionary[@"photoUrl"] ? [NSURL URLWithString:dictionary[@"photoUrl"]] : nil;
   31|      0|  return YES;
   32|      0|}
   33|       |
   34|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyPhoneNumberRequest.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyPhoneNumberRequest.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |/** @var kVerifyPhoneNumberEndPoint
   22|       |    @brief The "verifyPhoneNumber" endpoint.
   23|       | */
   24|       |static NSString *const kVerifyPhoneNumberEndPoint = @"verifyPhoneNumber";
   25|       |
   26|       |/** @var kVerificationIDKey
   27|       |    @brief The key for the verification ID parameter in the request.
   28|       | */
   29|       |static NSString *const kVerificationIDKey = @"sessionInfo";
   30|       |
   31|       |/** @var kVerificationCodeKey
   32|       |    @brief The key for the verification code parameter in the request.
   33|       | */
   34|       |static NSString *const kVerificationCodeKey = @"code";
   35|       |
   36|       |/** @var kIDTokenKey
   37|       |    @brief The key for the "ID Token" value in the request.
   38|       | */
   39|       |static NSString *const kIDTokenKey = @"idToken";
   40|       |
   41|       |/** @var kTemporaryProofKey
   42|       |    @brief The key for the temporary proof value in the request.
   43|       | */
   44|       |static NSString *const kTemporaryProofKey = @"temporaryProof";
   45|       |
   46|       |/** @var kPhoneNumberKey
   47|       |    @brief The key for the phone number value in the request.
   48|       | */
   49|       |static NSString *const kPhoneNumberKey = @"phoneNumber";
   50|       |
   51|       |/** @var kOperationKey
   52|       |    @brief The key for the operation value in the request.
   53|       | */
   54|       |static NSString *const kOperationKey = @"operation";
   55|       |
   56|       |@implementation FIRVerifyPhoneNumberRequest
   57|       |
   58|       |- (nullable instancetype)initWithTemporaryProof:(NSString *)temporaryProof
   59|       |                                    phoneNumber:(NSString *)phoneNumber
   60|       |                                      operation:(FIRAuthOperationType)operation
   61|       |                           requestConfiguration:
   62|      0|                              (FIRAuthRequestConfiguration *)requestConfiguration {
   63|      0|  self = [super initWithEndpoint:kVerifyPhoneNumberEndPoint
   64|      0|            requestConfiguration:requestConfiguration];
   65|      0|  if (self) {
   66|      0|    _temporaryProof = [temporaryProof copy];
   67|      0|    _phoneNumber = [phoneNumber copy];
   68|      0|    _operation = operation;
   69|      0|  }
   70|      0|  return self;
   71|      0|}
   72|       |
   73|       |- (nullable instancetype)initWithVerificationID:(NSString *)verificationID
   74|       |                               verificationCode:(NSString *)verificationCode
   75|       |                                      operation:(FIRAuthOperationType)operation
   76|       |                           requestConfiguration:
   77|      0|                              (FIRAuthRequestConfiguration *)requestConfiguration {
   78|      0|  self = [super initWithEndpoint:kVerifyPhoneNumberEndPoint
   79|      0|            requestConfiguration:requestConfiguration];
   80|      0|  if (self) {
   81|      0|    _verificationID = verificationID;
   82|      0|    _verificationCode = verificationCode;
   83|      0|    _operation = operation;
   84|      0|  }
   85|      0|  return self;
   86|      0|}
   87|       |
   88|       |/** @fn FIRAuthOperationString
   89|       |    @brief Returns a string object corresponding to the provided FIRAuthOperationType value.
   90|       |    @param operationType The value of the FIRAuthOperationType enum which will be translated to its
   91|       |        corresponding string value.
   92|       |    @return The string value corresponding to the FIRAuthOperationType argument.
   93|       | */
   94|      0|NSString *const FIRAuthOperationString(FIRAuthOperationType operationType) {
   95|      0|  switch(operationType){
   96|      0|    case FIRAuthOperationTypeUnspecified:
   97|      0|      return @"VERIFY_OP_UNSPECIFIED";
   98|      0|    case FIRAuthOperationTypeSignUpOrSignIn:
   99|      0|      return @"SIGN_UP_OR_IN";
  100|      0|    case FIRAuthOperationTypeReauth:
  101|      0|      return @"REAUTH";
  102|      0|    case FIRAuthOperationTypeLink:
  103|      0|      return @"LINK";
  104|      0|    case FIRAuthOperationTypeUpdate:
  105|      0|      return @"UPDATE";
  106|      0|  }
  107|      0|}
  108|       |
  109|      0|- (nullable id)unencodedHTTPRequestBodyWithError:(NSError *__autoreleasing  _Nullable *)error {
  110|      0|  NSMutableDictionary *postBody = [NSMutableDictionary dictionary];
  111|      0|  if (_verificationID) {
  112|      0|    postBody[kVerificationIDKey] = _verificationID;
  113|      0|  }
  114|      0|  if (_verificationCode) {
  115|      0|    postBody[kVerificationCodeKey] = _verificationCode;
  116|      0|  }
  117|      0|  if (_accessToken) {
  118|      0|    postBody[kIDTokenKey] = _accessToken;
  119|      0|  }
  120|      0|  if (_temporaryProof) {
  121|      0|    postBody[kTemporaryProofKey] = _temporaryProof;
  122|      0|  }
  123|      0|  if (_phoneNumber) {
  124|      0|    postBody[kPhoneNumberKey] = _phoneNumber;
  125|      0|  }
  126|      0|  NSString *operation = FIRAuthOperationString(_operation);
  127|      0|  postBody[kOperationKey] = operation;
  128|      0|  return postBody;
  129|      0|}
  130|       |
  131|       |@end
  132|       |
  133|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseAuth/Firebase/Auth/Source/RPCs/FIRVerifyPhoneNumberResponse.m:
    1|       |/*
    2|       | * Copyright 2017 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "FIRVerifyPhoneNumberResponse.h"
   18|       |
   19|       |NS_ASSUME_NONNULL_BEGIN
   20|       |
   21|       |@implementation FIRVerifyPhoneNumberResponse
   22|       |
   23|      0|- (nullable NSString *)expectedKind {
   24|      0|  return nil;
   25|      0|}
   26|       |
   27|       |- (BOOL)setWithDictionary:(NSDictionary *)dictionary
   28|      0|                    error:(NSError *_Nullable *_Nullable)error {
   29|      0|  _IDToken = [dictionary[@"idToken"] copy];
   30|      0|  _refreshToken = [dictionary[@"refreshToken"] copy];
   31|      0|  _isNewUser = [dictionary[@"isNewUser"] boolValue];
   32|      0|  _localID = [dictionary[@"localId"] copy];
   33|      0|  _phoneNumber = [dictionary[@"phoneNumber"] copy];
   34|      0|  _temporaryProof = [dictionary[@"temporaryProof"] copy];
   35|      0|  _approximateExpirationDate = [dictionary[@"expiresIn"] isKindOfClass:[NSString class]] ?
   36|      0|      [NSDate dateWithTimeIntervalSinceNow:[dictionary[@"expiresIn"] doubleValue]] : nil;
   37|      0|  return YES;
   38|      0|}
   39|       |
   40|       |@end
   41|       |
   42|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRAnalyticsConfiguration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FIRAnalyticsConfiguration.h"
   16|       |
   17|       |#import "Private/FIRAnalyticsConfiguration+Internal.h"
   18|       |
   19|       |@implementation FIRAnalyticsConfiguration
   20|       |
   21|      1|+ (FIRAnalyticsConfiguration *)sharedInstance {
   22|      1|  static FIRAnalyticsConfiguration *sharedInstance = nil;
   23|      1|  static dispatch_once_t onceToken;
   24|      1|  dispatch_once(&onceToken, ^{
   25|      1|    sharedInstance = [[FIRAnalyticsConfiguration alloc] init];
   26|      1|  });
   27|      1|  return sharedInstance;
   28|      1|}
   29|       |
   30|      0|- (void)postNotificationName:(NSString *)name value:(id)value {
   31|      0|  if (!name.length || !value) {
   32|      0|    return;
   33|      0|  }
   34|      0|  [[NSNotificationCenter defaultCenter] postNotificationName:name
   35|      0|                                                      object:self
   36|      0|                                                    userInfo:@{name : value}];
   37|      0|}
   38|       |
   39|      0|- (void)setMinimumSessionInterval:(NSTimeInterval)minimumSessionInterval {
   40|      0|  [self postNotificationName:kFIRAnalyticsConfigurationSetMinimumSessionIntervalNotification
   41|      0|                       value:@(minimumSessionInterval)];
   42|      0|}
   43|       |
   44|      0|- (void)setSessionTimeoutInterval:(NSTimeInterval)sessionTimeoutInterval {
   45|      0|  [self postNotificationName:kFIRAnalyticsConfigurationSetSessionTimeoutIntervalNotification
   46|      0|                       value:@(sessionTimeoutInterval)];
   47|      0|}
   48|       |
   49|      0|- (void)setAnalyticsCollectionEnabled:(BOOL)analyticsCollectionEnabled {
   50|      0|  [self setAnalyticsCollectionEnabled:analyticsCollectionEnabled persistSetting:YES];
   51|      0|}
   52|       |
   53|       |- (void)setAnalyticsCollectionEnabled:(BOOL)analyticsCollectionEnabled
   54|      0|                       persistSetting:(BOOL)shouldPersist {
   55|      0|  // Persist the measurementEnabledState. Use FIRAnalyticsEnabledState values instead of YES/NO.
   56|      0|  FIRAnalyticsEnabledState analyticsEnabledState =
   57|      0|      analyticsCollectionEnabled ? kFIRAnalyticsEnabledStateSetYes : kFIRAnalyticsEnabledStateSetNo;
   58|      0|  if (shouldPersist) {
   59|      0|    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
   60|      0|    [userDefaults setObject:@(analyticsEnabledState)
   61|      0|                     forKey:kFIRAPersistedConfigMeasurementEnabledStateKey];
   62|      0|    [userDefaults synchronize];
   63|      0|  }
   64|      0|
   65|      0|  [self postNotificationName:kFIRAnalyticsConfigurationSetEnabledNotification
   66|      0|                       value:@(analyticsCollectionEnabled)];
   67|      0|}
   68|       |
   69|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRApp.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#include <sys/utsname.h>
   16|       |
   17|       |#import "FIRApp.h"
   18|       |#import "FIRConfiguration.h"
   19|       |#import "Private/FIRAnalyticsConfiguration+Internal.h"
   20|       |#import "Private/FIRAppInternal.h"
   21|       |#import "Private/FIRBundleUtil.h"
   22|       |#import "Private/FIRComponentContainerInternal.h"
   23|       |#import "Private/FIRLibrary.h"
   24|       |#import "Private/FIRLogger.h"
   25|       |#import "Private/FIROptionsInternal.h"
   26|       |
   27|       |NSString *const kFIRServiceAdMob = @"AdMob";
   28|       |NSString *const kFIRServiceAuth = @"Auth";
   29|       |NSString *const kFIRServiceAuthUI = @"AuthUI";
   30|       |NSString *const kFIRServiceCrash = @"Crash";
   31|       |NSString *const kFIRServiceDatabase = @"Database";
   32|       |NSString *const kFIRServiceDynamicLinks = @"DynamicLinks";
   33|       |NSString *const kFIRServiceFirestore = @"Firestore";
   34|       |NSString *const kFIRServiceFunctions = @"Functions";
   35|       |NSString *const kFIRServiceInstanceID = @"InstanceID";
   36|       |NSString *const kFIRServiceInvites = @"Invites";
   37|       |NSString *const kFIRServiceMessaging = @"Messaging";
   38|       |NSString *const kFIRServiceMeasurement = @"Measurement";
   39|       |NSString *const kFIRServicePerformance = @"Performance";
   40|       |NSString *const kFIRServiceRemoteConfig = @"RemoteConfig";
   41|       |NSString *const kFIRServiceStorage = @"Storage";
   42|       |NSString *const kGGLServiceAnalytics = @"Analytics";
   43|       |NSString *const kGGLServiceSignIn = @"SignIn";
   44|       |
   45|       |NSString *const kFIRDefaultAppName = @"__FIRAPP_DEFAULT";
   46|       |NSString *const kFIRAppReadyToConfigureSDKNotification = @"FIRAppReadyToConfigureSDKNotification";
   47|       |NSString *const kFIRAppDeleteNotification = @"FIRAppDeleteNotification";
   48|       |NSString *const kFIRAppIsDefaultAppKey = @"FIRAppIsDefaultAppKey";
   49|       |NSString *const kFIRAppNameKey = @"FIRAppNameKey";
   50|       |NSString *const kFIRGoogleAppIDKey = @"FIRGoogleAppIDKey";
   51|       |
   52|       |NSString *const kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat =
   53|       |    @"/google/firebase/global_data_collection_enabled:%@";
   54|       |NSString *const kFIRGlobalAppDataCollectionEnabledPlistKey =
   55|       |    @"FirebaseDataCollectionDefaultEnabled";
   56|       |
   57|       |NSString *const kFIRAppDiagnosticsNotification = @"FIRAppDiagnosticsNotification";
   58|       |
   59|       |NSString *const kFIRAppDiagnosticsConfigurationTypeKey = @"ConfigType";
   60|       |NSString *const kFIRAppDiagnosticsErrorKey = @"Error";
   61|       |NSString *const kFIRAppDiagnosticsFIRAppKey = @"FIRApp";
   62|       |NSString *const kFIRAppDiagnosticsSDKNameKey = @"SDKName";
   63|       |NSString *const kFIRAppDiagnosticsSDKVersionKey = @"SDKVersion";
   64|       |
   65|       |// Auth internal notification notification and key.
   66|       |NSString *const FIRAuthStateDidChangeInternalNotification =
   67|       |    @"FIRAuthStateDidChangeInternalNotification";
   68|       |NSString *const FIRAuthStateDidChangeInternalNotificationAppKey =
   69|       |    @"FIRAuthStateDidChangeInternalNotificationAppKey";
   70|       |NSString *const FIRAuthStateDidChangeInternalNotificationTokenKey =
   71|       |    @"FIRAuthStateDidChangeInternalNotificationTokenKey";
   72|       |NSString *const FIRAuthStateDidChangeInternalNotificationUIDKey =
   73|       |    @"FIRAuthStateDidChangeInternalNotificationUIDKey";
   74|       |
   75|       |/**
   76|       | * The URL to download plist files.
   77|       | */
   78|       |static NSString *const kPlistURL = @"https://console.firebase.google.com/";
   79|       |
   80|       |/**
   81|       | * An array of all classes that registered as `FIRCoreConfigurable` in order to receive lifecycle
   82|       | * events from Core.
   83|       | */
   84|       |static NSMutableArray<Class<FIRLibrary>> *sRegisteredAsConfigurable;
   85|       |
   86|       |@interface FIRApp ()
   87|       |
   88|       |#ifdef DEBUG
   89|       |@property(nonatomic) BOOL alreadyOutputDataCollectionFlag;
   90|       |#endif  // DEBUG
   91|       |
   92|       |@end
   93|       |
   94|       |@implementation FIRApp
   95|       |
   96|       |// This is necessary since our custom getter prevents `_options` from being created.
   97|       |@synthesize options = _options;
   98|       |
   99|       |static NSMutableDictionary *sAllApps;
  100|       |static FIRApp *sDefaultApp;
  101|       |static NSMutableDictionary *sLibraryVersions;
  102|       |
  103|      1|+ (void)configure {
  104|      1|  FIROptions *options = [FIROptions defaultOptions];
  105|      1|  if (!options) {
  106|      0|    // Read the Info.plist to see if the flag is set. At this point we can't check any user defaults
  107|      0|    // since the app isn't configured at all, so only rely on the Info.plist value.
  108|      0|    NSNumber *collectionEnabledPlistValue = [[self class] readDataCollectionSwitchFromPlist];
  109|      0|    if (collectionEnabledPlistValue == nil || [collectionEnabledPlistValue boolValue]) {
  110|      0|      [[NSNotificationCenter defaultCenter]
  111|      0|          postNotificationName:kFIRAppDiagnosticsNotification
  112|      0|                        object:nil
  113|      0|                      userInfo:@{
  114|      0|                        kFIRAppDiagnosticsConfigurationTypeKey : @(FIRConfigTypeCore),
  115|      0|                        kFIRAppDiagnosticsErrorKey : [FIRApp errorForMissingOptions]
  116|      0|                      }];
  117|      0|    }
  118|      0|
  119|      0|    [NSException raise:kFirebaseCoreErrorDomain
  120|      0|                format:@"`[FIRApp configure];` (`FirebaseApp.configure()` in Swift) could not find "
  121|      0|                       @"a valid GoogleService-Info.plist in your project. Please download one "
  122|      0|                       @"from %@.",
  123|      0|                       kPlistURL];
  124|      0|  }
  125|      1|  [FIRApp configureWithOptions:options];
  126|       |#if TARGET_OS_OSX || TARGET_OS_TV
  127|       |  FIRLogNotice(kFIRLoggerCore, @"I-COR000028",
  128|       |               @"tvOS and macOS SDK support is not part of the official Firebase product. "
  129|       |               @"Instead they are community supported. Details at "
  130|       |               @"https://github.com/firebase/firebase-ios-sdk/blob/master/README.md.");
  131|       |#endif
  132|       |}
  133|       |
  134|      1|+ (void)configureWithOptions:(FIROptions *)options {
  135|      1|  if (!options) {
  136|      0|    [NSException raise:kFirebaseCoreErrorDomain
  137|      0|                format:@"Options is nil. Please pass a valid options."];
  138|      0|  }
  139|      1|  [FIRApp configureWithName:kFIRDefaultAppName options:options];
  140|      1|}
  141|       |
  142|      1|+ (void)configureWithName:(NSString *)name options:(FIROptions *)options {
  143|      1|  if (!name || !options) {
  144|      0|    [NSException raise:kFirebaseCoreErrorDomain format:@"Neither name nor options can be nil."];
  145|      0|  }
  146|      1|  if (name.length == 0) {
  147|      0|    [NSException raise:kFirebaseCoreErrorDomain format:@"Name cannot be empty."];
  148|      0|  }
  149|      1|
  150|      1|  if ([name isEqualToString:kFIRDefaultAppName]) {
  151|      1|    if (sDefaultApp) {
  152|      0|      [NSException raise:kFirebaseCoreErrorDomain
  153|      0|                  format:@"Default app has already been configured."];
  154|      0|    }
  155|      1|
  156|      1|    FIRLogDebug(kFIRLoggerCore, @"I-COR000001", @"Configuring the default app.");
  157|      1|  } else {
  158|      0|    // Validate the app name and ensure it hasn't been configured already.
  159|      0|    for (NSUInteger charIndex = 0; charIndex < name.length; charIndex++) {
  160|      0|      char character = [name characterAtIndex:charIndex];
  161|      0|      if (!((character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z') ||
  162|      0|            (character >= '0' && character <= '9') || character == '_' || character == '-')) {
  163|      0|        [NSException raise:kFirebaseCoreErrorDomain
  164|      0|                    format:@"App name should only contain Letters, "
  165|      0|                           @"Numbers, Underscores, and Dashes."];
  166|      0|      }
  167|      0|    }
  168|      0|
  169|      0|    if (sAllApps && sAllApps[name]) {
  170|      0|      [NSException raise:kFirebaseCoreErrorDomain
  171|      0|                  format:@"App named %@ has already been configured.", name];
  172|      0|    }
  173|      0|
  174|      0|    FIRLogDebug(kFIRLoggerCore, @"I-COR000002", @"Configuring app named %@", name);
  175|      0|  }
  176|      1|
  177|      1|  @synchronized(self) {
  178|      1|    FIRApp *app = [[FIRApp alloc] initInstanceWithName:name options:options];
  179|      1|    if (app.isDefaultApp) {
  180|      1|      sDefaultApp = app;
  181|      1|    }
  182|      1|
  183|      1|    [FIRApp addAppToAppDictionary:app];
  184|      1|    [FIRApp sendNotificationsToSDKs:app];
  185|      1|  }
  186|      1|}
  187|       |
  188|      3|+ (FIRApp *)defaultApp {
  189|      3|  if (sDefaultApp) {
  190|      3|    return sDefaultApp;
  191|      3|  }
  192|      0|  FIRLogError(kFIRLoggerCore, @"I-COR000003",
  193|      0|              @"The default Firebase app has not yet been "
  194|      0|              @"configured. Add `[FIRApp configure];` (`FirebaseApp.configure()` in Swift) to your "
  195|      0|              @"application initialization. Read more: https://goo.gl/ctyzm8.");
  196|      0|  return nil;
  197|      0|}
  198|       |
  199|      0|+ (FIRApp *)appNamed:(NSString *)name {
  200|      0|  @synchronized(self) {
  201|      0|    if (sAllApps) {
  202|      0|      FIRApp *app = sAllApps[name];
  203|      0|      if (app) {
  204|      0|        return app;
  205|      0|      }
  206|      0|    }
  207|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000004", @"App with name %@ does not exist.", name);
  208|      0|    return nil;
  209|      0|  }
  210|      0|}
  211|       |
  212|      1|+ (NSDictionary *)allApps {
  213|      1|  @synchronized(self) {
  214|      1|    if (!sAllApps) {
  215|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000005", @"No app has been configured yet.");
  216|      0|    }
  217|      1|    NSDictionary *dict = [NSDictionary dictionaryWithDictionary:sAllApps];
  218|      1|    return dict;
  219|      1|  }
  220|      1|}
  221|       |
  222|       |// Public only for tests
  223|      0|+ (void)resetApps {
  224|      0|  sDefaultApp = nil;
  225|      0|  [sAllApps removeAllObjects];
  226|      0|  sAllApps = nil;
  227|      0|  [sLibraryVersions removeAllObjects];
  228|      0|  sLibraryVersions = nil;
  229|      0|}
  230|       |
  231|      0|- (void)deleteApp:(FIRAppVoidBoolCallback)completion {
  232|      0|  @synchronized([self class]) {
  233|      0|    if (sAllApps && sAllApps[self.name]) {
  234|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000006", @"Deleting app named %@", self.name);
  235|      0|
  236|      0|      // Remove all cached instances from the container before deleting the app.
  237|      0|      [self.container removeAllCachedInstances];
  238|      0|
  239|      0|      [sAllApps removeObjectForKey:self.name];
  240|      0|      [self clearDataCollectionSwitchFromUserDefaults];
  241|      0|      if ([self.name isEqualToString:kFIRDefaultAppName]) {
  242|      0|        sDefaultApp = nil;
  243|      0|      }
  244|      0|      NSDictionary *appInfoDict = @{kFIRAppNameKey : self.name};
  245|      0|      [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppDeleteNotification
  246|      0|                                                          object:[self class]
  247|      0|                                                        userInfo:appInfoDict];
  248|      0|      completion(YES);
  249|      0|    } else {
  250|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000007", @"App does not exist.");
  251|      0|      completion(NO);
  252|      0|    }
  253|      0|  }
  254|      0|}
  255|       |
  256|      1|+ (void)addAppToAppDictionary:(FIRApp *)app {
  257|      1|  if (!sAllApps) {
  258|      1|    sAllApps = [NSMutableDictionary dictionary];
  259|      1|  }
  260|      1|  if ([app configureCore]) {
  261|      1|    sAllApps[app.name] = app;
  262|      1|  } else {
  263|      0|    [NSException raise:kFirebaseCoreErrorDomain
  264|      0|                format:@"Configuration fails. It may be caused by an invalid GOOGLE_APP_ID in "
  265|      0|                       @"GoogleService-Info.plist or set in the customized options."];
  266|      0|  }
  267|      1|}
  268|       |
  269|      1|- (instancetype)initInstanceWithName:(NSString *)name options:(FIROptions *)options {
  270|      1|  self = [super init];
  271|      1|  if (self) {
  272|      1|    _name = [name copy];
  273|      1|    _options = [options copy];
  274|      1|    _options.editingLocked = YES;
  275|      1|    _isDefaultApp = [name isEqualToString:kFIRDefaultAppName];
  276|      1|    _container = [[FIRComponentContainer alloc] initWithApp:self];
  277|      1|  }
  278|      1|  return self;
  279|      1|}
  280|       |
  281|      1|- (BOOL)configureCore {
  282|      1|  [self checkExpectedBundleID];
  283|      1|  if (![self isAppIDValid]) {
  284|      0|    if (_options.usingOptionsFromDefaultPlist && [self isDataCollectionDefaultEnabled]) {
  285|      0|      [[NSNotificationCenter defaultCenter]
  286|      0|          postNotificationName:kFIRAppDiagnosticsNotification
  287|      0|                        object:nil
  288|      0|                      userInfo:@{
  289|      0|                        kFIRAppDiagnosticsConfigurationTypeKey : @(FIRConfigTypeCore),
  290|      0|                        kFIRAppDiagnosticsErrorKey : [FIRApp errorForInvalidAppID],
  291|      0|                      }];
  292|      0|    }
  293|      0|    return NO;
  294|      0|  }
  295|      1|
  296|      1|  if ([self isDataCollectionDefaultEnabled]) {
  297|      1|    [[NSNotificationCenter defaultCenter]
  298|      1|        postNotificationName:kFIRAppDiagnosticsNotification
  299|      1|                      object:nil
  300|      1|                    userInfo:@{
  301|      1|                      kFIRAppDiagnosticsConfigurationTypeKey : @(FIRConfigTypeCore),
  302|      1|                      kFIRAppDiagnosticsFIRAppKey : self
  303|      1|                    }];
  304|      1|  }
  305|      1|
  306|      1|#if TARGET_OS_IOS
  307|      1|  // Initialize the Analytics once there is a valid options under default app. Analytics should
  308|      1|  // always initialize first by itself before the other SDKs.
  309|      1|  if ([self.name isEqualToString:kFIRDefaultAppName]) {
  310|      1|    Class firAnalyticsClass = NSClassFromString(@"FIRAnalytics");
  311|      1|    if (!firAnalyticsClass) {
  312|      0|      FIRLogWarning(kFIRLoggerCore, @"I-COR000022",
  313|      0|                    @"Firebase Analytics is not available. To add it, include Firebase/Core in the "
  314|      0|                    @"Podfile or add FirebaseAnalytics.framework to the Link Build Phase");
  315|      1|    } else {
  316|      1|#pragma clang diagnostic push
  317|      1|#pragma clang diagnostic ignored "-Wundeclared-selector"
  318|      1|      SEL startWithConfigurationSelector = @selector(startWithConfiguration:options:);
  319|      1|#pragma clang diagnostic pop
  320|      1|      if ([firAnalyticsClass respondsToSelector:startWithConfigurationSelector]) {
  321|      1|#pragma clang diagnostic push
  322|      1|#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
  323|      1|        [firAnalyticsClass performSelector:startWithConfigurationSelector
  324|      1|                                withObject:[FIRConfiguration sharedInstance].analyticsConfiguration
  325|      1|                                withObject:_options];
  326|      1|#pragma clang diagnostic pop
  327|      1|      }
  328|      1|    }
  329|      1|  }
  330|      1|#endif
  331|      1|
  332|      1|  return YES;
  333|      1|}
  334|       |
  335|     12|- (FIROptions *)options {
  336|     12|  return [_options copy];
  337|     12|}
  338|       |
  339|      0|- (void)setDataCollectionDefaultEnabled:(BOOL)dataCollectionDefaultEnabled {
  340|      0|#ifdef DEBUG
  341|      0|  FIRLogDebug(kFIRLoggerCore, @"I-COR000034", @"Explicitly %@ data collection flag.",
  342|      0|              dataCollectionDefaultEnabled ? @"enabled" : @"disabled");
  343|      0|  self.alreadyOutputDataCollectionFlag = YES;
  344|      0|#endif  // DEBUG
  345|      0|
  346|      0|  NSString *key =
  347|      0|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, self.name];
  348|      0|  [[NSUserDefaults standardUserDefaults] setBool:dataCollectionDefaultEnabled forKey:key];
  349|      0|
  350|      0|  // Core also controls the FirebaseAnalytics flag, so check if the Analytics flags are set
  351|      0|  // within FIROptions and change the Analytics value if necessary. Analytics only works with the
  352|      0|  // default app, so return if this isn't the default app.
  353|      0|  if (!self.isDefaultApp) {
  354|      0|    return;
  355|      0|  }
  356|      0|
  357|      0|  // Check if the Analytics flag is explicitly set. If so, no further actions are necessary.
  358|      0|  if ([self.options isAnalyticsCollectionExpicitlySet]) {
  359|      0|    return;
  360|      0|  }
  361|      0|
  362|      0|  // The Analytics flag has not been explicitly set, so update with the value being set.
  363|      0|  [[FIRAnalyticsConfiguration sharedInstance]
  364|      0|      setAnalyticsCollectionEnabled:dataCollectionDefaultEnabled
  365|      0|                     persistSetting:NO];
  366|      0|}
  367|       |
  368|      3|- (BOOL)isDataCollectionDefaultEnabled {
  369|      3|  // Check if it's been manually set before in code, and use that as the higher priority value.
  370|      3|  NSNumber *defaultsObject = [[self class] readDataCollectionSwitchFromUserDefaultsForApp:self];
  371|      3|  if (defaultsObject != nil) {
  372|      0|#ifdef DEBUG
  373|      0|    if (!self.alreadyOutputDataCollectionFlag) {
  374|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000031", @"Data Collection flag is %@ in user defaults.",
  375|      0|                  [defaultsObject boolValue] ? @"enabled" : @"disabled");
  376|      0|      self.alreadyOutputDataCollectionFlag = YES;
  377|      0|    }
  378|      0|#endif  // DEBUG
  379|      0|    return [defaultsObject boolValue];
  380|      0|  }
  381|      3|
  382|      3|  // Read the Info.plist to see if the flag is set. If it's not set, it should default to `YES`.
  383|      3|  // As per the implementation of `readDataCollectionSwitchFromPlist`, it's a cached value and has
  384|      3|  // no performance impact calling multiple times.
  385|      3|  NSNumber *collectionEnabledPlistValue = [[self class] readDataCollectionSwitchFromPlist];
  386|      3|  if (collectionEnabledPlistValue != nil) {
  387|      0|#ifdef DEBUG
  388|      0|    if (!self.alreadyOutputDataCollectionFlag) {
  389|      0|      FIRLogDebug(kFIRLoggerCore, @"I-COR000032", @"Data Collection flag is %@ in plist.",
  390|      0|                  [collectionEnabledPlistValue boolValue] ? @"enabled" : @"disabled");
  391|      0|      self.alreadyOutputDataCollectionFlag = YES;
  392|      0|    }
  393|      0|#endif  // DEBUG
  394|      0|    return [collectionEnabledPlistValue boolValue];
  395|      0|  }
  396|      3|
  397|      3|#ifdef DEBUG
  398|      3|  if (!self.alreadyOutputDataCollectionFlag) {
  399|      1|    FIRLogDebug(kFIRLoggerCore, @"I-COR000033", @"Data Collection flag is not set.");
  400|      1|    self.alreadyOutputDataCollectionFlag = YES;
  401|      1|  }
  402|      3|#endif  // DEBUG
  403|      3|  return YES;
  404|      3|}
  405|       |
  406|       |#pragma mark - private
  407|       |
  408|      1|+ (void)sendNotificationsToSDKs:(FIRApp *)app {
  409|      1|  // TODO: Remove this notification once all SDKs are registered with `FIRCoreConfigurable`.
  410|      1|  NSNumber *isDefaultApp = [NSNumber numberWithBool:app.isDefaultApp];
  411|      1|  NSDictionary *appInfoDict = @{
  412|      1|    kFIRAppNameKey : app.name,
  413|      1|    kFIRAppIsDefaultAppKey : isDefaultApp,
  414|      1|    kFIRGoogleAppIDKey : app.options.googleAppID
  415|      1|  };
  416|      1|  [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppReadyToConfigureSDKNotification
  417|      1|                                                      object:self
  418|      1|                                                    userInfo:appInfoDict];
  419|      1|
  420|      1|  // This is the new way of sending information to SDKs.
  421|      1|  // TODO: Do we want this on a background thread, maybe?
  422|      2|  for (Class<FIRLibrary> library in sRegisteredAsConfigurable) {
  423|      2|    [library configureWithApp:app];
  424|      2|  }
  425|      1|}
  426|       |
  427|      0|+ (NSError *)errorForMissingOptions {
  428|      0|  NSDictionary *errorDict = @{
  429|      0|    NSLocalizedDescriptionKey :
  430|      0|        @"Unable to parse GoogleService-Info.plist in order to configure services.",
  431|      0|    NSLocalizedRecoverySuggestionErrorKey :
  432|      0|        @"Check formatting and location of GoogleService-Info.plist."
  433|      0|  };
  434|      0|  return [NSError errorWithDomain:kFirebaseCoreErrorDomain
  435|      0|                             code:FIRErrorCodeInvalidPlistFile
  436|      0|                         userInfo:errorDict];
  437|      0|}
  438|       |
  439|       |+ (NSError *)errorForSubspecConfigurationFailureWithDomain:(NSString *)domain
  440|       |                                                 errorCode:(FIRErrorCode)code
  441|       |                                                   service:(NSString *)service
  442|      0|                                                    reason:(NSString *)reason {
  443|      0|  NSString *description =
  444|      0|      [NSString stringWithFormat:@"Configuration failed for service %@.", service];
  445|      0|  NSDictionary *errorDict =
  446|      0|      @{NSLocalizedDescriptionKey : description, NSLocalizedFailureReasonErrorKey : reason};
  447|      0|  return [NSError errorWithDomain:domain code:code userInfo:errorDict];
  448|      0|}
  449|       |
  450|      0|+ (NSError *)errorForInvalidAppID {
  451|      0|  NSDictionary *errorDict = @{
  452|      0|    NSLocalizedDescriptionKey : @"Unable to validate Google App ID",
  453|      0|    NSLocalizedRecoverySuggestionErrorKey :
  454|      0|        @"Check formatting and location of GoogleService-Info.plist or GoogleAppID set in the "
  455|      0|        @"customized options."
  456|      0|  };
  457|      0|  return [NSError errorWithDomain:kFirebaseCoreErrorDomain
  458|      0|                             code:FIRErrorCodeInvalidAppID
  459|      0|                         userInfo:errorDict];
  460|      0|}
  461|       |
  462|      2|+ (BOOL)isDefaultAppConfigured {
  463|      2|  return (sDefaultApp != nil);
  464|      2|}
  465|       |
  466|      6|+ (void)registerLibrary:(nonnull NSString *)name withVersion:(nonnull NSString *)version {
  467|      6|  // Create the set of characters which aren't allowed, only if this feature is used.
  468|      6|  NSMutableCharacterSet *allowedSet = [NSMutableCharacterSet alphanumericCharacterSet];
  469|      6|  [allowedSet addCharactersInString:@"-_."];
  470|      6|  NSCharacterSet *disallowedSet = [allowedSet invertedSet];
  471|      6|  // Make sure the library name and version strings do not contain unexpected characters, and
  472|      6|  // add the name/version pair to the dictionary.
  473|      6|  if ([name rangeOfCharacterFromSet:disallowedSet].location == NSNotFound &&
  474|      6|      [version rangeOfCharacterFromSet:disallowedSet].location == NSNotFound) {
  475|      6|    if (!sLibraryVersions) {
  476|      1|      sLibraryVersions = [[NSMutableDictionary alloc] init];
  477|      1|    }
  478|      6|    sLibraryVersions[name] = version;
  479|      6|  } else {
  480|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000027",
  481|      0|                @"The library name (%@) or version number (%@) contain invalid characters. "
  482|      0|                @"Only alphanumeric, dash, underscore and period characters are allowed.",
  483|      0|                name, version);
  484|      0|  }
  485|      6|}
  486|       |
  487|       |+ (void)registerInternalLibrary:(nonnull Class<FIRLibrary>)library
  488|       |                       withName:(nonnull NSString *)name
  489|      3|                    withVersion:(nonnull NSString *)version {
  490|      3|  // This is called at +load time, keep the work to a minimum.
  491|      3|
  492|      3|  // Ensure the class given conforms to the proper protocol.
  493|      3|  if (![(Class)library conformsToProtocol:@protocol(FIRLibrary)] ||
  494|      3|      ![(Class)library respondsToSelector:@selector(componentsToRegister)]) {
  495|      0|    [NSException raise:NSInvalidArgumentException
  496|      0|                format:@"Class %@ attempted to register components, but it does not conform to "
  497|      0|                       @"`FIRLibrary or provide a `componentsToRegister:` method.",
  498|      0|                       library];
  499|      0|  }
  500|      3|
  501|      3|  [FIRComponentContainer registerAsComponentRegistrant:library];
  502|      3|  if ([(Class)library respondsToSelector:@selector(configureWithApp:)]) {
  503|      2|    static dispatch_once_t onceToken;
  504|      2|    dispatch_once(&onceToken, ^{
  505|      1|      sRegisteredAsConfigurable = [[NSMutableArray alloc] init];
  506|      1|    });
  507|      2|    [sRegisteredAsConfigurable addObject:library];
  508|      2|  }
  509|      3|  [self registerLibrary:name withVersion:version];
  510|      3|}
  511|       |
  512|      2|+ (NSString *)firebaseUserAgent {
  513|      2|  NSMutableArray<NSString *> *libraries =
  514|      2|      [[NSMutableArray<NSString *> alloc] initWithCapacity:sLibraryVersions.count];
  515|     12|  for (NSString *libraryName in sLibraryVersions) {
  516|     12|    [libraries
  517|     12|        addObject:[NSString stringWithFormat:@"%@/%@", libraryName, sLibraryVersions[libraryName]]];
  518|     12|  }
  519|      2|  [libraries sortUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
  520|      2|  return [libraries componentsJoinedByString:@" "];
  521|      2|}
  522|       |
  523|      1|- (void)checkExpectedBundleID {
  524|      1|  NSArray *bundles = [FIRBundleUtil relevantBundles];
  525|      1|  NSString *expectedBundleID = [self expectedBundleID];
  526|      1|  // The checking is only done when the bundle ID is provided in the serviceInfo dictionary for
  527|      1|  // backward compatibility.
  528|      1|  if (expectedBundleID != nil && ![FIRBundleUtil hasBundleIdentifier:expectedBundleID
  529|      1|                                                           inBundles:bundles]) {
  530|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000008",
  531|      0|                @"The project's Bundle ID is inconsistent with "
  532|      0|                @"either the Bundle ID in '%@.%@', or the Bundle ID in the options if you are "
  533|      0|                @"using a customized options. To ensure that everything can be configured "
  534|      0|                @"correctly, you may need to make the Bundle IDs consistent. To continue with this "
  535|      0|                @"plist file, you may change your app's bundle identifier to '%@'. Or you can "
  536|      0|                @"download a new configuration file that matches your bundle identifier from %@ "
  537|      0|                @"and replace the current one.",
  538|      0|                kServiceInfoFileName, kServiceInfoFileType, expectedBundleID, kPlistURL);
  539|      0|  }
  540|      1|}
  541|       |
  542|       |#pragma mark - private - App ID Validation
  543|       |
  544|       |/**
  545|       | * Validates the format and fingerprint of the app ID contained in GOOGLE_APP_ID in the plist file.
  546|       | * This is the main method for validating app ID.
  547|       | *
  548|       | * @return YES if the app ID fulfills the expected format and fingerprint, NO otherwise.
  549|       | */
  550|      1|- (BOOL)isAppIDValid {
  551|      1|  NSString *appID = _options.googleAppID;
  552|      1|  BOOL isValid = [FIRApp validateAppID:appID];
  553|      1|  if (!isValid) {
  554|      0|    NSString *expectedBundleID = [self expectedBundleID];
  555|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000009",
  556|      0|                @"The GOOGLE_APP_ID either in the plist file "
  557|      0|                @"'%@.%@' or the one set in the customized options is invalid. If you are using "
  558|      0|                @"the plist file, use the iOS version of bundle identifier to download the file, "
  559|      0|                @"and do not manually edit the GOOGLE_APP_ID. You may change your app's bundle "
  560|      0|                @"identifier to '%@'. Or you can download a new configuration file that matches "
  561|      0|                @"your bundle identifier from %@ and replace the current one.",
  562|      0|                kServiceInfoFileName, kServiceInfoFileType, expectedBundleID, kPlistURL);
  563|      0|  };
  564|      1|  return isValid;
  565|      1|}
  566|       |
  567|      1|+ (BOOL)validateAppID:(NSString *)appID {
  568|      1|  // Failing validation only occurs when we are sure we are looking at a V2 app ID and it does not
  569|      1|  // have a valid fingerprint, otherwise we just warn about the potential issue.
  570|      1|  if (!appID.length) {
  571|      0|    return NO;
  572|      0|  }
  573|      1|
  574|      1|  // All app IDs must start with at least "<version number>:".
  575|      1|  NSString *const versionPattern = @"^\\d+:";
  576|      1|  NSRegularExpression *versionRegex =
  577|      1|      [NSRegularExpression regularExpressionWithPattern:versionPattern options:0 error:NULL];
  578|      1|  if (!versionRegex) {
  579|      0|    return NO;
  580|      0|  }
  581|      1|
  582|      1|  NSRange appIDRange = NSMakeRange(0, appID.length);
  583|      1|  NSArray *versionMatches = [versionRegex matchesInString:appID options:0 range:appIDRange];
  584|      1|  if (versionMatches.count != 1) {
  585|      0|    return NO;
  586|      0|  }
  587|      1|
  588|      1|  NSRange versionRange = [(NSTextCheckingResult *)versionMatches.firstObject range];
  589|      1|  NSString *appIDVersion = [appID substringWithRange:versionRange];
  590|      1|  NSArray *knownVersions = @[ @"1:" ];
  591|      1|  if (![knownVersions containsObject:appIDVersion]) {
  592|      0|    // Permit unknown yet properly formatted app ID versions.
  593|      0|    return YES;
  594|      0|  }
  595|      1|
  596|      1|  if (![FIRApp validateAppIDFormat:appID withVersion:appIDVersion]) {
  597|      0|    return NO;
  598|      0|  }
  599|      1|
  600|      1|  if (![FIRApp validateAppIDFingerprint:appID withVersion:appIDVersion]) {
  601|      0|    return NO;
  602|      0|  }
  603|      1|
  604|      1|  return YES;
  605|      1|}
  606|       |
  607|      0|+ (NSString *)actualBundleID {
  608|      0|  return [[NSBundle mainBundle] bundleIdentifier];
  609|      0|}
  610|       |
  611|       |/**
  612|       | * Validates that the format of the app ID string is what is expected based on the supplied version.
  613|       | * The version must end in ":".
  614|       | *
  615|       | * For v1 app ids the format is expected to be
  616|       | * '<version #>:<project number>:ios:<fingerprint of bundle id>'.
  617|       | *
  618|       | * This method does not verify that the contents of the app id are correct, just that they fulfill
  619|       | * the expected format.
  620|       | *
  621|       | * @param appID Contents of GOOGLE_APP_ID from the plist file.
  622|       | * @param version Indicates what version of the app id format this string should be.
  623|       | * @return YES if provided string fufills the expected format, NO otherwise.
  624|       | */
  625|      1|+ (BOOL)validateAppIDFormat:(NSString *)appID withVersion:(NSString *)version {
  626|      1|  if (!appID.length || !version.length) {
  627|      0|    return NO;
  628|      0|  }
  629|      1|
  630|      1|  if (![version hasSuffix:@":"]) {
  631|      0|    return NO;
  632|      0|  }
  633|      1|
  634|      1|  if (![appID hasPrefix:version]) {
  635|      0|    return NO;
  636|      0|  }
  637|      1|
  638|      1|  NSString *const pattern = @"^\\d+:ios:[a-f0-9]+$";
  639|      1|  NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern
  640|      1|                                                                         options:0
  641|      1|                                                                           error:NULL];
  642|      1|  if (!regex) {
  643|      0|    return NO;
  644|      0|  }
  645|      1|
  646|      1|  NSRange localRange = NSMakeRange(version.length, appID.length - version.length);
  647|      1|  NSUInteger numberOfMatches = [regex numberOfMatchesInString:appID options:0 range:localRange];
  648|      1|  if (numberOfMatches != 1) {
  649|      0|    return NO;
  650|      0|  }
  651|      1|  return YES;
  652|      1|}
  653|       |
  654|       |/**
  655|       | * Validates that the fingerprint of the app ID string is what is expected based on the supplied
  656|       | * version. The version must end in ":".
  657|       | *
  658|       | * Note that the v1 hash algorithm is not permitted on the client and cannot be fully validated.
  659|       | *
  660|       | * @param appID Contents of GOOGLE_APP_ID from the plist file.
  661|       | * @param version Indicates what version of the app id format this string should be.
  662|       | * @return YES if provided string fufills the expected fingerprint and the version is known, NO
  663|       | *         otherwise.
  664|       | */
  665|      1|+ (BOOL)validateAppIDFingerprint:(NSString *)appID withVersion:(NSString *)version {
  666|      1|  if (!appID.length || !version.length) {
  667|      0|    return NO;
  668|      0|  }
  669|      1|
  670|      1|  if (![version hasSuffix:@":"]) {
  671|      0|    return NO;
  672|      0|  }
  673|      1|
  674|      1|  if (![appID hasPrefix:version]) {
  675|      0|    return NO;
  676|      0|  }
  677|      1|
  678|      1|  // Extract the supplied fingerprint from the supplied app ID.
  679|      1|  // This assumes the app ID format is the same for all known versions below. If the app ID format
  680|      1|  // changes in future versions, the tokenizing of the app ID format will need to take into account
  681|      1|  // the version of the app ID.
  682|      1|  NSArray *components = [appID componentsSeparatedByString:@":"];
  683|      1|  if (components.count != 4) {
  684|      0|    return NO;
  685|      0|  }
  686|      1|
  687|      1|  NSString *suppliedFingerprintString = components[3];
  688|      1|  if (!suppliedFingerprintString.length) {
  689|      0|    return NO;
  690|      0|  }
  691|      1|
  692|      1|  uint64_t suppliedFingerprint;
  693|      1|  NSScanner *scanner = [NSScanner scannerWithString:suppliedFingerprintString];
  694|      1|  if (![scanner scanHexLongLong:&suppliedFingerprint]) {
  695|      0|    return NO;
  696|      0|  }
  697|      1|
  698|      1|  if ([version isEqual:@"1:"]) {
  699|      1|    // The v1 hash algorithm is not permitted on the client so the actual hash cannot be validated.
  700|      1|    return YES;
  701|      1|  }
  702|      0|
  703|      0|  // Unknown version.
  704|      0|  return NO;
  705|      0|}
  706|       |
  707|      1|- (NSString *)expectedBundleID {
  708|      1|  return _options.bundleID;
  709|      1|}
  710|       |
  711|       |// end App ID validation
  712|       |
  713|       |#pragma mark - Reading From Plist & User Defaults
  714|       |
  715|       |/**
  716|       | * Clears the data collection switch from the standard NSUserDefaults for easier testing and
  717|       | * readability.
  718|       | */
  719|      0|- (void)clearDataCollectionSwitchFromUserDefaults {
  720|      0|  NSString *key =
  721|      0|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, self.name];
  722|      0|  [[NSUserDefaults standardUserDefaults] removeObjectForKey:key];
  723|      0|}
  724|       |
  725|       |/**
  726|       | * Reads the data collection switch from the standard NSUserDefaults for easier testing and
  727|       | * readability.
  728|       | */
  729|      3|+ (nullable NSNumber *)readDataCollectionSwitchFromUserDefaultsForApp:(FIRApp *)app {
  730|      3|  // Read the object in user defaults, and only return if it's an NSNumber.
  731|      3|  NSString *key =
  732|      3|      [NSString stringWithFormat:kFIRGlobalAppDataCollectionEnabledDefaultsKeyFormat, app.name];
  733|      3|  id collectionEnabledDefaultsObject = [[NSUserDefaults standardUserDefaults] objectForKey:key];
  734|      3|  if ([collectionEnabledDefaultsObject isKindOfClass:[NSNumber class]]) {
  735|      0|    return collectionEnabledDefaultsObject;
  736|      0|  }
  737|      3|
  738|      3|  return nil;
  739|      3|}
  740|       |
  741|       |/**
  742|       | * Reads the data collection switch from the Info.plist for easier testing and readability. Will
  743|       | * only read once from the plist and return the cached value.
  744|       | */
  745|      3|+ (nullable NSNumber *)readDataCollectionSwitchFromPlist {
  746|      3|  static NSNumber *collectionEnabledPlistObject;
  747|      3|  static dispatch_once_t onceToken;
  748|      3|  dispatch_once(&onceToken, ^{
  749|      1|    // Read the data from the `Info.plist`, only assign it if it's there and an NSNumber.
  750|      1|    id plistValue = [[NSBundle mainBundle]
  751|      1|        objectForInfoDictionaryKey:kFIRGlobalAppDataCollectionEnabledPlistKey];
  752|      1|    if (plistValue && [plistValue isKindOfClass:[NSNumber class]]) {
  753|      0|      collectionEnabledPlistObject = (NSNumber *)plistValue;
  754|      0|    }
  755|      1|  });
  756|      3|
  757|      3|  return collectionEnabledPlistObject;
  758|      3|}
  759|       |
  760|       |#pragma mark - Sending Logs
  761|       |
  762|       |- (void)sendLogsWithServiceName:(NSString *)serviceName
  763|       |                        version:(NSString *)version
  764|      0|                          error:(NSError *)error {
  765|      0|  // If the user has manually turned off data collection, return and don't send logs.
  766|      0|  if (![self isDataCollectionDefaultEnabled]) {
  767|      0|    return;
  768|      0|  }
  769|      0|
  770|      0|  NSMutableDictionary *userInfo = [[NSMutableDictionary alloc] initWithDictionary:@{
  771|      0|    kFIRAppDiagnosticsConfigurationTypeKey : @(FIRConfigTypeSDK),
  772|      0|    kFIRAppDiagnosticsSDKNameKey : serviceName,
  773|      0|    kFIRAppDiagnosticsSDKVersionKey : version,
  774|      0|    kFIRAppDiagnosticsFIRAppKey : self
  775|      0|  }];
  776|      0|  if (error) {
  777|      0|    userInfo[kFIRAppDiagnosticsErrorKey] = error;
  778|      0|  }
  779|      0|  [[NSNotificationCenter defaultCenter] postNotificationName:kFIRAppDiagnosticsNotification
  780|      0|                                                      object:nil
  781|      0|                                                    userInfo:userInfo];
  782|      0|}
  783|       |
  784|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRAppAssociationRegistration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/FIRAppAssociationRegistration.h"
   16|       |
   17|       |#import <objc/runtime.h>
   18|       |
   19|       |@implementation FIRAppAssociationRegistration
   20|       |
   21|       |+ (nullable id)registeredObjectWithHost:(id)host
   22|       |                                    key:(NSString *)key
   23|      0|                          creationBlock:(id _Nullable (^)(void))creationBlock {
   24|      0|  @synchronized(self) {
   25|      0|    SEL dictKey = @selector(registeredObjectWithHost:key:creationBlock:);
   26|      0|    NSMutableDictionary<NSString *, id> *objectsByKey = objc_getAssociatedObject(host, dictKey);
   27|      0|    if (!objectsByKey) {
   28|      0|      objectsByKey = [[NSMutableDictionary alloc] init];
   29|      0|      objc_setAssociatedObject(host, dictKey, objectsByKey, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
   30|      0|    }
   31|      0|    id obj = objectsByKey[key];
   32|      0|    NSValue *creationBlockBeingCalled = [NSValue valueWithPointer:dictKey];
   33|      0|    if (obj) {
   34|      0|      if ([creationBlockBeingCalled isEqual:obj]) {
   35|      0|        [NSException raise:@"Reentering registeredObjectWithHost:key:creationBlock: not allowed"
   36|      0|                    format:@"host: %@ key: %@", host, key];
   37|      0|      }
   38|      0|      return obj;
   39|      0|    }
   40|      0|    objectsByKey[key] = creationBlockBeingCalled;
   41|      0|    obj = creationBlock();
   42|      0|    objectsByKey[key] = obj;
   43|      0|    return obj;
   44|      0|  }
   45|      0|}
   46|       |
   47|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRBundleUtil.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/FIRBundleUtil.h"
   16|       |
   17|       |@implementation FIRBundleUtil
   18|       |
   19|      2|+ (NSArray *)relevantBundles {
   20|      2|  return @[ [NSBundle mainBundle], [NSBundle bundleForClass:[self class]] ];
   21|      2|}
   22|       |
   23|       |+ (NSString *)optionsDictionaryPathWithResourceName:(NSString *)resourceName
   24|       |                                        andFileType:(NSString *)fileType
   25|      1|                                          inBundles:(NSArray *)bundles {
   26|      1|  // Loop through all bundles to find the config dict.
   27|      1|  for (NSBundle *bundle in bundles) {
   28|      1|    NSString *path = [bundle pathForResource:resourceName ofType:fileType];
   29|      1|    // Use the first one we find.
   30|      1|    if (path) {
   31|      1|      return path;
   32|      1|    }
   33|      1|  }
   34|      1|  return nil;
   35|      1|}
   36|       |
   37|      0|+ (NSArray *)relevantURLSchemes {
   38|      0|  NSMutableArray *result = [[NSMutableArray alloc] init];
   39|      0|  for (NSBundle *bundle in [[self class] relevantBundles]) {
   40|      0|    NSArray *urlTypes = [bundle objectForInfoDictionaryKey:@"CFBundleURLTypes"];
   41|      0|    for (NSDictionary *urlType in urlTypes) {
   42|      0|      [result addObjectsFromArray:urlType[@"CFBundleURLSchemes"]];
   43|      0|    }
   44|      0|  }
   45|      0|  return result;
   46|      0|}
   47|       |
   48|      1|+ (BOOL)hasBundleIdentifier:(NSString *)bundleIdentifier inBundles:(NSArray *)bundles {
   49|      1|  for (NSBundle *bundle in bundles) {
   50|      1|    if ([bundle.bundleIdentifier isEqualToString:bundleIdentifier]) {
   51|      1|      return YES;
   52|      1|    }
   53|      1|  }
   54|      1|  return NO;
   55|      1|}
   56|       |
   57|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRComponent.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "Private/FIRComponent.h"
   18|       |
   19|       |#import "Private/FIRComponentContainer.h"
   20|       |#import "Private/FIRDependency.h"
   21|       |
   22|       |@interface FIRComponent ()
   23|       |
   24|       |- (instancetype)initWithProtocol:(Protocol *)protocol
   25|       |             instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   26|       |                    dependencies:(NSArray<FIRDependency *> *)dependencies
   27|       |                   creationBlock:(FIRComponentCreationBlock)creationBlock;
   28|       |
   29|       |@end
   30|       |
   31|       |@implementation FIRComponent
   32|       |
   33|       |+ (instancetype)componentWithProtocol:(Protocol *)protocol
   34|      1|                        creationBlock:(FIRComponentCreationBlock)creationBlock {
   35|      1|  return [[FIRComponent alloc] initWithProtocol:protocol
   36|      1|                            instantiationTiming:FIRInstantiationTimingLazy
   37|      1|                                   dependencies:@[]
   38|      1|                                  creationBlock:creationBlock];
   39|      1|}
   40|       |
   41|       |+ (instancetype)componentWithProtocol:(Protocol *)protocol
   42|       |                  instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   43|       |                         dependencies:(NSArray<FIRDependency *> *)dependencies
   44|      2|                        creationBlock:(FIRComponentCreationBlock)creationBlock {
   45|      2|  return [[FIRComponent alloc] initWithProtocol:protocol
   46|      2|                            instantiationTiming:instantiationTiming
   47|      2|                                   dependencies:dependencies
   48|      2|                                  creationBlock:creationBlock];
   49|      2|}
   50|       |
   51|       |- (instancetype)initWithProtocol:(Protocol *)protocol
   52|       |             instantiationTiming:(FIRInstantiationTiming)instantiationTiming
   53|       |                    dependencies:(NSArray<FIRDependency *> *)dependencies
   54|      3|                   creationBlock:(FIRComponentCreationBlock)creationBlock {
   55|      3|  self = [super init];
   56|      3|  if (self) {
   57|      3|    _protocol = protocol;
   58|      3|    _instantiationTiming = instantiationTiming;
   59|      3|    _dependencies = [dependencies copy];
   60|      3|    _creationBlock = creationBlock;
   61|      3|  }
   62|      3|  return self;
   63|      3|}
   64|       |
   65|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRComponentContainer.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "Private/FIRComponentContainer.h"
   18|       |
   19|       |#import "Private/FIRAppInternal.h"
   20|       |#import "Private/FIRComponent.h"
   21|       |#import "Private/FIRLibrary.h"
   22|       |#import "Private/FIRLogger.h"
   23|       |
   24|       |NS_ASSUME_NONNULL_BEGIN
   25|       |
   26|       |@interface FIRComponentContainer ()
   27|       |
   28|       |/// The dictionary of components that are registered for a particular app. The key is an NSString
   29|       |/// of the protocol.
   30|       |@property(nonatomic, strong) NSMutableDictionary<NSString *, FIRComponentCreationBlock> *components;
   31|       |
   32|       |/// Cached instances of components that requested to be cached.
   33|       |@property(nonatomic, strong) NSMutableDictionary<NSString *, id> *cachedInstances;
   34|       |
   35|       |@end
   36|       |
   37|       |@implementation FIRComponentContainer
   38|       |
   39|       |// Collection of all classes that register to provide components.
   40|       |static NSMutableSet<Class> *sFIRComponentRegistrants;
   41|       |
   42|       |#pragma mark - Public Registration
   43|       |
   44|      3|+ (void)registerAsComponentRegistrant:(Class<FIRLibrary>)klass {
   45|      3|  static dispatch_once_t onceToken;
   46|      3|  dispatch_once(&onceToken, ^{
   47|      1|    sFIRComponentRegistrants = [[NSMutableSet<Class> alloc] init];
   48|      1|  });
   49|      3|
   50|      3|  [self registerAsComponentRegistrant:klass inSet:sFIRComponentRegistrants];
   51|      3|}
   52|       |
   53|       |+ (void)registerAsComponentRegistrant:(Class<FIRLibrary>)klass
   54|      3|                                inSet:(NSMutableSet<Class> *)allRegistrants {
   55|      3|  [allRegistrants addObject:klass];
   56|      3|}
   57|       |
   58|       |#pragma mark - Internal Initialization
   59|       |
   60|      1|- (instancetype)initWithApp:(FIRApp *)app {
   61|      1|  return [self initWithApp:app registrants:sFIRComponentRegistrants];
   62|      1|}
   63|       |
   64|      1|- (instancetype)initWithApp:(FIRApp *)app registrants:(NSMutableSet<Class> *)allRegistrants {
   65|      1|  self = [super init];
   66|      1|  if (self) {
   67|      1|    _app = app;
   68|      1|    _cachedInstances = [NSMutableDictionary<NSString *, id> dictionary];
   69|      1|    _components = [NSMutableDictionary<NSString *, FIRComponentCreationBlock> dictionary];
   70|      1|
   71|      1|    [self populateComponentsFromRegisteredClasses:allRegistrants forApp:app];
   72|      1|  }
   73|      1|  return self;
   74|      1|}
   75|       |
   76|      1|- (void)populateComponentsFromRegisteredClasses:(NSSet<Class> *)classes forApp:(FIRApp *)app {
   77|      1|  // Loop through the verified component registrants and populate the components array.
   78|      3|  for (Class<FIRLibrary> klass in classes) {
   79|      3|    // Loop through all the components being registered and store them as appropriate.
   80|      3|    // Classes which do not provide functionality should use a dummy FIRComponentRegistrant
   81|      3|    // protocol.
   82|      3|    for (FIRComponent *component in [klass componentsToRegister]) {
   83|      3|      // Check if the component has been registered before, and error out if so.
   84|      3|      NSString *protocolName = NSStringFromProtocol(component.protocol);
   85|      3|      if (self.components[protocolName]) {
   86|      0|        FIRLogError(kFIRLoggerCore, @"I-COR000029",
   87|      0|                    @"Attempted to register protocol %@, but it already has an implementation.",
   88|      0|                    protocolName);
   89|      0|        continue;
   90|      0|      }
   91|      3|
   92|      3|      // Store the creation block for later usage.
   93|      3|      self.components[protocolName] = component.creationBlock;
   94|      3|
   95|      3|      // Instantiate the
   96|      3|      BOOL shouldInstantiateEager =
   97|      3|          (component.instantiationTiming == FIRInstantiationTimingAlwaysEager);
   98|      3|      BOOL shouldInstantiateDefaultEager =
   99|      3|          (component.instantiationTiming == FIRInstantiationTimingEagerInDefaultApp &&
  100|      3|           [app isDefaultApp]);
  101|      3|      if (shouldInstantiateEager || shouldInstantiateDefaultEager) {
  102|      0|        [self instantiateInstanceForProtocol:component.protocol withBlock:component.creationBlock];
  103|      0|      }
  104|      3|    }
  105|      3|  }
  106|      1|}
  107|       |
  108|       |#pragma mark - Instance Creation
  109|       |
  110|       |/// Instantiate an instance of a class that conforms to the specified protocol.
  111|       |/// This will:
  112|       |///   - Call the block to create an instance if possible,
  113|       |///   - Validate that the instance returned conforms to the protocol it claims to,
  114|       |///   - Cache the instance if the block requests it
  115|       |- (nullable id)instantiateInstanceForProtocol:(Protocol *)protocol
  116|      2|                                    withBlock:(FIRComponentCreationBlock)creationBlock {
  117|      2|  if (!creationBlock) {
  118|      0|    return nil;
  119|      0|  }
  120|      2|
  121|      2|  // Create an instance using the creation block.
  122|      2|  BOOL shouldCache = NO;
  123|      2|  id instance = creationBlock(self, &shouldCache);
  124|      2|  if (!instance) {
  125|      0|    return nil;
  126|      0|  }
  127|      2|
  128|      2|  // An instance was created, validate that it conforms to the protocol it claims to.
  129|      2|  NSString *protocolName = NSStringFromProtocol(protocol);
  130|      2|  if (![instance conformsToProtocol:protocol]) {
  131|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000030",
  132|      0|                @"An instance conforming to %@ was requested, but the instance provided does not "
  133|      0|                @"conform to the protocol",
  134|      0|                protocolName);
  135|      0|  }
  136|      2|
  137|      2|  // The instance is ready to be returned, but check if it should be cached first before returning.
  138|      2|  if (shouldCache) {
  139|      2|    self.cachedInstances[protocolName] = instance;
  140|      2|  }
  141|      2|
  142|      2|  return instance;
  143|      2|}
  144|       |
  145|       |#pragma mark - Internal Retrieval
  146|       |
  147|      2|- (nullable id)instanceForProtocol:(Protocol *)protocol {
  148|      2|  // Check if there is a cached instance, and return it if so.
  149|      2|  NSString *protocolName = NSStringFromProtocol(protocol);
  150|      2|  id cachedInstance = self.cachedInstances[protocolName];
  151|      2|  if (cachedInstance) {
  152|      0|    return cachedInstance;
  153|      0|  }
  154|      2|
  155|      2|  // Use the creation block to instantiate an instance and return it.
  156|      2|  FIRComponentCreationBlock creationBlock = self.components[protocolName];
  157|      2|  return [self instantiateInstanceForProtocol:protocol withBlock:creationBlock];
  158|      2|}
  159|       |
  160|       |#pragma mark - Lifecycle
  161|       |
  162|      0|- (void)removeAllCachedInstances {
  163|      0|  // Loop through the cache and notify each instance that is a maintainer to clean up after itself.
  164|      0|  for (id instance in self.cachedInstances.allValues) {
  165|      0|    if ([instance conformsToProtocol:@protocol(FIRComponentLifecycleMaintainer)] &&
  166|      0|        [instance respondsToSelector:@selector(appWillBeDeleted:)]) {
  167|      0|      [instance appWillBeDeleted:self.app];
  168|      0|    }
  169|      0|  }
  170|      0|
  171|      0|  [self.cachedInstances removeAllObjects];
  172|      0|}
  173|       |
  174|       |@end
  175|       |
  176|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRComponentType.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "Private/FIRComponentType.h"
   18|       |
   19|       |#import "Private/FIRComponentContainerInternal.h"
   20|       |
   21|       |@implementation FIRComponentType
   22|       |
   23|      2|+ (id)instanceForProtocol:(Protocol *)protocol inContainer:(FIRComponentContainer *)container {
   24|      2|  // Forward the call to the container.
   25|      2|  return [container instanceForProtocol:protocol];
   26|      2|}
   27|       |
   28|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRConfiguration.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "FIRConfiguration.h"
   16|       |
   17|       |extern void FIRSetLoggerLevel(FIRLoggerLevel loggerLevel);
   18|       |
   19|       |@implementation FIRConfiguration
   20|       |
   21|      1|+ (instancetype)sharedInstance {
   22|      1|  static FIRConfiguration *sharedInstance = nil;
   23|      1|  static dispatch_once_t onceToken;
   24|      1|  dispatch_once(&onceToken, ^{
   25|      1|    sharedInstance = [[FIRConfiguration alloc] init];
   26|      1|  });
   27|      1|  return sharedInstance;
   28|      1|}
   29|       |
   30|      1|- (instancetype)init {
   31|      1|  self = [super init];
   32|      1|  if (self) {
   33|      1|    _analyticsConfiguration = [FIRAnalyticsConfiguration sharedInstance];
   34|      1|  }
   35|      1|  return self;
   36|      1|}
   37|       |
   38|      0|- (void)setLoggerLevel:(FIRLoggerLevel)loggerLevel {
   39|      0|  NSAssert(loggerLevel <= FIRLoggerLevelMax && loggerLevel >= FIRLoggerLevelMin,
   40|      0|           @"Invalid logger level, %ld", (long)loggerLevel);
   41|      0|  FIRSetLoggerLevel(loggerLevel);
   42|      0|}
   43|       |
   44|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRDependency.m:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |
   17|       |#import "Private/FIRDependency.h"
   18|       |
   19|       |@interface FIRDependency ()
   20|       |
   21|       |- (instancetype)initWithProtocol:(Protocol *)protocol isRequired:(BOOL)required;
   22|       |
   23|       |@end
   24|       |
   25|       |@implementation FIRDependency
   26|       |
   27|      0|+ (instancetype)dependencyWithProtocol:(Protocol *)protocol {
   28|      0|  return [[self alloc] initWithProtocol:protocol isRequired:YES];
   29|      0|}
   30|       |
   31|      0|+ (instancetype)dependencyWithProtocol:(Protocol *)protocol isRequired:(BOOL)required {
   32|      0|  return [[self alloc] initWithProtocol:protocol isRequired:required];
   33|      0|}
   34|       |
   35|      0|- (instancetype)initWithProtocol:(Protocol *)protocol isRequired:(BOOL)required {
   36|      0|  self = [super init];
   37|      0|  if (self) {
   38|      0|    _protocol = protocol;
   39|      0|    _isRequired = required;
   40|      0|  }
   41|      0|  return self;
   42|      0|}
   43|       |
   44|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIRLogger.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/FIRLogger.h"
   16|       |
   17|       |#import <FirebaseCore/FIRLoggerLevel.h>
   18|       |#import <GoogleUtilities/GULAppEnvironmentUtil.h>
   19|       |#import <GoogleUtilities/GULLogger.h>
   20|       |
   21|       |#import "Private/FIRVersion.h"
   22|       |
   23|       |FIRLoggerService kFIRLoggerABTesting = @"[Firebase/ABTesting]";
   24|       |FIRLoggerService kFIRLoggerAdMob = @"[Firebase/AdMob]";
   25|       |FIRLoggerService kFIRLoggerAnalytics = @"[Firebase/Analytics]";
   26|       |FIRLoggerService kFIRLoggerAuth = @"[Firebase/Auth]";
   27|       |FIRLoggerService kFIRLoggerCore = @"[Firebase/Core]";
   28|       |FIRLoggerService kFIRLoggerCrash = @"[Firebase/Crash]";
   29|       |FIRLoggerService kFIRLoggerDatabase = @"[Firebase/Database]";
   30|       |FIRLoggerService kFIRLoggerDynamicLinks = @"[Firebase/DynamicLinks]";
   31|       |FIRLoggerService kFIRLoggerFirestore = @"[Firebase/Firestore]";
   32|       |FIRLoggerService kFIRLoggerInstanceID = @"[Firebase/InstanceID]";
   33|       |FIRLoggerService kFIRLoggerInvites = @"[Firebase/Invites]";
   34|       |FIRLoggerService kFIRLoggerMLKit = @"[Firebase/MLKit]";
   35|       |FIRLoggerService kFIRLoggerMessaging = @"[Firebase/Messaging]";
   36|       |FIRLoggerService kFIRLoggerPerf = @"[Firebase/Performance]";
   37|       |FIRLoggerService kFIRLoggerRemoteConfig = @"[Firebase/RemoteConfig]";
   38|       |FIRLoggerService kFIRLoggerStorage = @"[Firebase/Storage]";
   39|       |FIRLoggerService kFIRLoggerSwizzler = @"[FirebaseSwizzlingUtilities]";
   40|       |
   41|       |/// Arguments passed on launch.
   42|       |NSString *const kFIRDisableDebugModeApplicationArgument = @"-FIRDebugDisabled";
   43|       |NSString *const kFIREnableDebugModeApplicationArgument = @"-FIRDebugEnabled";
   44|       |NSString *const kFIRLoggerForceSDTERRApplicationArgument = @"-FIRLoggerForceSTDERR";
   45|       |
   46|       |/// Key for the debug mode bit in NSUserDefaults.
   47|       |NSString *const kFIRPersistedDebugModeKey = @"/google/firebase/debug_mode";
   48|       |
   49|       |/// NSUserDefaults that should be used to store and read variables. If nil, `standardUserDefaults`
   50|       |/// will be used.
   51|       |static NSUserDefaults *sFIRLoggerUserDefaults;
   52|       |
   53|       |static dispatch_once_t sFIRLoggerOnceToken;
   54|       |
   55|       |// The sFIRAnalyticsDebugMode flag is here to support the -FIRDebugEnabled/-FIRDebugDisabled
   56|       |// flags used by Analytics. Users who use those flags expect Analytics to log verbosely,
   57|       |// while the rest of Firebase logs at the default level. This flag is introduced to support
   58|       |// that behavior.
   59|       |static BOOL sFIRAnalyticsDebugMode;
   60|       |
   61|       |#ifdef DEBUG
   62|       |/// The regex pattern for the message code.
   63|       |static NSString *const kMessageCodePattern = @"^I-[A-Z]{3}[0-9]{6}$";
   64|       |static NSRegularExpression *sMessageCodeRegex;
   65|       |#endif
   66|       |
   67|      7|void FIRLoggerInitializeASL() {
   68|      7|  dispatch_once(&sFIRLoggerOnceToken, ^{
   69|      1|    // Register Firebase Version with GULLogger.
   70|      1|    GULLoggerRegisterVersion(FIRVersionString);
   71|      1|
   72|      1|    // Override the aslOptions to ASL_OPT_STDERR if the override argument is passed in.
   73|      1|    NSArray *arguments = [NSProcessInfo processInfo].arguments;
   74|      1|    BOOL overrideSTDERR = [arguments containsObject:kFIRLoggerForceSDTERRApplicationArgument];
   75|      1|
   76|      1|    // Use the standard NSUserDefaults if it hasn't been explicitly set.
   77|      1|    if (sFIRLoggerUserDefaults == nil) {
   78|      1|      sFIRLoggerUserDefaults = [NSUserDefaults standardUserDefaults];
   79|      1|    }
   80|      1|
   81|      1|    BOOL forceDebugMode = NO;
   82|      1|    BOOL debugMode = [sFIRLoggerUserDefaults boolForKey:kFIRPersistedDebugModeKey];
   83|      1|    if ([arguments containsObject:kFIRDisableDebugModeApplicationArgument]) {  // Default mode
   84|      0|      [sFIRLoggerUserDefaults removeObjectForKey:kFIRPersistedDebugModeKey];
   85|      1|    } else if ([arguments containsObject:kFIREnableDebugModeApplicationArgument] ||
   86|      1|               debugMode) {  // Debug mode
   87|      0|      [sFIRLoggerUserDefaults setBool:YES forKey:kFIRPersistedDebugModeKey];
   88|      0|      forceDebugMode = YES;
   89|      0|    }
   90|      1|    GULLoggerInitializeASL();
   91|      1|    if (overrideSTDERR) {
   92|      0|      GULLoggerEnableSTDERR();
   93|      0|    }
   94|      1|    if (forceDebugMode) {
   95|      0|      GULLoggerForceDebug();
   96|      0|    }
   97|      1|  });
   98|      7|}
   99|       |
  100|      0|__attribute__((no_sanitize("thread"))) void FIRSetAnalyticsDebugMode(BOOL analyticsDebugMode) {
  101|      0|  sFIRAnalyticsDebugMode = analyticsDebugMode;
  102|      0|}
  103|       |
  104|      0|void FIRSetLoggerLevel(FIRLoggerLevel loggerLevel) {
  105|      0|  FIRLoggerInitializeASL();
  106|      0|  GULSetLoggerLevel((GULLoggerLevel)loggerLevel);
  107|      0|}
  108|       |
  109|       |#ifdef DEBUG
  110|      0|void FIRResetLogger() {
  111|      0|  extern void GULResetLogger(void);
  112|      0|  sFIRLoggerOnceToken = 0;
  113|      0|  [sFIRLoggerUserDefaults removeObjectForKey:kFIRPersistedDebugModeKey];
  114|      0|  sFIRLoggerUserDefaults = nil;
  115|      0|  GULResetLogger();
  116|      0|}
  117|       |
  118|      0|void FIRSetLoggerUserDefaults(NSUserDefaults *defaults) {
  119|      0|  sFIRLoggerUserDefaults = defaults;
  120|      0|}
  121|       |#endif
  122|       |
  123|       |/**
  124|       | * Check if the level is high enough to be loggable.
  125|       | *
  126|       | * Analytics can override the log level with an intentional race condition.
  127|       | * Add the attribute to get a clean thread sanitizer run.
  128|       | */
  129|       |__attribute__((no_sanitize("thread"))) BOOL FIRIsLoggableLevel(FIRLoggerLevel loggerLevel,
  130|      0|                                                               BOOL analyticsComponent) {
  131|      0|  FIRLoggerInitializeASL();
  132|      0|  if (sFIRAnalyticsDebugMode && analyticsComponent) {
  133|      0|    return YES;
  134|      0|  }
  135|      0|  return GULIsLoggableLevel((GULLoggerLevel)loggerLevel);
  136|      0|}
  137|       |
  138|       |void FIRLogBasic(FIRLoggerLevel level,
  139|       |                 FIRLoggerService service,
  140|       |                 NSString *messageCode,
  141|       |                 NSString *message,
  142|      7|                 va_list args_ptr) {
  143|      7|  FIRLoggerInitializeASL();
  144|      7|  GULLogBasic((GULLoggerLevel)level, service,
  145|      7|              sFIRAnalyticsDebugMode && [kFIRLoggerAnalytics isEqualToString:service], messageCode,
  146|      7|              message, args_ptr);
  147|      7|}
  148|       |
  149|       |/**
  150|       | * Generates the logging functions using macros.
  151|       | *
  152|       | * Calling FIRLogError(kFIRLoggerCore, @"I-COR000001", @"Configure %@ failed.", @"blah") shows:
  153|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Error> [Firebase/Core][I-COR000001] Configure blah failed.
  154|       | * Calling FIRLogDebug(kFIRLoggerCore, @"I-COR000001", @"Configure succeed.") shows:
  155|       | * yyyy-mm-dd hh:mm:ss.SSS sender[PID] <Debug> [Firebase/Core][I-COR000001] Configure succeed.
  156|       | */
  157|       |#define FIR_LOGGING_FUNCTION(level)                                                             \
  158|      2|  void FIRLog##level(FIRLoggerService service, NSString *messageCode, NSString *message, ...) { \
  159|      2|    va_list args_ptr;                                                                           \
  160|      2|    va_start(args_ptr, message);                                                                \
  161|      2|    FIRLogBasic(FIRLoggerLevel##level, service, messageCode, message, args_ptr);                \
  162|      2|    va_end(args_ptr);                                                                           \
  163|      2|  }
  ------------------
  | Unexecuted instantiation: FIRLogError
  ------------------
  | Unexecuted instantiation: FIRLogWarning
  ------------------
  | Unexecuted instantiation: FIRLogNotice
  ------------------
  | Unexecuted instantiation: FIRLogInfo
  ------------------
  | FIRLogDebug:
  |  158|      2|  void FIRLog##level(FIRLoggerService service, NSString *messageCode, NSString *message, ...) { \
  |  159|      2|    va_list args_ptr;                                                                           \
  |  160|      2|    va_start(args_ptr, message);                                                                \
  |  161|      2|    FIRLogBasic(FIRLoggerLevel##level, service, messageCode, message, args_ptr);                \
  |  162|      2|    va_end(args_ptr);                                                                           \
  |  163|      2|  }
  ------------------
  164|       |
  165|       |FIR_LOGGING_FUNCTION(Error)
  166|       |FIR_LOGGING_FUNCTION(Warning)
  167|       |FIR_LOGGING_FUNCTION(Notice)
  168|       |FIR_LOGGING_FUNCTION(Info)
  169|       |FIR_LOGGING_FUNCTION(Debug)
  170|       |
  171|       |#undef FIR_MAKE_LOGGER
  172|       |
  173|       |#pragma mark - FIRLoggerWrapper
  174|       |
  175|       |@implementation FIRLoggerWrapper
  176|       |
  177|       |+ (void)logWithLevel:(FIRLoggerLevel)level
  178|       |         withService:(FIRLoggerService)service
  179|       |            withCode:(NSString *)messageCode
  180|       |         withMessage:(NSString *)message
  181|      0|            withArgs:(va_list)args {
  182|      0|  FIRLogBasic(level, service, messageCode, message, args);
  183|      0|}
  184|       |
  185|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/FIROptions.m:
    1|       |// Copyright 2017 Google
    2|       |//
    3|       |// Licensed under the Apache License, Version 2.0 (the "License");
    4|       |// you may not use this file except in compliance with the License.
    5|       |// You may obtain a copy of the License at
    6|       |//
    7|       |//      http://www.apache.org/licenses/LICENSE-2.0
    8|       |//
    9|       |// Unless required by applicable law or agreed to in writing, software
   10|       |// distributed under the License is distributed on an "AS IS" BASIS,
   11|       |// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   12|       |// See the License for the specific language governing permissions and
   13|       |// limitations under the License.
   14|       |
   15|       |#import "Private/FIRAppInternal.h"
   16|       |#import "Private/FIRBundleUtil.h"
   17|       |#import "Private/FIRErrors.h"
   18|       |#import "Private/FIRLogger.h"
   19|       |#import "Private/FIROptionsInternal.h"
   20|       |
   21|       |// Keys for the strings in the plist file.
   22|       |NSString *const kFIRAPIKey = @"API_KEY";
   23|       |NSString *const kFIRTrackingID = @"TRACKING_ID";
   24|       |NSString *const kFIRGoogleAppID = @"GOOGLE_APP_ID";
   25|       |NSString *const kFIRClientID = @"CLIENT_ID";
   26|       |NSString *const kFIRGCMSenderID = @"GCM_SENDER_ID";
   27|       |NSString *const kFIRAndroidClientID = @"ANDROID_CLIENT_ID";
   28|       |NSString *const kFIRDatabaseURL = @"DATABASE_URL";
   29|       |NSString *const kFIRStorageBucket = @"STORAGE_BUCKET";
   30|       |// The key to locate the expected bundle identifier in the plist file.
   31|       |NSString *const kFIRBundleID = @"BUNDLE_ID";
   32|       |// The key to locate the project identifier in the plist file.
   33|       |NSString *const kFIRProjectID = @"PROJECT_ID";
   34|       |
   35|       |NSString *const kFIRIsMeasurementEnabled = @"IS_MEASUREMENT_ENABLED";
   36|       |NSString *const kFIRIsAnalyticsCollectionEnabled = @"FIREBASE_ANALYTICS_COLLECTION_ENABLED";
   37|       |NSString *const kFIRIsAnalyticsCollectionDeactivated = @"FIREBASE_ANALYTICS_COLLECTION_DEACTIVATED";
   38|       |
   39|       |NSString *const kFIRIsAnalyticsEnabled = @"IS_ANALYTICS_ENABLED";
   40|       |NSString *const kFIRIsSignInEnabled = @"IS_SIGNIN_ENABLED";
   41|       |
   42|       |// Library version ID.
   43|       |NSString *const kFIRLibraryVersionID = @"5"     // Major version (one or more digits)
   44|       |                                       @"02"    // Minor version (exactly 2 digits)
   45|       |                                       @"00"    // Build number (exactly 2 digits)
   46|       |                                       @"000";  // Fixed "000"
   47|       |// Plist file name.
   48|       |NSString *const kServiceInfoFileName = @"GoogleService-Info";
   49|       |// Plist file type.
   50|       |NSString *const kServiceInfoFileType = @"plist";
   51|       |
   52|       |// Exception raised from attempting to modify a FIROptions after it's been copied to a FIRApp.
   53|       |NSString *const kFIRExceptionBadModification =
   54|       |    @"Attempted to modify options after it's set on FIRApp. Please modify all properties before "
   55|       |    @"initializing FIRApp.";
   56|       |
   57|       |@interface FIROptions ()
   58|       |
   59|       |/**
   60|       | * This property maintains the actual configuration key-value pairs.
   61|       | */
   62|       |@property(nonatomic, readwrite) NSMutableDictionary *optionsDictionary;
   63|       |
   64|       |/**
   65|       | * Calls `analyticsOptionsDictionaryWithInfoDictionary:` using [NSBundle mainBundle].infoDictionary.
   66|       | * It combines analytics options from both the infoDictionary and the GoogleService-Info.plist.
   67|       | * Values which are present in the main plist override values from the GoogleService-Info.plist.
   68|       | */
   69|       |@property(nonatomic, readonly) NSDictionary *analyticsOptionsDictionary;
   70|       |
   71|       |/**
   72|       | * Combination of analytics options from both the infoDictionary and the GoogleService-Info.plist.
   73|       | * Values which are present in the infoDictionary override values from the GoogleService-Info.plist.
   74|       | */
   75|       |- (NSDictionary *)analyticsOptionsDictionaryWithInfoDictionary:(NSDictionary *)infoDictionary;
   76|       |
   77|       |/**
   78|       | * Throw exception if editing is locked when attempting to modify an option.
   79|       | */
   80|       |- (void)checkEditingLocked;
   81|       |
   82|       |@end
   83|       |
   84|       |@implementation FIROptions {
   85|       |  /// Backing variable for self.analyticsOptionsDictionary.
   86|       |  NSDictionary *_analyticsOptionsDictionary;
   87|       |}
   88|       |
   89|       |static FIROptions *sDefaultOptions = nil;
   90|       |static NSDictionary *sDefaultOptionsDictionary = nil;
   91|       |
   92|       |#pragma mark - Public only for internal class methods
   93|       |
   94|      1|+ (FIROptions *)defaultOptions {
   95|      1|  if (sDefaultOptions != nil) {
   96|      0|    return sDefaultOptions;
   97|      0|  }
   98|      1|
   99|      1|  NSDictionary *defaultOptionsDictionary = [self defaultOptionsDictionary];
  100|      1|  if (defaultOptionsDictionary == nil) {
  101|      0|    return nil;
  102|      0|  }
  103|      1|
  104|      1|  sDefaultOptions = [[FIROptions alloc] initInternalWithOptionsDictionary:defaultOptionsDictionary];
  105|      1|  return sDefaultOptions;
  106|      1|}
  107|       |
  108|       |#pragma mark - Private class methods
  109|       |
  110|      1|+ (void)initialize {
  111|      1|  // Report FirebaseCore version for useragent string
  112|      1|  NSRange major = NSMakeRange(0, 1);
  113|      1|  NSRange minor = NSMakeRange(1, 2);
  114|      1|  NSRange patch = NSMakeRange(3, 2);
  115|      1|  [FIRApp
  116|      1|      registerLibrary:@"fire-ios"
  117|      1|          withVersion:[NSString stringWithFormat:@"%@.%d.%d",
  118|      1|                                                 [kFIRLibraryVersionID substringWithRange:major],
  119|      1|                                                 [[kFIRLibraryVersionID substringWithRange:minor]
  120|      1|                                                     intValue],
  121|      1|                                                 [[kFIRLibraryVersionID substringWithRange:patch]
  122|      1|                                                     intValue]]];
  123|      1|  NSDictionary<NSString *, id> *info = [[NSBundle mainBundle] infoDictionary];
  124|      1|  NSString *xcodeVersion = info[@"DTXcodeBuild"];
  125|      1|  NSString *sdkVersion = info[@"DTSDKBuild"];
  126|      1|  if (xcodeVersion) {
  127|      1|    [FIRApp registerLibrary:@"xcode" withVersion:xcodeVersion];
  128|      1|  }
  129|      1|  if (sdkVersion) {
  130|      1|    [FIRApp registerLibrary:@"apple-sdk" withVersion:sdkVersion];
  131|      1|  }
  132|      1|}
  133|       |
  134|      2|+ (NSDictionary *)defaultOptionsDictionary {
  135|      2|  if (sDefaultOptionsDictionary != nil) {
  136|      1|    return sDefaultOptionsDictionary;
  137|      1|  }
  138|      1|  NSString *plistFilePath = [FIROptions plistFilePathWithName:kServiceInfoFileName];
  139|      1|  if (plistFilePath == nil) {
  140|      0|    return nil;
  141|      0|  }
  142|      1|  sDefaultOptionsDictionary = [NSDictionary dictionaryWithContentsOfFile:plistFilePath];
  143|      1|  if (sDefaultOptionsDictionary == nil) {
  144|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000011",
  145|      0|                @"The configuration file is not a dictionary: "
  146|      0|                @"'%@.%@'.",
  147|      0|                kServiceInfoFileName, kServiceInfoFileType);
  148|      0|  }
  149|      1|  return sDefaultOptionsDictionary;
  150|      1|}
  151|       |
  152|       |// Returns the path of the plist file with a given file name.
  153|      1|+ (NSString *)plistFilePathWithName:(NSString *)fileName {
  154|      1|  NSArray *bundles = [FIRBundleUtil relevantBundles];
  155|      1|  NSString *plistFilePath =
  156|      1|      [FIRBundleUtil optionsDictionaryPathWithResourceName:fileName
  157|      1|                                               andFileType:kServiceInfoFileType
  158|      1|                                                 inBundles:bundles];
  159|      1|  if (plistFilePath == nil) {
  160|      0|    FIRLogError(kFIRLoggerCore, @"I-COR000012", @"Could not locate configuration file: '%@.%@'.",
  161|      0|                fileName, kServiceInfoFileType);
  162|      0|  }
  163|      1|  return plistFilePath;
  164|      1|}
  165|       |
  166|      0|+ (void)resetDefaultOptions {
  167|      0|  sDefaultOptions = nil;
  168|      0|  sDefaultOptionsDictionary = nil;
  169|      0|}
  170|       |
  171|       |#pragma mark - Private instance methods
  172|       |
  173|      1|- (instancetype)initInternalWithOptionsDictionary:(NSDictionary *)optionsDictionary {
  174|      1|  self = [super init];
  175|      1|  if (self) {
  176|      1|    _optionsDictionary = [optionsDictionary mutableCopy];
  177|      1|    _usingOptionsFromDefaultPlist = YES;
  178|      1|  }
  179|      1|  return self;
  180|      1|}
  181|       |
  182|     13|- (id)copyWithZone:(NSZone *)zone {
  183|     13|  FIROptions *newOptions = [[[self class] allocWithZone:zone] init];
  184|     13|  if (newOptions) {
  185|     13|    newOptions.optionsDictionary = self.optionsDictionary;
  186|     13|    newOptions.deepLinkURLScheme = self.deepLinkURLScheme;
  187|     13|    newOptions.editingLocked = self.isEditingLocked;
  188|     13|    newOptions.usingOptionsFromDefaultPlist = self.usingOptionsFromDefaultPlist;
  189|     13|  }
  190|     13|  return newOptions;
  191|     13|}
  192|       |
  193|       |#pragma mark - Public instance methods
  194|       |
  195|      0|- (instancetype)initWithContentsOfFile:(NSString *)plistPath {
  196|      0|  self = [super init];
  197|      0|  if (self) {
  198|      0|    if (plistPath == nil) {
  199|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000013", @"The plist file path is nil.");
  200|      0|      return nil;
  201|      0|    }
  202|      0|    _optionsDictionary = [[NSDictionary dictionaryWithContentsOfFile:plistPath] mutableCopy];
  203|      0|    if (_optionsDictionary == nil) {
  204|      0|      FIRLogError(kFIRLoggerCore, @"I-COR000014",
  205|      0|                  @"The configuration file at %@ does not exist or "
  206|      0|                  @"is not a well-formed plist file.",
  207|      0|                  plistPath);
  208|      0|      return nil;
  209|      0|    }
  210|      0|    // TODO: Do we want to validate the dictionary here? It says we do that already in
  211|      0|    // the public header.
  212|      0|  }
  213|      0|  return self;
  214|      0|}
  215|       |
  216|      0|- (instancetype)initWithGoogleAppID:(NSString *)googleAppID GCMSenderID:(NSString *)GCMSenderID {
  217|      0|  self = [super init];
  218|      0|  if (self) {
  219|      0|    NSMutableDictionary *mutableOptionsDict = [NSMutableDictionary dictionary];
  220|      0|    [mutableOptionsDict setValue:googleAppID forKey:kFIRGoogleAppID];
  221|      0|    [mutableOptionsDict setValue:GCMSenderID forKey:kFIRGCMSenderID];
  222|      0|    [mutableOptionsDict setValue:[[NSBundle mainBundle] bundleIdentifier] forKey:kFIRBundleID];
  223|      0|    self.optionsDictionary = mutableOptionsDict;
  224|      0|  }
  225|      0|  return self;
  226|      0|}
  227|       |
  228|      1|- (NSString *)APIKey {
  229|      1|  return self.optionsDictionary[kFIRAPIKey];
  230|      1|}
  231|       |
  232|     13|- (void)checkEditingLocked {
  233|     13|  if (self.isEditingLocked) {
  234|      0|    [NSException raise:kFirebaseCoreErrorDomain format:kFIRExceptionBadModification];
  235|      0|  }
  236|     13|}
  237|       |
  238|      0|- (void)setAPIKey:(NSString *)APIKey {
  239|      0|  [self checkEditingLocked];
  240|      0|  _optionsDictionary[kFIRAPIKey] = [APIKey copy];
  241|      0|}
  242|       |
  243|      0|- (NSString *)clientID {
  244|      0|  return self.optionsDictionary[kFIRClientID];
  245|      0|}
  246|       |
  247|      0|- (void)setClientID:(NSString *)clientID {
  248|      0|  [self checkEditingLocked];
  249|      0|  _optionsDictionary[kFIRClientID] = [clientID copy];
  250|      0|}
  251|       |
  252|      0|- (NSString *)trackingID {
  253|      0|  return self.optionsDictionary[kFIRTrackingID];
  254|      0|}
  255|       |
  256|      0|- (void)setTrackingID:(NSString *)trackingID {
  257|      0|  [self checkEditingLocked];
  258|      0|  _optionsDictionary[kFIRTrackingID] = [trackingID copy];
  259|      0|}
  260|       |
  261|      1|- (NSString *)GCMSenderID {
  262|      1|  return self.optionsDictionary[kFIRGCMSenderID];
  263|      1|}
  264|       |
  265|      0|- (void)setGCMSenderID:(NSString *)GCMSenderID {
  266|      0|  [self checkEditingLocked];
  267|      0|  _optionsDictionary[kFIRGCMSenderID] = [GCMSenderID copy];
  268|      0|}
  269|       |
  270|      0|- (NSString *)projectID {
  271|      0|  return self.optionsDictionary[kFIRProjectID];
  272|      0|}
  273|       |
  274|      0|- (void)setProjectID:(NSString *)projectID {
  275|      0|  [self checkEditingLocked];
  276|      0|  _optionsDictionary[kFIRProjectID] = [projectID copy];
  277|      0|}
  278|       |
  279|      0|- (NSString *)androidClientID {
  280|      0|  return self.optionsDictionary[kFIRAndroidClientID];
  281|      0|}
  282|       |
  283|      0|- (void)setAndroidClientID:(NSString *)androidClientID {
  284|      0|  [self checkEditingLocked];
  285|      0|  _optionsDictionary[kFIRAndroidClientID] = [androidClientID copy];
  286|      0|}
  287|       |
  288|      7|- (NSString *)googleAppID {
  289|      7|  return self.optionsDictionary[kFIRGoogleAppID];
  290|      7|}
  291|       |
  292|      0|- (void)setGoogleAppID:(NSString *)googleAppID {
  293|      0|  [self checkEditingLocked];
  294|      0|  _optionsDictionary[kFIRGoogleAppID] = [googleAppID copy];
  295|      0|}
  296|       |
  297|      1|- (NSString *)libraryVersionID {
  298|      1|  return kFIRLibraryVersionID;
  299|      1|}
  300|       |
  301|      0|- (void)setLibraryVersionID:(NSString *)libraryVersionID {
  302|      0|  _optionsDictionary[kFIRLibraryVersionID] = [libraryVersionID copy];
  303|      0|}
  304|       |
  305|      0|- (NSString *)databaseURL {
  306|      0|  return self.optionsDictionary[kFIRDatabaseURL];
  307|      0|}
  308|       |
  309|      0|- (void)setDatabaseURL:(NSString *)databaseURL {
  310|      0|  [self checkEditingLocked];
  311|      0|
  312|      0|  _optionsDictionary[kFIRDatabaseURL] = [databaseURL copy];
  313|      0|}
  314|       |
  315|      0|- (NSString *)storageBucket {
  316|      0|  return self.optionsDictionary[kFIRStorageBucket];
  317|      0|}
  318|       |
  319|      0|- (void)setStorageBucket:(NSString *)storageBucket {
  320|      0|  [self checkEditingLocked];
  321|      0|  _optionsDictionary[kFIRStorageBucket] = [storageBucket copy];
  322|      0|}
  323|       |
  324|     13|- (void)setDeepLinkURLScheme:(NSString *)deepLinkURLScheme {
  325|     13|  [self checkEditingLocked];
  326|     13|  _deepLinkURLScheme = [deepLinkURLScheme copy];
  327|     13|}
  328|       |
  329|      3|- (NSString *)bundleID {
  330|      3|  return self.optionsDictionary[kFIRBundleID];
  331|      3|}
  332|       |
  333|      0|- (void)setBundleID:(NSString *)bundleID {
  334|      0|  [self checkEditingLocked];
  335|      0|  _optionsDictionary[kFIRBundleID] = [bundleID copy];
  336|      0|}
  337|       |
  338|       |#pragma mark - Internal instance methods
  339|       |
  340|      5|- (NSDictionary *)analyticsOptionsDictionaryWithInfoDictionary:(NSDictionary *)infoDictionary {
  341|      5|  if (_analyticsOptionsDictionary == nil) {
  342|      1|    NSMutableDictionary *tempAnalyticsOptions = [[NSMutableDictionary alloc] init];
  343|      1|    NSArray *measurementKeys = @[
  344|      1|      kFIRIsMeasurementEnabled, kFIRIsAnalyticsCollectionEnabled,
  345|      1|      kFIRIsAnalyticsCollectionDeactivated
  346|      1|    ];
  347|      3|    for (NSString *key in measurementKeys) {
  348|      3|      id value = infoDictionary[key] ?: self.optionsDictionary[key] ?: nil;
  349|      3|      if (!value) {
  350|      3|        continue;
  351|      3|      }
  352|      0|      tempAnalyticsOptions[key] = value;
  353|      0|    }
  354|      1|    _analyticsOptionsDictionary = tempAnalyticsOptions;
  355|      1|  }
  356|      5|  return _analyticsOptionsDictionary;
  357|      5|}
  358|       |
  359|      5|- (NSDictionary *)analyticsOptionsDictionary {
  360|      5|  return [self analyticsOptionsDictionaryWithInfoDictionary:[NSBundle mainBundle].infoDictionary];
  361|      5|}
  362|       |
  363|       |/**
  364|       | * Whether or not Measurement was enabled. Measurement is enabled unless explicitly disabled in
  365|       | * GoogleService-Info.plist. This uses the old plist flag IS_MEASUREMENT_ENABLED, which should still
  366|       | * be supported.
  367|       | */
  368|      1|- (BOOL)isMeasurementEnabled {
  369|      1|  if (self.isAnalyticsCollectionDeactivated) {
  370|      0|    return NO;
  371|      0|  }
  372|      1|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsMeasurementEnabled];
  373|      1|  if (value == nil) {
  374|      1|    // TODO: This could probably be cleaned up since FIROptions shouldn't know about FIRApp or have
  375|      1|    //       to check if it's the default app. The FIROptions instance can't be modified after
  376|      1|    //       `+configure` is called, so it's not a good place to copy it either in case the flag is
  377|      1|    //       changed at runtime.
  378|      1|
  379|      1|    // If no values are set for Analytics, fall back to the global collection switch in FIRApp.
  380|      1|    // Analytics only supports the default FIRApp, so check that first.
  381|      1|    if (![FIRApp isDefaultAppConfigured]) {
  382|      0|      return NO;
  383|      0|    }
  384|      1|
  385|      1|    // Fall back to the default app's collection switch when the key is not in the dictionary.
  386|      1|    return [FIRApp defaultApp].isDataCollectionDefaultEnabled;
  387|      1|  }
  388|      0|  return [value boolValue];
  389|      0|}
  390|       |
  391|      0|- (BOOL)isAnalyticsCollectionExpicitlySet {
  392|      0|  // If it's de-activated, it classifies as explicity set. If not, it's not a good enough indication
  393|      0|  // that the developer wants FirebaseAnalytics enabled so continue checking.
  394|      0|  if (self.isAnalyticsCollectionDeactivated) {
  395|      0|    return YES;
  396|      0|  }
  397|      0|
  398|      0|  // Check if the current Analytics flag is set.
  399|      0|  id collectionEnabledObject = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionEnabled];
  400|      0|  if (collectionEnabledObject && [collectionEnabledObject isKindOfClass:[NSNumber class]]) {
  401|      0|    // It doesn't matter what the value is, it's explicitly set.
  402|      0|    return YES;
  403|      0|  }
  404|      0|
  405|      0|  // Check if the old measurement flag is set.
  406|      0|  id measurementEnabledObject = self.analyticsOptionsDictionary[kFIRIsMeasurementEnabled];
  407|      0|  if (measurementEnabledObject && [measurementEnabledObject isKindOfClass:[NSNumber class]]) {
  408|      0|    // It doesn't matter what the value is, it's explicitly set.
  409|      0|    return YES;
  410|      0|  }
  411|      0|
  412|      0|  // No flags are set to explicitly enable or disable FirebaseAnalytics.
  413|      0|  return NO;
  414|      0|}
  415|       |
  416|      1|- (BOOL)isAnalyticsCollectionEnabled {
  417|      1|  if (self.isAnalyticsCollectionDeactivated) {
  418|      0|    return NO;
  419|      0|  }
  420|      1|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionEnabled];
  421|      1|  if (value == nil) {
  422|      1|    return self.isMeasurementEnabled;  // Fall back to older plist flag.
  423|      1|  }
  424|      0|  return [value boolValue];
  425|      0|}
  426|       |
  427|      3|- (BOOL)isAnalyticsCollectionDeactivated {
  428|      3|  NSNumber *value = self.analyticsOptionsDictionary[kFIRIsAnalyticsCollectionDeactivated];
  429|      3|  if (value == nil) {
  430|      3|    return NO;  // Analytics Collection is not deactivated when the key is not in the dictionary.
  431|      3|  }
  432|      0|  return [value boolValue];
  433|      0|}
  434|       |
  435|      0|- (BOOL)isAnalyticsEnabled {
  436|      0|  return [self.optionsDictionary[kFIRIsAnalyticsEnabled] boolValue];
  437|      0|}
  438|       |
  439|      0|- (BOOL)isSignInEnabled {
  440|      0|  return [self.optionsDictionary[kFIRIsSignInEnabled] boolValue];
  441|      0|}
  442|       |
  443|       |@end

/Users/DDube/Developer/iOS/Songhound/Pods/FirebaseCore/Firebase/Core/Private/FIRComponentContainer.h:
    1|       |/*
    2|       | * Copyright 2018 Google
    3|       | *
    4|       | * Licensed under the Apache License, Version 2.0 (the "License");
    5|       | * you may not use this file except in compliance with the License.
    6|       | * You may obtain a copy of the License at
    7|       | *
    8|       | *      http://www.apache.org/licenses/LICENSE-2.0
    9|       | *
   10|       | * Unless required by applicable law or agreed to in writing, software
   11|       | * distributed under the License is distributed on an "AS IS" BASIS,
   12|       | * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   13|       | * See the License for the specific language governing permissions and
   14|       | * limitations under the License.
   15|       | */
   16|       |#import <Foundation/Foundation.h>
   17|       |
   18|       |#import "FIRComponentType.h"
   19|       |#import "FIRLibrary.h"
   20|       |
   21|       |NS_ASSUME_NONNULL_BEGIN
   22|       |
   23|       |/// A type-safe macro to retrieve a component from a container. This should be used to retrieve
   24|       |/// components instead of using the container directly.
   25|       |#define FIR_COMPONENT(type, container) \
   26|      1|  [FIRComponentType<id<type>> instanceForProtocol:@protocol(type) inContainer:container]
   27|       |
   28|       |@class FIRApp;
   29|       |
   30|       |/// A container that holds different components that are registered via the
   31|       |/// `registerAsComponentRegistrant:` call. These classes should conform to `FIRComponentRegistrant`
   32|       |/// in order to properly register components for Core.
   33|       |NS_SWIFT_NAME(FirebaseComponentContainer)
   34|       |@interface FIRComponentContainer : NSObject
   35|       |
   36|       |/// A weak reference to the app that an instance of the container belongs to.
   37|       |@property(nonatomic, weak, readonly) FIRApp *app;
   38|       |
   39|       |/// Unavailable. Use the `container` property on `FIRApp`.
   40|       |- (instancetype)init NS_UNAVAILABLE;
   41|       |
   42|       |@end
   43|       |
   44|       |NS_ASSUME_NONNULL_END

/Users/DDube/Developer/iOS/Songhound/Songhound/AppDelegate.swift:
    1|       |//
    2|       |//  AppDelegate.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/15.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import GoogleMaps
   11|       |import Firebase
   12|       |import GoogleSignIn
   13|       |
   14|       |
   15|       |@UIApplicationMain
   16|       |class AppDelegate: UIResponder, UIApplicationDelegate  {
   17|       |
   18|       |    var window: UIWindow?
   19|       |
   20|      1|    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
   21|      1|        // Override point for customization after application launch.
   22|      1|
   23|      1|        // My personal key to access the maps service
   24|      1|        GMSServices.provideAPIKey("AIzaSyBqwX1XCTzvEdNZH-WydmpTf3dVgUgUhes")
   25|      1|        GIDSignIn.sharedInstance().clientID = "288110944258-ridgqi0r03ttme394kd3ch2s7toggpa9.apps.googleusercontent.com"
   26|      1|       
   27|      1|        // activate firebase core
   28|      1|        FirebaseApp.configure()
   29|      1|        
   30|      1|        // init our 
   31|      1|        let songsList = SongsListWireFrame.createSongsListModule()
   32|      1|        // I guess this is where we set the windows size when we open apps for iPhone on iPad ie. Instagram
   33|      1|        window = UIWindow(frame: UIScreen.main.bounds)
   34|      1|        window?.rootViewController =  songsList
   35|      1|        // what is a key window is it the laucher screen?
   36|      1|        window?.makeKeyAndVisible()
   37|      1|        return true
   38|      1|    }
   39|       |
   40|      0|    func  application(_ app: UIApplication, open url: URL,  options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
   41|      0|        return GIDSignIn.sharedInstance().handle(url as URL?, sourceApplication: options[UIApplication.OpenURLOptionsKey.sourceApplication] as? String,
   42|      0|                annotation: options[UIApplication.OpenURLOptionsKey.annotation])
   43|      0|    }
   44|       |
   45|       |
   46|      0|    func applicationWillResignActive(_ application: UIApplication) {
   47|      0|        // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
   48|      0|        // Use this method to pause ongoing tasks, disable timers, and invalidate graphics rendering callbacks. Games should use this method to pause the game.
   49|      0|    }
   50|       |
   51|      0|    func applicationDidEnterBackground(_ application: UIApplication) {
   52|      0|        // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
   53|      0|        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
   54|      0|    }
   55|       |
   56|      0|    func applicationWillEnterForeground(_ application: UIApplication) {
   57|      0|        // Called as part of the transition from the background to the active state; here you can undo many of the changes made on entering the background.
   58|      0|    }
   59|       |
   60|      1|    func applicationDidBecomeActive(_ application: UIApplication) {
   61|      1|        // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
   62|      1|    }
   63|       |
   64|      0|    func applicationWillTerminate(_ application: UIApplication) {
   65|      0|        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
   66|      0|    }
   67|       |
   68|       |
   69|       |}
   70|       |

/Users/DDube/Developer/iOS/Songhound/Songhound/ArtistsSongsList/DataManager/Remote/ArtistsSongsListRemoteDataManager .swift:
    1|       |//
    2|       |//  ArtistsSongsListRemoteDataManager .swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/06.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Alamofire
   11|       |import AlamofireObjectMapper
   12|       |
   13|       |class ArtistsSongsListRemoteDataManager: ArtistListRemoteDataManagerInputProtocol  {
   14|       |    var remoteRequestHandler: ArtistSongsListDataManagerOutputProtocol?
   15|       |    
   16|      0|    func retriveSongsList() {
   17|      0|        let artistName = ""
   18|      0|        Alamofire
   19|      0|            .request(Endpoints.Songs.fetch(songName: artistName).url, method: .get)
   20|      0|            .responseObject { (response: DataResponse<SongModelResponse>) in
   21|      0|                switch response.result {
   22|      0|                case .success(let res):
   23|      0|                    let songs = res.songs!
   24|      0|                    self.remoteRequestHandler?.onArtistSongsListRetrieved(songs)
   25|      0|                case .failure(let error):
   26|      0|                    print(error)
   27|      0|                }
   28|      0|        }
   29|      0|    }
   30|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/ArtistsSongsList/Interactor/ArtistSongsListInteractor.swift:
    1|       |//
    2|       |//  ArtistSongsListInteractor.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/06.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |// this does all the busines logic of our APP
   12|       |class ArtistSongsListInteractor : ArtistSongsListViewInteractorInputProtocol {
   13|       |   
   14|       |    var presenter: ArtistSongsListViewInteractorOutputProtocol?
   15|       |    var remoteDataManager: ArtistListRemoteDataManagerInputProtocol?
   16|       |    
   17|      0|    func retriveSongsList() {
   18|      0|        // no logic here yet
   19|      0|        // just calling the remote data manager to fetch the data
   20|      0|        
   21|      0|         remoteDataManager?.retriveSongsList()
   22|      0|        
   23|      0|    }
   24|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/ArtistsSongsList/Presenter/ArtistSongListViewPresenter.swift:
    1|       |//
    2|       |//  ArtistSongListViewPresenter.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/04.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |class ArtistSongListViewPresenter: ArtistSongsListViewPresenterProtocol {
   12|       |    var view: ArtistsListViewProtocol?
   13|       |    var interactor: ArtistSongsListViewInteractorInputProtocol?
   14|       |    var wireFrame: ArtistsListViewWireFrameProtocol?
   15|       |    var artist: ArtistModel?
   16|       |
   17|       |    // begin genesis
   18|      0|    func viewDidLoad() {
   19|      0|        view?.showLoading(forArtist: artist!)
   20|      0|        interactor?.retriveSongsList()
   21|      0|    }
   22|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/ArtistsSongsList/View/ArtistTableViewCell.swift:
    1|       |//
    2|       |//  ArtistTableViewCell.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/19.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class ArtistTableViewCell: UITableViewCell {
   12|       |    @IBOutlet weak var lblArtistName: UILabel!
   13|       |    
   14|       |    @IBOutlet weak var lblEmoji: UILabel!
   15|       |    @IBOutlet weak var lblNumHits: UILabel!
   16|       |    @IBOutlet weak var imgArtist: UIImageView!
   17|       |    
   18|      0|    override func awakeFromNib() {
   19|      0|        super.awakeFromNib()
   20|      0|        // Initialization code
   21|      0|        
   22|      0|//        lblEmoji.text = "🔥"
   23|      0|        makeUIImageViewCircle(imageView: imgArtist, imgSize: 40)
   24|      0|        
   25|      0|        
   26|      0|    }
   27|       |
   28|      0|    override func setSelected(_ selected: Bool, animated: Bool) {
   29|      0|        super.setSelected(selected, animated: animated)
   30|      0|
   31|      0|        // Configure the view for the selected state
   32|      0|    }
   33|       |
   34|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/ArtistsSongsList/View/ArtistsListViewController.swift:
    1|       |//
    2|       |//  ArtistsListViewController.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/04.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import PKHUD
   11|       |
   12|       |class ArtistsListViewController: UIViewController {
   13|       |
   14|       |    @IBOutlet weak var songsTableView: UITableView!
   15|       |    @IBOutlet weak var artistName: UILabel!
   16|       |    
   17|       |    var songList: [SongModel] = []
   18|       |    
   19|       |    var presenter: ArtistSongsListViewPresenterProtocol?
   20|       |    
   21|      0|    override func viewDidLoad() {
   22|      0|        super.viewDidLoad()
   23|      0|        presenter?.viewDidLoad()
   24|      0|       // songsTableView.footerView = UIView()
   25|      0|
   26|      0|        // Do any additional setup after loading the view.
   27|      0|    }
   28|       |}
   29|       |
   30|       |extension ArtistsListViewController: ArtistsListViewProtocol {
   31|       |
   32|      0|    func showSongs(with songs: [SongModel]) {
   33|      0|        songList = songs
   34|      0|        self.songsTableView.reloadData()
   35|      0|    }
   36|       |    
   37|      0|    func showLoading(forArtist artist: ArtistModel) {
   38|      0|        HUD.show(.progress)
   39|      0|        self.artistName.text = artist.name
   40|      0|    }
   41|       |    
   42|       |    // they should be refactored to another page
   43|      0|    func showError() {
   44|      0|        HUD.flash(.label("Internet not connect"), delay: 2.0)
   45|      0|    }
   46|       |    
   47|      0|    func hideLoading() {
   48|      0|        HUD.hide()
   49|      0|    }
   50|       |}
   51|       |
   52|       |extension ArtistsListViewController:  UITableViewDataSource, UITableViewDelegate {
   53|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   54|      0|        return songList.count
   55|      0|    }
   56|       |    
   57|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   58|      0|        let cell = self.songsTableView.dequeueReusableCell(withIdentifier: "songCell", for: indexPath) as! SongTableViewCell
   59|      0|        let song = songList[indexPath.row]
   60|      0|        cell.set(forSong: song)
   61|      0|        return cell
   62|      0|    }
   63|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/ArtistsSongsList/View/TopSongsByArtistViewController.swift:
    1|       |//
    2|       |//  TopSongsByArtistViewController.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/18.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class TopSongsByArtistViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, UISearchBarDelegate {
   12|       |    
   13|       |    @IBOutlet weak var artistsTableView: UITableView!
   14|       |    @IBOutlet weak var searchBar: UISearchBar!
   15|       |    
   16|       |    var artists: [Artist] = []
   17|       |    
   18|      0|    override func viewDidLoad() {
   19|      0|        super.viewDidLoad()
   20|      0|
   21|      0|        self.artistsTableView.delegate = self
   22|      0|        self.artistsTableView.dataSource = self
   23|      0|        self.searchBar.delegate = self
   24|      0|
   25|      0|        // Do any additional setup after loading the view.
   26|      0|    }
   27|       |
   28|       |    
   29|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   30|      0|        return artists.count
   31|      0|    }
   32|       |    
   33|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   34|      0|        let cell = self.artistsTableView.dequeueReusableCell(withIdentifier: "artistTableViewCell", for: indexPath) as! ArtistTableViewCell
   35|      0|        
   36|      0|        cell.lblArtistName.text = artists[indexPath.row].name
   37|      0|        //cell.lblNumHits.text = "\(artists[indexPath.row].numHits) hot songs"
   38|      0|      //  let str = artists[indexPath.row].isHot ? "🔥" :  "";
   39|      0|      //  cell.lblEmoji.text = str
   40|      0|        
   41|      0|//        cell.imgArtist. = // set the artist image 
   42|      0|        
   43|      0|        return cell
   44|      0|    }
   45|       |
   46|      0|    @IBAction func onBackButtonClick(_ sender: UIButton) {
   47|      0|        dismiss(animated: true, completion: nil)
   48|      0|    }
   49|       |    
   50|      0|    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
   51|      0|        print("clicked bro")
   52|      0|        performSegue(withIdentifier: "viewSongsOfArtist", sender: self )
   53|      0|    }
   54|       |    
   55|      0|    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
   56|      0|        print("called bro")
   57|      0|        if segue.identifier == "viewSongsOfArtist" {
   58|      0|            if let indexPath = self.artistsTableView.indexPathForSelectedRow {
   59|      0|                let controller = segue.destination as! SongsViewController
   60|      0|                controller.artist = artists[indexPath.row]
   61|      0|            }
   62|      0|        }
   63|      0|    }
   64|       |
   65|      0|    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
   66|      0|        // bad code!!!
   67|      0|        if !searchText.isEmpty {
   68|      0|            artists = artists.filter { (artist: Artist) -> Bool in
   69|      0|                return artist.name.range(of: searchText, options: .caseInsensitive, range: nil, locale: nil) != nil
   70|      0|            }
   71|      0|        } else {
   72|      0|           // populateArtists()
   73|      0|        }
   74|      0|
   75|      0|        artistsTableView.reloadData()
   76|      0|    }
   77|       |
   78|      0|    func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) {
   79|      0|        self.searchBar.showsCancelButton = true
   80|      0|    }
   81|       |
   82|      0|    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {
   83|      0|        searchBar.showsCancelButton = false
   84|      0|        searchBar.text = ""
   85|      0|        searchBar.resignFirstResponder()
   86|      0|        //populateArtists()
   87|      0|    }
   88|       |
   89|       |    /*
   90|       |    // MARK: - Navigation
   91|       |
   92|       |    // In a storyboard-based application, you will often want to do a little preparation before navigation
   93|       |    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
   94|       |        // Get the new view controller using segue.destination.
   95|       |        // Pass the selected object to the new view controller.
   96|       |    }
   97|       |    */
   98|       |
   99|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/ArtistsSongsList/WireFrame/ArtistsListViewWireFrame.swift:
    1|       |//
    2|       |//  ArtistsSongsListViewWireFrame.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/04.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |class ArtistsListViewWireFrame: ArtistsListViewWireFrameProtocol {
   13|      0|    class func createArtistListViewModule(forArtist artist: ArtistModel) -> UIViewController {
   14|      0|        let viewController = mainStoryboard.instantiateViewController(withIdentifier: "ArtistListViewController")
   15|      0|        
   16|      0|        if let view = viewController as? ArtistsListViewController {
   17|      0|            var presenter: ArtistSongsListViewPresenterProtocol = ArtistSongListViewPresenter()
   18|      0|            let wireframe: ArtistsListViewWireFrameProtocol = ArtistsListViewWireFrame()
   19|      0|            
   20|      0|            view.presenter = presenter
   21|      0|            presenter.view = view
   22|      0|            presenter.artist = artist
   23|      0|            presenter.wireFrame = wireframe
   24|      0|            
   25|      0|            return viewController
   26|      0|            
   27|      0|        }
   28|      0|        return UIViewController()
   29|      0|    }
   30|       |    
   31|       |    
   32|       |    
   33|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/Common/Endpoints.swift:
    1|       |//
    2|       |//  Endpoints.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/02.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |struct API {
   12|       |    static let baseURL = "https://itunes.apple.com/search?media=music&entity=song"
   13|       |}
   14|       |
   15|       |// this is the structure of how a any url should look like
   16|       |protocol Endpoint {
   17|       |    var path: String { get }
   18|       |    var url: String { get }
   19|       |}
   20|       |
   21|       |// these are all my end points
   22|       |enum Endpoints {
   23|       |    enum Songs: Endpoint {
   24|       |        case fetch(songName: String)
   25|       |
   26|       |        // these are functions of this enum!
   27|      1|        public var path: String {
   28|      1|            switch self {
   29|      1|             case .fetch(let songName): return "&term=\(songName)"
   30|      1|            }
   31|      1|        }
   32|       |
   33|      1|        public var url: String {
   34|      1|            switch self {
   35|      1|             case .fetch: return "\(API.baseURL)\(path)"
   36|      1|            }
   37|      1|        }
   38|       |
   39|       |    }
   40|       |}
   41|       |

/Users/DDube/Developer/iOS/Songhound/Songhound/Common/Extensions.swift:
    1|       |//
    2|       |//  Extensions.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/01.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |//TODO do documantation commantring stsyle bro
   12|       |/*
   13|       |    this asyncrouly download the image from the server
   14|       | */
   15|       |extension UIImageView {
   16|     10|    func dowloadFromServer(url: URL, contentMode mode: UIView.ContentMode = .scaleAspectFit) {
   17|     10|        contentMode = mode
   18|     10|        URLSession.shared.dataTask(with: url) { data, response, error in
   19|     10|            guard
   20|     10|                let httpURLResponse = response as? HTTPURLResponse, httpURLResponse.statusCode == 200,
   21|     10|                let mimeType = response?.mimeType, mimeType.hasPrefix("image"),
   22|     10|                let data = data, error == nil,
   23|     10|                let image = UIImage(data: data)
   24|     10|                else { return }
   25|     10|            DispatchQueue.main.async() {
   26|     10|                self.image = image
   27|     10|            }
   28|     10|        }.resume()
   29|     10|    }
   30|     10|    func dowloadFromServer(link: String, contentMode mode: UIView.ContentMode = .scaleAspectFit) {
   31|     10|        guard let url = URL(string: link) else { return }
   32|     10|        dowloadFromServer(url: url, contentMode: mode)
   33|     10|    }
   34|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/Common/RESTClient.swift:
    1|       |//
    2|       |// Created by Divine Dube on 2019-02-25.
    3|       |// Copyright (c) 2019 Divine Dube. All rights reserved.
    4|       |//
    5|       |
    6|       |
    7|       |import Alamofire
    8|       |import SwiftyJSON
    9|       |
   10|       |fileprivate let BASE_URL = "https://itunes.apple.com/search?media=music&entity=song"
   11|       |
   12|      0|func getArtist(songId: Int) {
   13|      0|    
   14|      0|}
   15|       |
   16|      0|func getTopSongs(response: @escaping (_ songs: [Song]) -> Void) {
   17|      0|    
   18|      0|}
   19|       |
   20|       |// return an array of songs
   21|      0|func searchForSongByArtist(songName: String, callback: @escaping (_ songs: [Song]) -> Void) {
   22|      0|    var songs: [Song] = []
   23|      0|    Alamofire.request(BASE_URL + "&term=\(songName)")
   24|      0|        .responseJSON(completionHandler: { response in
   25|      0|            switch response.result {
   26|      0|            case .success(let json):
   27|      0|                let resArray = JSON(json)["results"] // fix this line looks bad
   28|      0|                for i in 0...50 {
   29|      0|                    let artistName = resArray[i]["artistName"].stringValue
   30|      0|                    let albumName = resArray[i]["collectionName"].stringValue
   31|      0|                    let trackName = resArray[i]["trackName"].stringValue
   32|      0|                    let artworkURL = resArray[i]["artworkUrl100"].stringValue
   33|      0|                    let genre = resArray[i]["primaryGenreName"].stringValue
   34|      0|                    let song = Song(name: trackName, artistName: artistName, genre: genre, popularity: 10, albumName: albumName, artworkURL: artworkURL)
   35|      0|                    
   36|      0|                    songs.append(song)
   37|      0|                }
   38|      0|                print("the json response from apple is \(response)")
   39|      0|                callback(songs)
   40|      0|                
   41|      0|            case .failure(let error):
   42|      0|                print(error)
   43|      0|            }
   44|      0|        })
   45|      0|}
   46|       |
   47|      0|func searchAlbumCoverFromMusicBrainz(songName: String) {
   48|      0|    
   49|      0|}

/Users/DDube/Developer/iOS/Songhound/Songhound/Common/SongTableViewCell.swift:
    1|       |//
    2|       |//  SongTableViewCell.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/18.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class SongTableViewCell: UITableViewCell {
   12|       |    
   13|       |
   14|       |    @IBOutlet weak var lblSongName: UILabel!
   15|       |    @IBOutlet weak var lblArtistName: UILabel!
   16|       |    @IBOutlet weak var lblAlbumName: UILabel!
   17|       |    @IBOutlet weak var lblGenre: UILabel!
   18|       |    @IBOutlet weak var imgAlbumCover: UIImageView!
   19|       |    
   20|       |    
   21|     10|    override func awakeFromNib() {
   22|     10|        super.awakeFromNib()
   23|     10|        // Initialization code
   24|     10|    }
   25|       |
   26|     10|    override func setSelected(_ selected: Bool, animated: Bool) {
   27|     10|        super.setSelected(selected, animated: animated)
   28|     10|
   29|     10|        // Configure the view for the selected state
   30|     10|    }
   31|       |    
   32|     10|    func set(forSong song: SongModel) {
   33|     10|        self.selectionStyle = .none
   34|     10|        self.lblArtistName.text = song.artistName
   35|     10|        self.lblSongName.text = song.name
   36|     10|        self.lblGenre.text = song.genre
   37|     10|        self.lblAlbumName.text = song.albumName
   38|     10|        self.imgAlbumCover.dowloadFromServer(link: song.artworkURL)
   39|     10|    }
   40|       |
   41|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/Common/UIUtils.swift:
    1|       |//
    2|       |//  UIUtils.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/19.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |let USER_ID = "user"
   12|       |let ID_TOKEN = "id_token"
   13|       |let FULL_NAME = "full_name"
   14|       |let GIVEN_NAME = "given_name"
   15|       |let FAMILY_NAME = "family_name"
   16|       |let EMAIL = "email"
   17|       |let PROFILE_URL = "profile_url"
   18|       |
   19|       |
   20|      4|func makeUIImageViewCircle(imageView: UIImageView, imgSize: Int) {
   21|      4|        imageView.layer.cornerRadius = CGFloat(imgSize / 2)
   22|      4|        imageView.layer.masksToBounds = true;
   23|      4|}
   24|       |
   25|       |
   26|      0|func getSignedInUser() -> User? {
   27|      0|    //its a singleton so it does not matter how many times it gets called / hit stuff /
   28|      0|    //TODO : rename to userDefaults
   29|      0|    let pref = UserDefaults.standard
   30|      0|
   31|      0|    let userId = pref.string(forKey: USER_ID) ?? ""
   32|      0|    // this means a user is not signed in yoh
   33|      0|    guard !userId.isEmpty else { return nil}
   34|      0|    
   35|      0|    let idToken = pref.string(forKey:  ID_TOKEN)
   36|      0|    let fullName = pref.string(forKey:  FULL_NAME)
   37|      0|    let givenName = pref.string(forKey:  GIVEN_NAME)
   38|      0|    let familyName = pref.string(forKey:  FAMILY_NAME)
   39|      0|    let email = pref.string(forKey:  EMAIL)
   40|      0|    let profileURL = pref.string(forKey:  PROFILE_URL)
   41|      0|    
   42|      0|    let user = User(userId: userId,
   43|      0|                            idToken: idToken,
   44|      0|                            fullName: fullName,
   45|      0|                            givenName: givenName,
   46|      0|                            familyName: familyName,
   47|      0|                            email: email,
   48|      0|                            profileURL: profileURL)
   49|      0|    
   50|      0|    return user
   51|      0|}
   52|       |

/Users/DDube/Developer/iOS/Songhound/Songhound/Common/WireFrame/WireFrameUtils.swift:
    1|       |//
    2|       |//  WireFrameUtils.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/04.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|      1|var mainStoryboard: UIStoryboard {
   12|      1|    return UIStoryboard(name: "Main", bundle: Bundle.main)
   13|      1|}

/Users/DDube/Developer/iOS/Songhound/Songhound/Entities/Artist.swift:
    1|       |//
    2|       |//  Artist.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/19.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |class Artist {
   10|       |    var name: String = ""
   11|       |    var artistID: Int64
   12|       |
   13|      0|    init(name: String, artistID: Int64) {
   14|      0|        self.name = name
   15|      0|        self.artistID = artistID
   16|      0|    }
   17|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/Entities/Song.swift:
    1|       |//
    2|       |//  Song.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/17.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |class Song {
   10|       |    var name: String
   11|       |    var artistName: String
   12|       |    var albumName: String
   13|       |    var genre: String
   14|       |    var popularity: Int
   15|       |    var artworkURL: String
   16|       |    
   17|      0|    init( name: String,  artistName: String, genre: String, popularity: Int, albumName: String,  artworkURL: String) {
   18|      0|        self.name = name
   19|      0|        self.artistName = artistName
   20|      0|        self.genre = genre  // TODO change spelling
   21|      0|        self.popularity = popularity
   22|      0|        self.albumName = albumName
   23|      0|        self.artworkURL = artworkURL
   24|      0|    }
   25|       |
   26|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/Entities/SongModel.swift:
    1|       |//
    2|       |//  SongModel.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/01.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import ObjectMapper
   11|       |
   12|       |struct SongModel {
   13|       |    var id: UInt = 0
   14|       |    var name: String = ""
   15|       |    var artistName: String = ""
   16|       |    var albumName: String = ""
   17|       |    var genre: String = ""
   18|       |    var popularity: Int = 0
   19|       |    var artworkURL: String = ""
   20|       |    var artist: ArtistModel = ArtistModel()
   21|       |}
   22|       |
   23|       |/*
   24|       |     try this so that we can remove the songs model
   25|       | 
   26|       |     func mapping(map: Map) {
   27|       |     distance <- map["distance.value"]
   28|       |     }
   29|       | */
   30|       |
   31|       |extension SongModel: Mappable {
   32|     50|    init?(map: Map) {}
   33|       |    
   34|     50|    mutating func mapping(map: Map) {
   35|     50|        id      <- map["collectionId"]
   36|     50|        name       <- map["trackName"]
   37|     50|        artworkURL      <- map["artworkUrl100"]
   38|     50|        artistName      <- map["artistName"]
   39|     50|        albumName       <- map["collectionName"]
   40|     50|        genre       <- map["genre"]
   41|     50|        // initialise the artist also
   42|     50|        artist.name     <-  map["artistName"]
   43|     50|        artist.artistID     <- map["artistId"]
   44|     50|    }
   45|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/Entities/SongModelResponse.swift:
    1|       |//
    2|       |//  SongModelResponse.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/03.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |import Foundation
    9|       |import ObjectMapper
   10|       |
   11|       |struct SongModelResponse {
   12|       |    var resultCount: Int? = 0
   13|       |    var songs: [SongModel]? = nil
   14|       |}
   15|       |
   16|       |extension SongModelResponse: Mappable {
   17|       |    
   18|      1|    init?(map: Map) {
   19|      1|        
   20|      1|    }
   21|       |    
   22|      1|    mutating func mapping(map: Map) {
   23|      1|        resultCount     <- map["resultCount"]
   24|      1|        songs       <- map["results"]
   25|      1|    }
   26|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/Entities/User.swift:
    1|       |//
    2|       |// Created by Divine Dube on 2019-02-25.
    3|       |// Copyright (c) 2019 Divine Dube. All rights reserved.
    4|       |//
    5|       |
    6|       |import Foundation
    7|       |
    8|       |class User : NSCoder {
    9|       |    var userId: String? = "" {
   10|      0|        willSet(newTotalSteps) {
   11|      0|            print("About to set totalSteps to \(String(describing: newTotalSteps))")
   12|      0|        }
   13|      0|        didSet {
   14|      0|            
   15|      0|        }
   16|       |    }
   17|       |    var idToken: String?
   18|       |    var fullName: String?
   19|       |    var givenName: String?
   20|       |    var familyName: String?
   21|       |    var email: String?
   22|       |    var profileURL: String?
   23|       |
   24|      0|    init(userId: String?, idToken: String?, fullName: String?, givenName: String?, familyName: String?, email: String?, profileURL: String?) {
   25|      0|        self.userId = userId
   26|      0|        self.idToken = idToken
   27|      0|        self.fullName = fullName
   28|      0|        self.givenName = givenName
   29|      0|        self.familyName = familyName
   30|      0|        self.email = email
   31|      0|    }
   32|       |    
   33|       |    //try this new property observers
   34|       |    
   35|       |    
   36|       |
   37|       |
   38|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/SongsDetails/SongsViewController.swift:
    1|       |//
    2|       |//  SongsViewController.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/21.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class SongsViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {
   12|       |    
   13|       |    private var songs: [Song] = []
   14|       |    var artist: Artist? = nil
   15|       |    
   16|       |    @IBOutlet weak var arti: UILabel!
   17|       |    @IBOutlet weak var songsTableView: UITableView!
   18|       |    
   19|       |    
   20|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   21|      0|        return songs.count
   22|      0|    }
   23|       |    
   24|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   25|      0|        let cell = self.songsTableView.dequeueReusableCell(withIdentifier: "songCell", for: indexPath) as! SongTableViewCell
   26|      0|        
   27|      0|        let artistName: String = songs[indexPath.row].artistName
   28|      0|        let songName: String = songs[indexPath.row].name
   29|      0|        //        I will implement something like this in the future but for now what we have is cool so I will cmt it out
   30|      0|        //        let popularity: Int = data[indexPath.row].popularity
   31|      0|        let genre: String = songs[indexPath.row].genre
   32|      0|        let albumName: String = songs[indexPath.row].albumName
   33|      0|        cell.lblArtistName.text = artistName
   34|      0|        cell.lblSongName.text = songName
   35|      0|        cell.lblGenre.text = genre
   36|      0|        cell.lblAlbumName.text = albumName
   37|      0|        
   38|      0|        return cell
   39|      0|    }
   40|       |    
   41|      0|    override func viewDidLoad() {
   42|      0|        super.viewDidLoad()
   43|      0|        self.songsTableView.delegate = self
   44|      0|        self.songsTableView.dataSource = self
   45|      0|        // Do any additional setup after loading the view.
   46|      0|        
   47|      0|        guard artist != nil else {
   48|      0|            print("ooops could not populate the view properly bro")
   49|      0|            return
   50|      0|        }
   51|      0|        
   52|      0|        arti.text = artist?.name
   53|      0|        
   54|      0|        
   55|      0|    }
   56|       |    
   57|      0|    @IBAction func backButton(_ sender: UIButton) {
   58|      0|        self.dismiss(animated: true, completion: nil)
   59|      0|    }
   60|       |    
   61|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/SongsList/DataManager/SongListRemoteDataManager.swift:
    1|       |//
    2|       |//  SongListRemoteDataManager.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/02.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import Alamofire
   11|       |import AlamofireObjectMapper
   12|       |
   13|       |class SongListRemoteDataManager : SongsListRemoteDataManagerInputProtocol {
   14|       |    // this protocol is the one responsible for sending data the presenter
   15|       |    var remoteRequestHandler: SongsListRemoteDataManagerOutputProtocol?
   16|       |    
   17|      1|    func retrieveSongsList() {
   18|      1|        Alamofire
   19|      1|            .request(Endpoints.Songs.fetch(songName: "swift").url, method: .get)
   20|      1|//            .validate() // no need for this but anyway..
   21|      1|            .responseObject { (response: DataResponse<SongModelResponse>) in
   22|      1|                switch response.result {
   23|      1|                case .success(let res):
   24|      1|                    let songs = res.songs!
   25|      1|                    self.remoteRequestHandler?.onSongsRetrieved(songs)
   26|      1|                case .failure(let error):
   27|      0|                    print(error)
   28|      1|                }
   29|      1|            }
   30|      1|    }
   31|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/SongsList/Interactor/SongsListInteractor.swift:
    1|       |//
    2|       |//  SongsListInteractor.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/01.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |
   12|       |// the buss logic goes here
   13|       |// this protocol can do output input
   14|       |class SongsListInterator: SongsListInteratorInputProtocol {
   15|       |// this is the input Interator so its responsible for actually getting in the input
   16|       |
   17|       |    var presenter: SongsListInteratorOutputProtocol?
   18|       |    var localDataManager: SongsListLocalDataManagerInputProtocol?
   19|       |    var remoteDataManager: SongsListRemoteDataManagerInputProtocol?
   20|       |    // this is our cache of all the data that we get from the model!
   21|       |    var cache: [SongModel]? = nil
   22|       |    
   23|      1|    func retrieveSongsList() {
   24|      1|        remoteDataManager?.retrieveSongsList()
   25|      1|    }
   26|       |
   27|      3|    func getArtist(top selectedId: Int) {
   28|      3|        guard cache != nil, selectedId < cache!.count else {return}
   29|      0|        // TODO elegant way to force unwrap using the guard statement
   30|      0|        onArtistSelected(artist: cache![selectedId].artist)
   31|      0|    }
   32|       |}
   33|       |
   34|       |// output talks to the presenter
   35|       |extension SongsListInterator: SongsListRemoteDataManagerOutputProtocol {
   36|      1|    func onSongsRetrieved(_ songs: [SongModel]) {
   37|      1|        presenter?.didRetrieveSongs(songs)
   38|      1|        cache = songs
   39|      1|    }
   40|       |
   41|      0|    func onError() {
   42|      0|        presenter?.onError()
   43|      0|    }
   44|       |
   45|       |    func onArtistSelected(artist: ArtistModel) {
   46|       |        presenter?.didSelectArtist(artist: artist)
   47|       |    }
   48|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/SongsList/Presenter/SongsListViewPresenter.swift:
    1|       |//
    2|       |//  SongsListViewPresenter.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/01.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |
   10|       |
   11|       |// so this classes characteristic is defined by this protocol that it inherits from
   12|       |// this class communicates with the other classes
   13|       |// get the user response from the View
   14|       |class SongsListViewPresenter: SongListPresenterProtocol {
   15|       |
   16|       |    weak var view: SongsListViewProtocol?
   17|       |    var interactor: SongsListInteratorInputProtocol?
   18|       |    var wireframe: SongsListViewWireFrameProtocol?
   19|       |    
   20|      1|    func viewDidLoad() {
   21|      1|        view?.showLoading()
   22|      1|        interactor?.retrieveSongsList()
   23|      1|    }
   24|       |    
   25|      0|    func showSongDetail(forSong song: SongModel) {
   26|      0|        wireframe?.presentSongDetailsScreen(from: view!, forSong: song)
   27|      0|    }
   28|       |    
   29|      3|    func showSongs(forSelectedArtistId: Int) {
   30|      3|        interactor?.getArtist(top: forSelectedArtistId)
   31|      3|    }
   32|       |}
   33|       |
   34|       |extension SongsListViewPresenter: SongsListInteratorOutputProtocol {
   35|       |
   36|       |
   37|      1|    func didRetrieveSongs(_ songs: [SongModel]) {
   38|      1|        view?.hideLoading()
   39|      1|        view?.showSongsList(songs: songs)
   40|      1|    }
   41|       |    
   42|      0|    func onError() {
   43|      0|        view?.hideLoading()
   44|      0|        view?.showError()
   45|      0|    }
   46|       |
   47|      0|    func didSelectArtist(artist: ArtistModel) {
   48|      0|        wireframe?.presentSongsListViewScreen(from:  view!, forArtist: artist)
   49|      0|    }
   50|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/SongsList/View/SongsListViewController.swift:
    1|       |//
    2|       |//  SongsListViewViewController.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/01.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import PKHUD
   11|       |
   12|       |// TODO must be ablke to mod the navigation controller
   13|       |
   14|       |// TODO GET APP back to the state that it was before VIPER
   15|       |
   16|       |class SongsListViewController: UIViewController {
   17|       |    
   18|       |    //top Items for the songs list view controller
   19|       |    @IBOutlet weak var lblUserName: UILabel!
   20|       |    @IBOutlet weak var imgProfilePicture: UIImageView!
   21|       |    @IBOutlet weak var imgArtist3: UIImageView!
   22|       |    @IBOutlet weak var imgArtist2: UIImageView!
   23|       |    @IBOutlet weak var imgArtist1: UIImageView!
   24|       |    @IBOutlet weak var lblArtistName3: UILabel!
   25|       |    @IBOutlet weak var lblArtistName2: UILabel!
   26|       |    @IBOutlet weak var lblArtistName1: UILabel!
   27|       |    @IBOutlet weak var lblPlaying: UILabel!
   28|       |    @IBOutlet weak var currentLocation: UILabel!
   29|       |    @IBOutlet weak var tableViewSongs: UITableView!
   30|       |    
   31|       |    var presenter: SongListPresenterProtocol?
   32|       |    var songList: [SongModel] = []
   33|       |    //-1 means no image was selected
   34|       |    private var selectedImage = -1
   35|       |    
   36|      1|    override func viewDidLoad() {
   37|      1|        super.viewDidLoad()
   38|      1|        presenter?.viewDidLoad()
   39|      1|        // TODO: Investigate this please why does it not show list with out this
   40|      1|        // also why does it not show the cell separators
   41|      1|        self.tableViewSongs.delegate = self
   42|      1|        self.tableViewSongs.dataSource = self
   43|      1|       // tableViewSongs.tableFooterView = UIView()
   44|      1|
   45|      1|        // Do any additional setup after loading the view.
   46|      1|        setUpTopThreeImages()
   47|      1|    }
   48|       |    
   49|      1|    private func setUpTopThreeImages() {
   50|      1|        makeUIImageViewCircle(imageView: imgProfilePicture, imgSize: 50)
   51|      1|        makeUIImageViewCircle(imageView: imgArtist1, imgSize: 100)
   52|      1|        makeUIImageViewCircle(imageView: imgArtist2, imgSize: 100)
   53|      1|        makeUIImageViewCircle(imageView: imgArtist3, imgSize: 100)
   54|      1|        
   55|      1|        addTapGestureToAnImageView(imageView: imgArtist3)
   56|      1|        addTapGestureToAnImageView(imageView: imgArtist1)
   57|      1|        addTapGestureToAnImageView(imageView: imgArtist2)
   58|      1|    }
   59|       |    
   60|       |    
   61|      3|    func addTapGestureToAnImageView(imageView: UIImageView) {
   62|      3|        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(ViewController.imageTapped(gesture:)))
   63|      3|        imageView.addGestureRecognizer(tapGesture)
   64|      3|        imageView.isUserInteractionEnabled = true
   65|      3|        
   66|      3|        imageTapped(gesture: tapGesture)
   67|      3|    }
   68|       |    
   69|      3|    @objc func imageTapped(gesture: UIGestureRecognizer) {
   70|      3|        if let imageView = gesture.view as? UIImageView {
   71|      3|            print("Hello ")
   72|      3|            // niot sure if this is a good idea on getting by tag
   73|      3|            let tag = imageView.tag
   74|      3|            print("the tag is \(tag)")
   75|      3|            
   76|      3|            switch tag {
   77|      3|            case 0:
   78|      1|                print("img one openi")
   79|      1|                selectedImage = 0
   80|      1|                presenter?.showSongs(forSelectedArtistId: selectedImage)
   81|      3|                    //  performSegue(withIdentifier: "viewSongsForArtist", sender: self)
   82|      3|                    // will perform segue on the presenter since its the only one which can do so
   83|      3|            case 1:
   84|      1|                print("img one open")
   85|      1|                selectedImage = 1
   86|      1|                presenter?.showSongs(forSelectedArtistId: selectedImage)
   87|      3|               // performSegue(withIdentifier: "viewSongsForArtist", sender: self)
   88|      3|            case 2:
   89|      1|                print("img one opennn")
   90|      1|                selectedImage = 2
   91|      1|                presenter?.showSongs(forSelectedArtistId: selectedImage)
   92|      3|              //  performSegue(withIdentifier: "viewSongsForArtist", sender: self)
   93|      3|            case 3:
   94|      0|                print("profile picture selected bro ")
   95|      3|            //    GIDSignIn.sharedInstance().signIn()
   96|      3|            default:
   97|      0|                print("ooops")
   98|      3|                
   99|      3|            }
  100|      3|        }
  101|      3|    }
  102|       |    
  103|       |    
  104|       |}
  105|       |//Song list view protocol
  106|       |extension SongsListViewController: SongsListViewProtocol {
  107|      0|    func onTopThreeArtistClicked() {
  108|      0|        
  109|      0|    }
  110|       |    
  111|      1|    func showSongsList(songs: [SongModel]) {
  112|      1|        songList = songs
  113|      1|        tableViewSongs.reloadData()
  114|      1|    }
  115|       |    
  116|      0|    func showError() {
  117|      0|        HUD.flash(.label("Internet not connect"), delay: 2.0)
  118|      0|    }
  119|       |    
  120|      1|    func showLoading() {
  121|      1|        HUD.show(.progress)
  122|      1|    }
  123|       |    
  124|      1|    func hideLoading() {
  125|      1|        HUD.hide()
  126|      1|    }
  127|       |}
  128|       |
  129|       |extension SongsListViewController:  UITableViewDataSource, UITableViewDelegate  {
  130|      4|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  131|      4|         return songList.count
  132|      4|    }
  133|       |    
  134|     10|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  135|     10|        let cell = self.tableViewSongs.dequeueReusableCell(withIdentifier: "songCell", for: indexPath) as! SongTableViewCell
  136|     10|        let song = songList[indexPath.row]
  137|     10|        cell.set(forSong: song)
  138|     10|        return cell
  139|     10|    }
  140|       |    
  141|      0|    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
  142|      0|        // do stuff when a cell is selected
  143|      0|    }
  144|       |}

/Users/DDube/Developer/iOS/Songhound/Songhound/SongsList/View/ViewController.swift:
    1|       |//
    2|       |//  ViewController.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/02/15.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |import GoogleMaps
   11|       |import Alamofire
   12|       |import SwiftyJSON
   13|       |import MediaPlayer
   14|       |import GoogleSignIn
   15|       |import Firebase
   16|       |import GoogleSignIn
   17|       |
   18|       |class ViewController: UIViewController,
   19|       |                                    UITableViewDataSource,
   20|       |                                    UITableViewDelegate, GIDSignInUIDelegate, GIDSignInDelegate {
   21|       |
   22|       |    @IBOutlet weak var lblUserName: UILabel!
   23|       |    @IBOutlet weak var imgProfilePicture: UIImageView!
   24|       |    @IBOutlet weak var imgArtist3: UIImageView!
   25|       |    @IBOutlet weak var imgArtist2: UIImageView!
   26|       |    @IBOutlet weak var imgArtist1: UIImageView!
   27|       |    @IBOutlet weak var lblArtistName3: UILabel!
   28|       |    @IBOutlet weak var lblArtistName2: UILabel!
   29|       |    @IBOutlet weak var lblArtistName1: UILabel!
   30|       |    @IBOutlet weak var tableViewSongs: UITableView!
   31|       |    @IBOutlet weak var lblPlaying: UILabel!
   32|       |    @IBOutlet weak var currentLocation: UILabel!
   33|       |
   34|       |
   35|       |    private let dispatcher = DispatchQueue(label: "execution-queue", qos: .default, attributes: .concurrent)
   36|       |    private let locationManager = CLLocationManager()
   37|       |    private var data: [Song] = []
   38|       |    //-1 means no image was selected
   39|       |    private var selectedImage = -1
   40|       |    // prefill it with defined artists
   41|       |    // we will get them from the api once we have the good data!
   42|       |    private var topThreeArtists: [Artist] = []
   43|       |
   44|       |    private let apiKey = "566c477a33b65757c982ebd5782c3377"
   45|       |
   46|      0|    override func viewDidLoad() {
   47|      0|        super.viewDidLoad()
   48|      0|        // Do any additional setup after loading the view, typically from a nib.
   49|      0|
   50|      0|        locationManager.delegate = self
   51|      0|        self.tableViewSongs.delegate = self
   52|      0|        self.tableViewSongs.dataSource = self
   53|      0|        GIDSignIn.sharedInstance().delegate = self
   54|      0|        GIDSignIn.sharedInstance().uiDelegate = self
   55|      0|        
   56|      0|      
   57|      0|
   58|      0|        print("assigning the self to the delegate")
   59|      0|        showCurrentPlayingSong()
   60|      0|
   61|      0|        locationManager.requestWhenInUseAuthorization()
   62|      0|      
   63|      0|        makeUIImageViewCircle(imageView: imgProfilePicture, imgSize: 50)
   64|      0|        makeUIImageViewCircle(imageView: imgArtist1, imgSize: 100)
   65|      0|        makeUIImageViewCircle(imageView: imgArtist2, imgSize: 100)
   66|      0|        makeUIImageViewCircle(imageView: imgArtist3, imgSize: 100)
   67|      0|
   68|      0|        addTapGestureToAnImageView(imageView: imgArtist3)
   69|      0|        addTapGestureToAnImageView(imageView: imgArtist1)
   70|      0|        addTapGestureToAnImageView(imageView: imgArtist2)
   71|      0|
   72|      0|        addTapGestureToAnImageView(imageView: imgProfilePicture)
   73|      0|        
   74|      0|       let user = getSignedInUser()
   75|      0|        if let user = user {
   76|      0|            lblUserName.text = user.fullName
   77|      0|            print("user details \(user.fullName!)")
   78|      0|            let prof = user.profileURL ?? ""
   79|      0|            print("the profile is \(prof)")
   80|      0|            downloadImage(urlString: prof )
   81|      0|        }
   82|      0|        
   83|      0|        searchForSongByArtist(songName: "Swift", callback: {songs in
   84|      0|            self.data = songs
   85|      0|            self.setupTopThreeArtists(songs: songs)
   86|      0|            self.tableViewSongs.reloadData()
   87|      0|        })
   88|      0|    }
   89|       |    
   90|       |    
   91|      0|    private func setupTopThreeArtists(songs: [Song]) {
   92|      0|        topThreeArtists.append(Artist(name: songs[0].artistName, artistID: 000))
   93|      0|        topThreeArtists.append(Artist(name: songs[1].artistName, artistID: 000))
   94|      0|        topThreeArtists.append(Artist(name: songs[2].artistName, artistID: 000))
   95|      0|        
   96|      0|        let name = topThreeArtists[0].name
   97|      0|        let name1 = topThreeArtists[1].name
   98|      0|        let name2 = topThreeArtists[2].name
   99|      0|
  100|      0|        lblArtistName1.text = name
  101|      0|        lblArtistName2.text = name1
  102|      0|        lblArtistName3.text = name2
  103|      0|    }
  104|       |
  105|       |//    func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) {
  106|       |//        if let error = error {
  107|       |//            return
  108|       |//        }
  109|       |//
  110|       |//        guard let authentication = user.authentication else { return }
  111|       |//        let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken,
  112|       |//                accessToken: authentication.accessToken)
  113|       |//        // ...
  114|       |//    }
  115|       |//
  116|       |//    func sign(_ signIn: GIDSignIn!, didDisconnectWith user: GIDGoogleUser!, withError error: Error!) {
  117|       |//        // Perform any operations when the user disconnects from app here.
  118|       |//        // ...
  119|       |//    }
  120|       |
  121|       |
  122|      0|    private func createArtist(artist: JSON) -> Artist {
  123|      0|        let artistName = artist["artist_name"].stringValue
  124|      0|        let artistId = artist["artist_id"].int64Value
  125|      0|
  126|      0|        return Artist(name: artistName, artistID: artistId)
  127|      0|    }
  128|       |
  129|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  130|      0|        print("data \(data.count)")
  131|      0|        return data.count
  132|      0|    }
  133|       |
  134|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  135|      0|        let cell = self.tableViewSongs.dequeueReusableCell(withIdentifier: "songCell", for: indexPath) as! SongTableViewCell
  136|      0|        let artistName: String = data[indexPath.row].artistName
  137|      0|        let songName: String = data[indexPath.row].name
  138|      0|
  139|      0|        let genre: String = data[indexPath.row].genre
  140|      0|        let albumName: String = data[indexPath.row].albumName
  141|      0|        cell.lblArtistName.text = artistName
  142|      0|        cell.lblSongName.text = songName
  143|      0|        cell.lblGenre.text = genre
  144|      0|        cell.lblAlbumName.text = albumName
  145|      0|        //ASK: I dont get why this whould be forced to unwrapped
  146|      0|        let cellImageView = cell.imgAlbumCover!
  147|      0|                // will download image later
  148|      0|        let albumCoverURL = data[indexPath.row].artworkURL
  149|      0|        cellImageView.dowloadFromServer(link: albumCoverURL)
  150|      0|
  151|      0|
  152|      0|        return cell
  153|      0|    }
  154|       |
  155|      0|    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
  156|      0|        // I dont know what to show
  157|      0|        //  performSegue(withIdentifier: "viewSongsOfArtist", sender: self)
  158|      0|
  159|      0|    }
  160|       |
  161|       |
  162|      0|    private func reverseGeocoderCoordinates(_ coordinates: CLLocationCoordinate2D, _ didRespond: @escaping (_ response: String) -> Void) {
  163|      0|
  164|      0|        let geocoder = GMSGeocoder()
  165|      0|
  166|      0|
  167|      0|        //the closure is a callback because this does niot exec in the main thread
  168|      0|        geocoder.reverseGeocodeCoordinate(coordinates) { response, error in
  169|      0|            // powerful stuff yoh
  170|      0|            guard let address = response?.firstResult(), let lines = address.lines else {
  171|      0|                return
  172|      0|            }
  173|      0|            let fullAddress = lines.joined(separator: "\n")
  174|      0|            didRespond(fullAddress)
  175|      0|            print("the full address is \(fullAddress)")
  176|      0|        }
  177|      0|    }
  178|       |
  179|       |    /*
  180|       |      example request
  181|       |     http://api.musixmatch.com/ws/1.1/track.search?q_artist=justin bieber&page_size=3&page=1&s_track_rating=desc
  182|       |     */
  183|      0|    private func getTracDetails(songName: String, artistName: String, responseCallback: @escaping (_ response: (DataResponse<Any>)) -> Void) {
  184|      0|        // this is requesting for a particular artist but it should search for a particualer song
  185|      0|        // validate() ??
  186|      0|        // should be able to also search by artist name
  187|      0|        let req = "http://api.musixmatch.com/ws/1.1/track.search?q_track=" +
  188|      0|                (songName.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!) +
  189|      0|                "&q_artist=" + (artistName.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed)!) +
  190|      0|                "&page_size=10&page=1&s_track_rating=desc&apikey=" + (apiKey)
  191|      0|        Alamofire.request(req).responseJSON { (response) in
  192|      0|            responseCallback(response)
  193|      0|        }
  194|      0|    }
  195|       |
  196|      0|     @objc func imageTapped(gesture: UIGestureRecognizer) {
  197|      0|        if let imageView = gesture.view as? UIImageView {
  198|      0|            print("Hello ")
  199|      0|            // niot sure if this is a good idea on getting by tag
  200|      0|            let tag = imageView.tag
  201|      0|            print("the tag is \(tag)")
  202|      0|
  203|      0|            switch tag {
  204|      0|            case 0:
  205|      0|                print("img one openi")
  206|      0|                selectedImage = 0
  207|      0|                performSegue(withIdentifier: "viewSongsForArtist", sender: self)
  208|      0|            case 1:
  209|      0|                print("img one open")
  210|      0|                selectedImage = 1
  211|      0|                performSegue(withIdentifier: "viewSongsForArtist", sender: self)
  212|      0|            case 2:
  213|      0|                print("img one opennn")
  214|      0|                selectedImage = 2
  215|      0|                performSegue(withIdentifier: "viewSongsForArtist", sender: self)
  216|      0|            case 3:
  217|      0|                print("profile picture selected bro ")
  218|      0|                GIDSignIn.sharedInstance().signIn()
  219|      0|            default:
  220|      0|                print("ooops")
  221|      0|                
  222|      0|            }
  223|      0|        }
  224|      0|    }
  225|       |
  226|       |
  227|      0|    func sign(_ signIn: GIDSignIn!, didDisconnectWith user: GIDGoogleUser!, withError error: Error!) {
  228|      0|        if let error = error {
  229|      0|            print("\(error.localizedDescription)")
  230|      0|        } else {
  231|      0|            saveGoogleUserInfo(user: user)
  232|      0|        }
  233|      0|    }
  234|       |
  235|      0|    private func saveGoogleUserInfo(user: GIDGoogleUser) {
  236|      0|        let userId = user.userID
  237|      0|        let idToken = user.authentication.idToken
  238|      0|        let fullName = user.profile.name
  239|      0|        let givenName = user.profile.givenName
  240|      0|        let familyName = user.profile.familyName
  241|      0|        let email = user.profile.email
  242|      0|        let profileURL = user.profile.imageURL(withDimension: 100).absoluteString
  243|      0|        let preferences = UserDefaults.standard
  244|      0|        
  245|      0|        preferences.set(userId, forKey: USER_ID)
  246|      0|        preferences.set(idToken, forKey: ID_TOKEN)
  247|      0|        preferences.set(fullName, forKey: FULL_NAME)
  248|      0|        preferences.set(givenName, forKey: GIVEN_NAME)
  249|      0|        preferences.set(familyName, forKey: FAMILY_NAME)
  250|      0|        preferences.set(email, forKey: EMAIL)
  251|      0|        preferences.set(profileURL, forKey: PROFILE_URL)
  252|      0|    
  253|      0|        let sync = preferences.synchronize()
  254|      0|        print("it sycned \(sync)")
  255|      0|    }
  256|       |
  257|      0|    func sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error!) {
  258|      0|        print("oopps user signed out yoh")
  259|      0|        
  260|      0|        guard let authentication = user.authentication else { return }
  261|      0|        
  262|      0|        let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken,
  263|      0|                                                       accessToken: authentication.accessToken)
  264|      0|        Auth.auth().signInAndRetrieveData(with: credential) { (authResult, error) in
  265|      0|            if let error = error {
  266|      0|                print("user not signed in there was an error bro \(error)")
  267|      0|                return
  268|      0|            }
  269|      0|            print("Yey user signed in bro")
  270|      0|            self.saveGoogleUserInfo(user: user)
  271|      0|            print("the user is \(String(describing: user?.userID))")
  272|      0|            if let user = getSignedInUser() {
  273|      0|                self.lblUserName.text = user.fullName
  274|      0|                if let profileUrl = user.profileURL {
  275|      0|                    self.downloadImage(urlString: profileUrl )
  276|      0|                } else {
  277|      0|                    // TODO: I want to set a default image
  278|      0|                }
  279|      0|            } else {
  280|      0|                print("failed to load user man")
  281|      0|                self.lblUserName.text = ""
  282|      0|            }
  283|      0|        }
  284|      0|    }
  285|       |    
  286|      0|    private func downloadImage(urlString: String) {
  287|      0|        // assuming that its dowloading the image
  288|      0|        dispatcher.async {
  289|      0|            let url = URL(string: urlString)
  290|      0|            print("the image of the profile picture is: \(String(describing: url))")
  291|      0|            if let url = url {
  292|      0|                let data = try? Data(contentsOf: url)
  293|      0|                if let data = data { // unwrap this data or our on the background thread yoh
  294|      0|                    // go to main thread bro
  295|      0|                    DispatchQueue.main.async {
  296|      0|                        // display the downloaded image
  297|      0|                        self.imgProfilePicture.image = UIImage(data: data)
  298|      0|                    }
  299|      0|                }
  300|      0|            }
  301|      0|        }
  302|      0|    }
  303|       |
  304|      0|    func addTapGestureToAnImageView(imageView: UIImageView) {
  305|      0|        let tapGesture = UITapGestureRecognizer(target: self, action: #selector(ViewController.imageTapped(gesture:)))
  306|      0|        imageView.addGestureRecognizer(tapGesture)
  307|      0|        imageView.isUserInteractionEnabled = true
  308|      0|
  309|      0|        //  imageTapped(gesture: tapGesture)
  310|      0|    }
  311|       |
  312|      0|    private func showCurrentPlayingSong() {
  313|      0|
  314|      0|        print("show currently Playing song")
  315|      0|
  316|      0|        let player = MPMusicPlayerController.systemMusicPlayer
  317|      0|
  318|      0|
  319|      0|        if let mediaItem = player.nowPlayingItem {
  320|      0|            let title: String = mediaItem.value(forKey: MPMediaItemPropertyTitle) as! String
  321|      0|            let albumTitle: String = mediaItem.value(forKey: MPMediaItemPropertyTitle) as! String
  322|      0|            let artist: String = mediaItem.value(forKey: MPMediaItemPropertyArtist) as! String
  323|      0|
  324|      0|            print("the title \(title) and albt \(albumTitle) and artist \(artist)")
  325|      0|        }
  326|      0|    }
  327|       |
  328|       |
  329|       |    // this prepare is for the 3 top artists
  330|       |
  331|      0|    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
  332|      0|        print("called bro")
  333|      0|        if segue.identifier == "viewSongsForArtist" {
  334|      0|            if selectedImage >= 0 {
  335|      0|                let controller = segue.destination as! SongsViewController
  336|      0|                controller.artist = topThreeArtists[selectedImage]
  337|      0|            } else {
  338|      0|                print("this image is bad selected image is still 0 ")
  339|      0|            }
  340|      0|        }
  341|      0|    }
  342|       |
  343|       |
  344|       |}
  345|       |
  346|       |extension ViewController: CLLocationManagerDelegate {
  347|      0|    func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
  348|      0|        guard status == .authorizedWhenInUse else {
  349|      0|            return
  350|      0|        }
  351|      0|        locationManager.startUpdatingLocation()
  352|      0|    }
  353|       |
  354|      0|    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
  355|      0|        guard let location = locations.first else {
  356|      0|            // could not get the current location
  357|      0|            print("sorry man could not get the current location")
  358|      0|            return
  359|      0|        }
  360|      0|        print("we know the current location yoh \(location)")
  361|      0|        // MY OWN CLOSURE
  362|      0|        reverseGeocoderCoordinates(location.coordinate) { fullAddressresponse in
  363|      0|            // do something with the response
  364|      0|            // baddd
  365|      0|            self.currentLocation.text = "\(String(describing: fullAddressresponse.components(separatedBy: ",").first!)), \(fullAddressresponse.components(separatedBy: ",")[1]) "
  366|      0|        }
  367|      0|        // use GMSGeocoder to get the address of the user yeah?
  368|      0|        locationManager.stopUpdatingLocation()
  369|      0|    }
  370|       |}
  371|       |
  372|       |

/Users/DDube/Developer/iOS/Songhound/Songhound/SongsList/WireFrame/SongsListWireFrame.swift:
    1|       |//
    2|       |//  SongsListWireFrame.swift
    3|       |//  Songhound
    4|       |//
    5|       |//  Created by Divine Dube on 2019/03/02.
    6|       |//  Copyright © 2019 Divine Dube. All rights reserved.
    7|       |//
    8|       |
    9|       |import UIKit
   10|       |
   11|       |class SongsListWireFrame: SongsListViewWireFrameProtocol {
   12|       |   
   13|       |    // some how this is static yoh
   14|      1|    class func createSongsListModule() -> UIViewController {
   15|      1|        // instatiate the main view controller
   16|      1|        let navController = mainStoryboard.instantiateViewController(withIdentifier: "SongsViewNavigationController")
   17|      1|        
   18|      1|        if let view = navController.children.first as? SongsListViewController {
   19|      1|            // instatiate the presenter here bro
   20|      1|            var presenter: SongListPresenterProtocol & SongsListInteratorOutputProtocol = SongsListViewPresenter()
   21|      1|            var interactor: SongsListInteratorInputProtocol & SongsListRemoteDataManagerOutputProtocol = SongsListInterator()
   22|      1|          //  let localDataManager: SongsListDataManagerInputProtocol = No local data manager not as of yet bro
   23|      1|            let remoteDataManager: SongsListRemoteDataManagerInputProtocol = SongListRemoteDataManager()
   24|      1|            let wireframe: SongsListWireFrame = SongsListWireFrame()
   25|      1|            
   26|      1|            view.presenter = presenter
   27|      1|            presenter.view = view
   28|      1|            presenter.wireframe = wireframe
   29|      1|            presenter.interactor = interactor
   30|      1|            interactor.presenter = presenter
   31|      1|            interactor.remoteDataManager = remoteDataManager
   32|      1|            remoteDataManager.remoteRequestHandler = interactor
   33|      1|            
   34|      1|            return navController
   35|      1|        }
   36|      0|        return UIViewController()
   37|      1|    }
   38|       |    
   39|       |    //actuall wireframing methods
   40|       |    
   41|      0|    func presentSongDetailsScreen(from view: SongsListViewProtocol, forSong song: SongModel) {
   42|      0|      //  let songDetailController = songDetailController
   43|      0|    }
   44|       |    
   45|      0|    func presentSongsListViewScreen(from view: SongsListViewProtocol, forArtist artist: ArtistModel) {
   46|      0|        let artistSongsList = ArtistsListViewWireFrame.createArtistListViewModule(forArtist: artist)
   47|      0|
   48|      0|        if let sourceView = view as? UIViewController {
   49|      0|            sourceView.navigationController?.pushViewController(artistSongsList, animated: true)
   50|      0|        }
   51|      0|    }
   52|       |}

